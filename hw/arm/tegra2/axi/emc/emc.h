/*
 * ARM NVIDIA Tegra2 emulation.
 *
 * Copyright (c) 2014-2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* Autogenerated from TRM v02p */

#ifndef TEGRA_EMC_H
#define TEGRA_EMC_H

#define INTSTATUS_OFFSET 0x0
#define INTSTATUS_RESET  0x00000000
typedef union intstatus_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int refresh_overflow_int:1;/* Refresh request overflow timeout. 0 = CLEAR 1 = SET */
        unsigned int clkchange_complete_int:1;/* CAR/EMC clock-change handshake complete. 0 = CLEAR 1 = SET */
        unsigned int mrr_divld_int:1;       /* LPDDR2 MRR data is available to be read. 0 = CLEAR 1 = SET */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} intstatus_t;

#define INTMASK_OFFSET 0x4
#define INTMASK_RESET  0x00000000
typedef union intmask_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int refresh_overflow_intmask:1;/* Mask for refresh request overflow timeout. 0 = MASKED 1 = UNMASKED */
        unsigned int clkchange_complete_intmask:1;/* Mask for CAR/EMC clock-change handshake complete. 0 = MASKED 1 = UNMASKED */
        unsigned int mrr_divld_intmask:1;   /* Mask for MRR data available. 0 = MASKED 1 = UNMASKED */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} intmask_t;

#define DBG_OFFSET 0x8
#define DBG_RESET  0x01000400
typedef union dbg_u {
    struct {
        unsigned int read_mux:1;            /* controls whether reads to the configuration registers are done from the assembly or active state. 0 = ACTIVE 1 = ASSEMBLY */
        unsigned int write_mux:1;           /* controls whether writes to the configuration registers are done from the assembly or active state. 0 = ASSEMBLY 1 = ACTIVE */
        unsigned int force_update:1;        /* causes the active state to get updated with the assembly state immediately upon writing the TIMING_CONTROL register. 0 = DISABLED 1 = ENABLED */
        unsigned int undefined_bit_3:1;
        unsigned int mrs_wait:1;            /* should be set to MRS_256 when a non-mobile DRAM is used because they require a 200 cycle delay between the DLL reset and any read commands. 0 = MRS_2 1 = MRS_256 */
        unsigned int periodic_qrst:1;       /* specifies whether or not to periodic reset the FBIO read-data fifo during normal operation. The periodic resets can be used for graceful recovery from an intermittent failure condition; only the initial reset is absolutely required. 0 = DISABLED 1 = ENABLED */
        unsigned int undefined_bits_6_8:3;
        unsigned int read_dqm_ctrl:1;       /* controls whether the dqm signals during reads are managed for power (not relevant for DDR). If set to MANAGED, EMC only turns them on when necessary. If set to ALWAYS_ON, the dqm signals are enabled during non-write operation. 0 = MANAGED 1 = ALWAYS_ON */
        unsigned int ap_req_busy_ctrl:1;    /* determines whether the busy signal from the auto-precharge cancellation (APC) fifo is allowed to stall requests to the EMC. 0 = DISABLED 1 = ENABLED */
        unsigned int undefined_bits_11_23:13;
        unsigned int cfg_priority:1;        /* determines the priority of cfg accesses to the DRAM. Setting this register to ENABLED gives DRAM config cycles (refresh, mrs, emrs, etc.) higher priority over real time requestors. The DISABLED setting gives the real time requestors higher priority than DRAM config cycles. Do not program to DISABLED unless for debugging. 0 = DISABLED 1 = ENABLED */
        unsigned int undefined_bits_25_31:7;
    };

    uint32_t reg32;
} dbg_t;

#define CFG_OFFSET 0xC
#define CFG_RESET  0x0300FF00
typedef union cfg_u {
    struct {
        unsigned int pre_idle_en:1;         /* preemptively closes all of the banks after the EMC has been idle for PRE_IDLE_CYCLES cycles and there are banks open. PRE_IDLE_EN can be enabled if violating tRAS max is an issue; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_1_7:7;
        unsigned int pre_idle_cycles:8;     /* cycles after which an idle bank may be closed. Note that 0 is an illegal setting for PRE_IDLE_CYCLES */
        unsigned int clear_ap_prev_spreq:1; /* used to try to clear the auto-precharge bit on the previous request if the next request is on the same page.  The previous request has to be in reach for this to happen. */
        unsigned int undefined_bits_17_23:7;
        unsigned int auto_pre_rd:1;         /* enable auto-precharge in the EMC for reads. This bits, when set to DISABLE, will override the settings in the MC register. Otherwise, they permit clients to make auto-precharge requests as specified by the Memory Controller. */
        unsigned int auto_pre_wr:1;         /* enable auto-precharge in the EMC for writes. This bits, when set to DISABLE, will override the settings in the MC register. Otherwise, they permit clients to make auto-precharge requests as specified by the Memory Controller. */
        unsigned int undefined_bits_26_28:3;
        unsigned int dram_acpd:1;           /* allows the DRAM controller to perform opportunistic active powerdown control using the CKE pin on the DRAM. The behavior of the powerdown control logic is controlled by the PDEX2* and *2PDEN registers. The value of DRAM_ACPD should only be changed when CKE is low, e.g., during software-controlled self-refresh or before DRAM initialization. If enabling ACPD, you should ALWAYS enable DRAM_CLKSTOP_PDSR_ONLY. Not doing so will result in sub-optimal power-down & clockstop performance. The powerdown conditions are met within a couple of cycles after the clock has stopped, so the clock must be restarted & minimum clock timings met before powerdown can be issued and clock restopped; 0 = NO_POWERDOWN; 1 = ACTIVE_POWERDOWN */
        unsigned int dram_clkstop_pdsr_only:1;/* clockstop (if enabled) only allowed to happen if CKE=0 (for all CKE bits associated w/ clock) 0 = DISABLED 1 = ENABLED */
        unsigned int dram_clkstop:1;        /* allows the DRAM controller to turn off the clock to the DRAM when it is safe to do so (no operations are ongoing, and tRFC, tMRS, tRP, etc. have all been satisfied; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} cfg_t;

#define ADR_CFG_OFFSET 0x10
#define ADR_CFG_RESET  0x00040202
typedef union adr_cfg_u {
    struct {
        unsigned int emem_colwidth:3;       /* width of column address of the attached SDRAM device; 0 = column width equals 7; 1 = column width equals 8; 2 = column width equals 9; 3 = column width equals 10; 4 = column width equals 11 */
        unsigned int undefined_bits_3_7:5;
        unsigned int emem_bankwidth:2;      /* width of bank address of the attached SDRAM device; 1 = device internal bank equals 2; 2 = device internal bank equals 4; 3 = device internal bank equals 8 */
        unsigned int undefined_bits_10_15:6;
        unsigned int emem_devsize:4;        /* size of the attached SDRAM device used to generate width of row address; 0 = D4 MB; 1 = D8 MB; 2 = D16 MB; 3 = D32 MB; 4 = D64 MB; 5 = D128 MB; 6 = D256 MB; 7 = D512 MB; 8 = D1024MB; 8 = D1GB */
        unsigned int undefined_bits_20_23:4;
        unsigned int emem_numdev:2;         /* : the number of attached devices. If more than one device is attached, the DEVSIZE, COLWIDTH, and BANKWIDTH configurations for the second device will be defined by the fields in ADR_CFG_1, while the fields in ADR_CFG will only apply to the first device; 0 = N1 (Number of Devices equals 1); 1 = N2 (Number of Devices equals 2) */
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} adr_cfg_t;

#define ADR_CFG_1_OFFSET 0x14
#define ADR_CFG_1_RESET  0x00040202
typedef union adr_cfg_1_u {
    struct {
        unsigned int emem1_colwidth:3;      /* width of column address of the attached SDRAM device; 0 = column width equals 7; 1 = column width equals 8; 2 = column width equals 9; 3 = column width equals 10; 4 = column width equals 11 */
        unsigned int undefined_bits_3_7:5;
        unsigned int emem1_bankwidth:2;     /* width of bank address of the attached SDRAM device; 2 = device internal bank equals 4; 3 = device internal bank equals 8 */
        unsigned int undefined_bits_10_15:6;
        unsigned int emem1_devsize:4;       /* size of the attached SDRAM device used to generate width of row address; 0 = D4 MB; 1 = D8 MB; 2 = D16 MB; 3 = D32 MB; 4 = D64 MB; 5 = D128 MB; 6 = D256 MB; 7 = D512 MB; 8 = D1024MB; 8 = D1GB */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} adr_cfg_1_t;

#define REFCTRL_OFFSET 0x20
#define REFCTRL_RESET  0x00000000
typedef union refctrl_u {
    struct {
        unsigned int device_refresh_disable:2;/* disables refresh to individual attached device (1 bit per dram chip-select) */
        unsigned int undefined_bits_2_30:29;
        unsigned int ref_valid:1;           /* enable refresh controller; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} refctrl_t;

#define PIN_OFFSET 0x24
#define PIN_RESET  0x00000000
typedef union pin_u {
    struct {
        unsigned int pin_cke:1;             /* selects the level of the CKE pin. This can be used to place the DRAM in power down state. PIN_CKE value is applied all CKE pins; 0 = POWERDOWN; 1 = NORMAL */
        unsigned int undefined_bits_1_3:3;
        unsigned int pin_dqm:1;             /* is used to always mask DRAM writes. This pin should only be used for initialization. Certain DRAM vendors (e.g., Samsung), require the DQM to be high during initialization. The register value should be set to NORMAL after the initialization sequence; 0 = NORMAL; 1 = INACTIVE */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} pin_t;

#define TIMING_CONTROL_OFFSET 0x28
#define TIMING_CONTROL_RESET  0x00000000
typedef union timing_control_u {
    struct {
        unsigned int timing_update:1;
        unsigned int undefined_bits_1_31:31;
    };

    uint32_t reg32;
} timing_control_t;

#define RC_OFFSET 0x2C
#define RC_RESET  0x0000003F
typedef union rc_u {
    struct {
        unsigned int rc:6;                  /* specifies the row cycle time. This is the minimum number of cycles between activate commands to the same bank. LPDDR2: ceil((tRASmin+tRPpb)/tCK) DDR2: ceil(tRC/tCK) */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} rc_t;

#define RFC_OFFSET 0x30
#define RFC_RESET  0x0000003F
typedef union rfc_u {
    struct {
        unsigned int rfc:9;                 /* specifies the auto refresh cycle time. This is the minimum number of cycles between an auto refresh command and a subsequent auto refresh or activate command. LPDDR2: ceil(tRFCab/tCK)  DDR2  : ceil(tRFC/tCK) */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} rfc_t;

#define RAS_OFFSET 0x34
#define RAS_RESET  0x0000003F
typedef union ras_u {
    struct {
        unsigned int ras:6;                 /* specifies the row active time. This is the minimum number of cycles between an activate command and a precharge command to the same bank. LPDDR2: ceil(tRASmin/tCK); min = 3  DDR2  : ceil(tRASmin/tCK) */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} ras_t;

#define RP_OFFSET 0x38
#define RP_RESET  0x0000003F
typedef union rp_u {
    struct {
        unsigned int rp:6;                  /* specifies the row precharge time. This is the minimum number of cycles between a precharge command and an activate command to the same bank. LPDDR2: ceil(tRPpb/tCK); min = 3  DDR2  : ceil(tRP/tCK) */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} rp_t;

#define R2W_OFFSET 0x3C
#define R2W_RESET  0x0000001F
typedef union r2w_u {
    struct {
        unsigned int r2w:5;                 /* specifies the minimum number of cycles from any read command to any write command, irrespective of bank. This parameter guarantees the read->write turn-around time on the bus. Largest programming value is 29 LPDDR2: ceilRL + ceil(tDQSCKmax/tCK) + 2 - WL  DDR2 w/o ODT: 4 DDR2 w/  ODT: 5 */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} r2w_t;

#define W2R_OFFSET 0x40
#define W2R_RESET  0x0000001F
typedef union w2r_u {
    struct {
        unsigned int w2r:5;                 /* specifies the minimum number of cycles from a write command to a read command, irrespective of bank. Largest programming value is 29 LPDDR2/DDR2: 2 + max(2, ceil(tWTR/tCK)) */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} w2r_t;

#define R2P_OFFSET 0x44
#define R2P_RESET  0x0000001F
typedef union r2p_u {
    struct {
        unsigned int r2p:5;                 /* specifies the minimum number of cycles from a read command to a precharge command for the same bank. LPDDR2: ceil(tRTP/tCK); min = 2; add 1 if LPDDR2-S2  DDR2: ceil(tRTP/tCK) */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} r2p_t;

#define W2P_OFFSET 0x48
#define W2P_RESET  0x0000001F
typedef union w2p_u {
    struct {
        unsigned int w2p:5;                 /* specifies the minimum number of cycles from a write command to a precharge command for the same bank.  LPDDR2: ceilWL + 2 + max(3, ceil(tWR/tCK))  DDR2: WL + 1 + max(2, ceil(tWR/tCK)) */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} w2p_t;

#define RD_RCD_OFFSET 0x4C
#define RD_RCD_RESET  0x0000001F
typedef union rd_rcd_u {
    struct {
        unsigned int rd_rcd:6;              /* specifies the RAS to CAS delay. RD_RCD is the minimum number of cycles between an activate command and a read command to the same bank. LPDDR2: ceil(tRCD/tCK); min = 3  DDR2: ceil(tRCD/tCK) */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} rd_rcd_t;

#define WR_RCD_OFFSET 0x50
#define WR_RCD_RESET  0x0000001F
typedef union wr_rcd_u {
    struct {
        unsigned int wr_rcd:6;              /* minimum number of cycles between an activate command and a write command to the same bank. LPDDR2: ceilceil(tRCD/tCK); min = 3  DDR2: ceil(tRCD/tCK) */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} wr_rcd_t;

#define RRD_OFFSET 0x54
#define RRD_RESET  0x0000000F
typedef union rrd_u {
    struct {
        unsigned int rrd:4;                 /* specifies the Bank X Act to Bank Y Act command delay. LPDDR2: ceilceil(tRRD/tCK); min = 2  DDR2: ceil(tRRD/tCK) */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} rrd_t;

#define REXT_OFFSET 0x58
#define REXT_RESET  0x00000001
typedef union rext_u {
    struct {
        unsigned int rext:4;                /* specifies the read to read delay for reads when multiple physical devices are present. LPDDR2:      if (tCK >= 6) REXT = 2      else if (tCK >= 2) REXT = 3      else REXT = 4 DDR2:  1 */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} rext_t;

#define WDV_OFFSET 0x5C
#define WDV_RESET  0x00000000
typedef union wdv_u {
    struct {
        unsigned int wdv:4;                 /* the number of cycles to post (delay) write data from being asserted to the rams. 15 = MAX LPDDR2: WL   DDR2: WL - 1 */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} wdv_t;

#define QUSE_OFFSET 0x60
#define QUSE_RESET  0x00000002
typedef union quse_u {
    struct {
        unsigned int quse:4;                /* tells the chip when to look for read return data.  LPDDR2/DDR2: obtained from characterization */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} quse_t;

#define QRST_OFFSET 0x64
#define QRST_RESET  0x00000001
typedef union qrst_u {
    struct {
        unsigned int qrst:4;                /* time from expiration of QSAFE until reset is issued LPDDR2: ceilRL - 2  DDR2: CL - 2 */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} qrst_t;

#define QSAFE_OFFSET 0x68
#define QSAFE_RESET  0x00000007
typedef union qsafe_u {
    struct {
        unsigned int qsafe:4;               /* time from a read command to when it is safe to issue a QRST (delayed by the QRST parameter). LPDDR2/DDR2: QSAFE &gt;= RDV - QRST */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} qsafe_t;

#define RDV_OFFSET 0x6C
#define RDV_RESET  0x00000008
typedef union rdv_u {
    struct {
        unsigned int rdv:5;                 /* time from read command to latching the read data from the pad macros. 15 = MAX LPDDR2: ceilRL + 5 + ceil(tDQSCKmax/tCK)  DDR2: CL + 7 for DDR2 */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} rdv_t;

#define REFRESH_OFFSET 0x70
#define REFRESH_RESET  0x0000001F
typedef union refresh_u {
    struct {
        unsigned int refresh_lo:5;          /* specifies the interval between refresh requests (LSB portion) 31 = MAX */
        unsigned int refresh:11;            /* specifies the interval between refresh requests (MSB portion) */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} refresh_t;

#define BURST_REFRESH_NUM_OFFSET 0x74
#define BURST_REFRESH_NUM_RESET  0x00000000
typedef union burst_refresh_num_u {
    struct {
        unsigned int burst_refresh_num:4;   /* specify the refresh burst count. 0 = Burst Refresh count equals 1 1 = Burst Refresh count equals 2 2 = Burst Refresh count equals 4 3 = Burst Refresh count equals 8 4 = Burst Refresh count equals 16 5 = Burst Refresh count equals 32 6 = Burst Refresh count equals 64 7 = Burst Refresh count equals 128 8 = Burst Refresh count equals 256 9 = Burst Refresh count equals 512 9 = MAX */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} burst_refresh_num_t;

#define PDEX2WR_OFFSET 0x78
#define PDEX2WR_RESET  0x0000000E
typedef union pdex2wr_u {
    struct {
        unsigned int pdex2wr:4;             /* specify the timing delay from exit of powerdown mode to a write command. Largest allowed value is 14 LPDDR2/DDR2: ceil(tXP/tCLK)+1 */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} pdex2wr_t;

#define PDEX2RD_OFFSET 0x7C
#define PDEX2RD_RESET  0x0000000E
typedef union pdex2rd_u {
    struct {
        unsigned int pdex2rd:4;             /* specify the timing delay from exit of powerdown mode to a read command. Largest allowed value is 14 LPDDR2/DDR2: ceil(tXP/tCLK)+1 */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} pdex2rd_t;

#define PCHG2PDEN_OFFSET 0x80
#define PCHG2PDEN_RESET  0x0000000F
typedef union pchg2pden_u {
    struct {
        unsigned int pchg2pden:5;           /* specify the timing delay from a precharge command to powerdown entry. LPDDR2/DDR2: ceil(tRP/tCK) */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} pchg2pden_t;

#define ACT2PDEN_OFFSET 0x84
#define ACT2PDEN_RESET  0x0000000F
typedef union act2pden_u {
    struct {
        unsigned int act2pden:5;            /* specify the timing delay from an activate, mrs or emrs command to powerdown entry. LPDDR2: ceilmax(8, ceil(tRCD/tCK)) DDR2: ceil(tRCD/tCLK) */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} act2pden_t;

#define AR2PDEN_OFFSET 0x88
#define AR2PDEN_RESET  0x0000001F
typedef union ar2pden_u {
    struct {
        unsigned int ar2pden:5;             /* specify the timing delay from an autorefresh command to powerdown entry. LPDDR2/DDR2: 1 */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} ar2pden_t;

#define RW2PDEN_OFFSET 0x8C
#define RW2PDEN_RESET  0x0000000F
typedef union rw2pden_u {
    struct {
        unsigned int rw2pden:6;             /* specify the timing delay from a read/write command to powerdown entry. Auto-precharge timing must be taken into account when programming this field. LPDDR2: ceilmax(RL+ceil((tDQSCKmax+tRP)/tCK)+1, WL+1+ceil((tWR+tRP)/tCK))  DDR2: max(RL+ceil((tDQSCKmax+tRP)/tCK)+1, WL+ceil((tWR+tRP)/tCK)) */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} rw2pden_t;

#define TXSR_OFFSET 0x90
#define TXSR_RESET  0x000007FF
typedef union txsr_u {
    struct {
        unsigned int txsr:12;               /* cycles between self-refresh exit & first DRAM command Largest allowed value is 0xffe LPDDR2: ceilceil(tXSR/tCK); min = 2  DDR2: ceil(tXSR/tCK) */
        unsigned int undefined_bits_12_31:20;
    };

    uint32_t reg32;
} txsr_t;

#define TCKE_OFFSET 0x94
#define TCKE_RESET  0x0000000E
typedef union tcke_u {
    struct {
        unsigned int tcke:4;                /* specify minimum CKE pulse width. LPDDR2: ceilmax(tCKE, ceil(tXP/tCKmin)): tCKmin is the tCK of the max frequency of the DRAM parts used  DDR2: tCKE */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} tcke_t;

#define TFAW_OFFSET 0x98
#define TFAW_RESET  0x00000000
typedef union tfaw_u {
    struct {
        unsigned int tfaw:6;                /* specify the width of the FAW (four-activate window) for 8-bank devices. Set to 0 to disable this timing check. Only 4 activates may occur withing the rolling window.  LPDDR2: ceilceil(tFAW/tCK); min = 8  DDR2: ceil(tFAW/tCK) */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} tfaw_t;

#define TRPAB_OFFSET 0x9C
#define TRPAB_RESET  0x00000000
typedef union trpab_u {
    struct {
        unsigned int trpab:6;               /* specify precharge-all tRP allowance for 8-bank devices. Setting this field to 0 will cause EMC to use TRP.TRP for precharge-all. LPDDR2: ceilceil((tRPpb+3)/tCK); min = 3  DDR2: ceil((tRP + tCK)/tCK) */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} trpab_t;

#define TCLKSTABLE_OFFSET 0xA0
#define TCLKSTABLE_RESET  0x00000000
typedef union tclkstable_u {
    struct {
        unsigned int tclkstable:4;          /* specify minimum number of cycles of a stable clock period prior to exiting powerdown or self-refresh modes. LPDDR2: ceilmax(5, ceil(tRFC]/tCKmin/4) - 2): tCKmin is the tCK of the max frequency of the DRAM parts used  DDR2: 2 */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} tclkstable_t;

#define TCLKSTOP_OFFSET 0xA4
#define TCLKSTOP_RESET  0x00000002
typedef union tclkstop_u {
    struct {
        unsigned int tclkstop:4;            /* delay from last command to stopping the external clock to DRAM devices. LPDDR2/DDR2: 2 */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} tclkstop_t;

#define TREFBW_OFFSET 0xA8
#define TREFBW_RESET  0x00000000
typedef union trefbw_u {
    struct {
        unsigned int trefbw:14;             /* specify the width of the burst-refresh window. If set to a non-zero value, only 8 refreshes will occur in this rolling window. Set to 0 to disable this timing check.  LPDDR2: ceilceil(32*tRFCab/tCK)  DDR2: 0 */
        unsigned int undefined_bits_14_31:18;
    };

    uint32_t reg32;
} trefbw_t;

#define QUSE_EXTRA_OFFSET 0xAC
#define QUSE_EXTRA_RESET  0x00000000
typedef union quse_extra_u {
    struct {
        unsigned int quse_extra:4;
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} quse_extra_t;

#define ODT_WRITE_OFFSET 0xB0
#define ODT_WRITE_RESET  0x00000000
typedef union odt_write_u {
    struct {
        unsigned int odt_wr_delay:3;        /* Set this field = ABS ( WL - ceiling(tAOND) - 2 ). The valid programming range is 0 <= ODT_WR_DELAY <= 2 if ODT_B4_WRITE=0, 0 <= ODT_WR_DELAY <= 1 if ODT_B4_WRITE=1 */
        unsigned int undefined_bits_3_29:27;
        unsigned int odt_b4_write:1;        /* If this field == 1, ODT is turned on ODT_WR_DELAY cycles prior to dram WRITE command. If this field == 0, ODT is turned on ODT_WR_DELAY cycles after dram WRITE command. Set ODT_B4_WRITE to 1 if ( WL - ceiling(tAOND) - 2 ) < 0 */
        unsigned int enable_odt_during_write:1;/* enables ODT to be turned on prior to issuing write to DRAM. If ENABLE_ODT_DURING_WRITE = 1 and DISABLE_ODT_DURING_READ = 0, ODT will always be enabled after 1st write */
    };

    uint32_t reg32;
} odt_write_t;

#define ODT_READ_OFFSET 0xB4
#define ODT_READ_RESET  0x00000000
typedef union odt_read_u {
    struct {
        unsigned int odt_rd_delay:3;        /* Set this field = ABS ( RL - ceiling(tAOFD) - 2 ). The valid programming range is 0 <= ODT_RD_DELAY <= 2 if ODT_B4_READ=0, 0 <= ODT_RD_DELAY <= 1 if ODT_B4_READ=1 */
        unsigned int undefined_bits_3_29:27;
        unsigned int odt_b4_read:1;         /* If this field == 1, ODT is turned off ODT_RD_DELAY cycles prior to dram READ command. If this field == 0, ODT is turned off ODT_RD_DELAY cycles after dram READ command. Set ODT_B4_READ to 1 if ( RL - ceiling(tAOFD) - 2 ) < 0 */
        unsigned int disable_odt_during_read:1;/* enables ODT to be turned off prior to issuing read to DRAM. If this field == 0, ODT state will not be changed for reads. If this field == 1, Turn off ODT prior to READ command (has no effect if ODT ENABLE_ODT_DURING_WRITE == 0, as ODT will always be disabled) */
    };

    uint32_t reg32;
} odt_read_t;

#define MRS_OFFSET 0xCC
#define MRS_RESET  0x00000000
typedef union mrs_u {
    struct {
        unsigned int mrs_adr:14;            /* mode-register data to be written */
        unsigned int undefined_bits_14_19:6;
        unsigned int mrs_ba:2;              /* Set to 0x0 for MRS */
        unsigned int undefined_bits_22_29:8;
        unsigned int mrs_dev_selectn:2;     /* active low chip-select, 0x0 applies command to both devices, 0x2 to for only dev0, 0x1 for only dev1 */
    };

    uint32_t reg32;
} mrs_t;

#define EMRS_OFFSET 0xD0
#define EMRS_RESET  0x00000000
typedef union emrs_u {
    struct {
        unsigned int emrs_adr:14;           /* mode-register data to be written */
        unsigned int undefined_bits_14_19:6;
        unsigned int emrs_ba:2;             /* Set to 0x1 for EMRS (and where applicable, 0x2 for EMRS2, and 0x3 for EMRS3) */
        unsigned int undefined_bits_22_29:8;
        unsigned int emrs_dev_selectn:2;    /* active low chip-select, 0x0 applies command to both devices, 0x2 to for only dev0, 0x1 for only dev1 */
    };

    uint32_t reg32;
} emrs_t;

#define REF_OFFSET 0xD4
#define REF_RESET  0x00000000
typedef union ref_u {
    struct {
        unsigned int ref_cmd:1;             /* causes the hardware to perform a REFRESH to all DRAM banks */
        unsigned int undefined_bits_1_7:7;
        unsigned int ref_num:8;             /* perform (REF_NUM + 1) refresh cycles */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} ref_t;

#define PRE_OFFSET 0xD8
#define PRE_RESET  0x00000000
typedef union pre_u {
    struct {
        unsigned int pre_cmd:1;             /* causes the hardware to perform a PRECHARGE to all DRAM banks */
        unsigned int undefined_bits_1_29:29;
        unsigned int pre_dev_selectn:2;     /* active low chip-select, 0x0 applies command to both devices, 0x2 to for only dev0, 0x1 for only dev1 */
    };

    uint32_t reg32;
} pre_t;

#define NOP_OFFSET 0xDC
#define NOP_RESET  0x00000000
typedef union nop_u {
    struct {
        unsigned int nop_cmd:1;             /* causes the hardware to perform a NOP to all DRAM banks */
        unsigned int undefined_bits_1_31:31;
    };

    uint32_t reg32;
} nop_t;

#define SELF_REF_OFFSET 0xE0
#define SELF_REF_RESET  0xC0000000
typedef union self_ref_u {
    struct {
        unsigned int self_ref_cmd:1;        /* causes the hardware to issue a SELF_REFRESH command. While CMD:ENABLED, the CKE pin is held deasserted. The CMD:ENABLED state will override the PIN:CKE setting. The DRAM will ignore all accesses until CMD:DISABLED. 0 = DISABLED 1 = ENABLED */
        unsigned int undefined_bits_1_29:29;
        unsigned int sref_dev_selectn:2;    /* active low chip-select, 0x0 applies command to both devices, 0x2 to for only dev0, 0x1 for only dev1, 0x3 for neither device */
    };

    uint32_t reg32;
} self_ref_t;

#define DPD_OFFSET 0xE4
#define DPD_RESET  0x00000000
typedef union dpd_u {
    struct {
        unsigned int dpd_cmd:1;             /* causes the hardware to issue the deep power down command (Burst Terminate w/ cke low). While in DPD mode, the DRAM will not maintain data integrity. While CMD:ENABLED, the CKE pin is held deasserted. The CMD:ENABLED state will override the PIN:CKE setting. The DRAM will ignore all accesses until CMD:DISABLED. 0 = DISABLED 1 = ENABLED */
        unsigned int undefined_bits_1_29:29;
        unsigned int dpd_dev_selectn:2;     /* active low chip-select, 0x0 applies command to both devices, 0x2 to for only dev0, 0x1 for only dev1 */
    };

    uint32_t reg32;
} dpd_t;

#define MRW_OFFSET 0xE8
#define MRW_RESET  0x00000000
typedef union mrw_u {
    struct {
        unsigned int mrw_op:8;              /* data to be written */
        unsigned int undefined_bits_8_15:8;
        unsigned int mrw_ma:8;              /* register address */
        unsigned int undefined_bits_24_29:6;
        unsigned int mrw_dev_selectn:2;     /* active-low chip-select, 0x0 applies command to both devices, 0x2 to for only dev0, 0x1 for dev1 */
    };

    uint32_t reg32;
} mrw_t;

#define MRR_OFFSET 0xEC
#define MRR_RESET  0x00000000
typedef union mrr_u {
    struct {
        unsigned int mrr_data:16;           /* data returned */
        unsigned int mrr_ma:8;              /* register address */
        unsigned int undefined_bits_24_29:6;
        unsigned int mrr_dev_selectn:2;     /* active-low chip-select, choose which device to send the command to. (enum for safety). 0 = ILLEGAL 1 = DEV1 2 = DEV0 3 = RESERVED */
    };

    uint32_t reg32;
} mrr_t;

#define FBIO_CFG1_OFFSET 0xF4
#define FBIO_CFG1_RESET  0x00000000
typedef union fbio_cfg1_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int cfg_den_early:1;       /* determines whether the output enable is the same width as data (DEN_EARLY=0) or 1/2 bit time wider on either end (DEN_EARLY=1). 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_17_31:15;
    };

    uint32_t reg32;
} fbio_cfg1_t;

#define FBIO_DQSIB_DLY_OFFSET 0xF8
#define FBIO_DQSIB_DLY_RESET  0x00000000
typedef union fbio_dqsib_dly_u {
    struct {
        unsigned int cfg_dqsib_dly_byte_0:8;
        unsigned int cfg_dqsib_dly_byte_1:8;
        unsigned int cfg_dqsib_dly_byte_2:8;
        unsigned int cfg_dqsib_dly_byte_3:8;
    };

    uint32_t reg32;
} fbio_dqsib_dly_t;

#define FBIO_DQSIB_DLY_MSB_OFFSET 0xFC
#define FBIO_DQSIB_DLY_MSB_RESET  0x00000000
typedef union fbio_dqsib_dly_msb_u {
    struct {
        unsigned int cfg_dqsib_dly_msb_byte_0:2;
        unsigned int undefined_bits_2_7:6;
        unsigned int cfg_dqsib_dly_msb_byte_1:2;
        unsigned int undefined_bits_10_15:6;
        unsigned int cfg_dqsib_dly_msb_byte_2:2;
        unsigned int undefined_bits_18_23:6;
        unsigned int cfg_dqsib_dly_msb_byte_3:2;
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} fbio_dqsib_dly_msb_t;

#define FBIO_CFG5_OFFSET 0x104
#define FBIO_CFG5_RESET  0x00000001
typedef union fbio_cfg5_u {
    struct {
        unsigned int dram_type:2;           /* specifies which DRAM protocol to use for the attached device(s). 0 = RESERVED 1 = DDR1 2 = LPDDR2 3 = DDR2 */
        unsigned int undefined_bits_2_3:2;
        unsigned int dram_width:1;          /* specifies whether the DRAM data-bus is 16-bits or 32-bits wide. 0 = X32 1 = X16 */
        unsigned int undefined_bits_5_6:2;
        unsigned int differential_dqs:1;    /* enables differential signalling on dqs strobes (lpddr2/ddr2 options) 0 = DISABLED 1 = ENABLED */
        unsigned int ctt_termination:1;     /* enables CTT_TERMINATION mode in pads (ddr2 support) 0 = DISABLED 1 = ENABLED */
        unsigned int dqs_pulld:1;           /* enables pulldowns on dqs lines (and pullups on DQS_N if DIFFERENTIAL_DQS). 0 = DISABLED 1 = ENABLED */
        unsigned int disable_concurrent_autopre:1;/* disables reads/writes to a device until the precharge command has been issued by the dram internally. 0 = DISABLED 1 = ENABLED */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} fbio_cfg5_t;

#define FBIO_QUSE_DLY_OFFSET 0x10C
#define FBIO_QUSE_DLY_RESET  0x00000000
typedef union fbio_quse_dly_u {
    struct {
        unsigned int cfg_quse_dly_byte_0:8;
        unsigned int cfg_quse_dly_byte_1:8;
        unsigned int cfg_quse_dly_byte_2:8;
        unsigned int cfg_quse_dly_byte_3:8;
    };

    uint32_t reg32;
} fbio_quse_dly_t;

#define FBIO_QUSE_DLY_MSB_OFFSET 0x110
#define FBIO_QUSE_DLY_MSB_RESET  0x00000000
typedef union fbio_quse_dly_msb_u {
    struct {
        unsigned int cfg_quse_dly_msb_byte_0:2;
        unsigned int undefined_bits_2_7:6;
        unsigned int cfg_quse_dly_msb_byte_1:2;
        unsigned int undefined_bits_10_15:6;
        unsigned int cfg_quse_dly_msb_byte_2:2;
        unsigned int undefined_bits_18_23:6;
        unsigned int cfg_quse_dly_msb_byte_3:2;
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} fbio_quse_dly_msb_t;

#define FBIO_CFG6_OFFSET 0x114
#define FBIO_CFG6_RESET  0x00000002
typedef union fbio_cfg6_u {
    struct {
        unsigned int cfg_quse_late:3;
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} fbio_cfg6_t;

#define DQS_TRIMMER_RD0_OFFSET 0x120
#define DQS_TRIMMER_RD0_RESET  0x00000000
typedef union dqs_trimmer_rd0_u {
    struct {
        unsigned int quse_current_trim_val_byte_0:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int dqs_current_trim_val_byte_0:10;
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} dqs_trimmer_rd0_t;

#define DQS_TRIMMER_RD1_OFFSET 0x124
#define DQS_TRIMMER_RD1_RESET  0x00000000
typedef union dqs_trimmer_rd1_u {
    struct {
        unsigned int quse_current_trim_val_byte_1:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int dqs_current_trim_val_byte_1:10;
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} dqs_trimmer_rd1_t;

#define DQS_TRIMMER_RD2_OFFSET 0x128
#define DQS_TRIMMER_RD2_RESET  0x00000000
typedef union dqs_trimmer_rd2_u {
    struct {
        unsigned int quse_current_trim_val_byte_2:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int dqs_current_trim_val_byte_2:10;
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} dqs_trimmer_rd2_t;

#define DQS_TRIMMER_RD3_OFFSET 0x12C
#define DQS_TRIMMER_RD3_RESET  0x00000000
typedef union dqs_trimmer_rd3_u {
    struct {
        unsigned int quse_current_trim_val_byte_3:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int dqs_current_trim_val_byte_3:10;
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} dqs_trimmer_rd3_t;

#define LL_ARB_CONFIG_OFFSET 0x144
#define LL_ARB_CONFIG_RESET  0x00002003
typedef union ll_arb_config_u {
    struct {
        unsigned int die_off_exp:4;
        unsigned int undefined_bits_4_7:4;
        unsigned int allow_idle_insert:1;   /* 0 = DISABLED 1 = ENABLED */
        unsigned int undefined_bits_9_11:3;
        unsigned int max_ll_greed:4;
        unsigned int undefined_bits_16_23:8;
        unsigned int ll_greed_diff_bank_disable:1;/* set to one to get AP15 behavior */
        unsigned int ll_greed_diff_bank_after_disable:1;/* set to one to get AP15 behavior */
        unsigned int ll_force_insert_wr_disable:1;/* set to one to get AP15 behavior */
        unsigned int ll_insert_diff_bank_before_disable:1;/* set to one to get AP15 behavior */
        unsigned int ll_insert_diff_bank_after_toggle:1;/* set to one to get AP15 behavior */
        unsigned int ll_insert_diff_bank_after_remove:1;/* set to zero to get AP15 behavior */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} ll_arb_config_t;

#define T_MIN_CRITICAL_HP_OFFSET 0x148
#define T_MIN_CRITICAL_HP_RESET  0x0A080600
typedef union t_min_critical_hp_u {
    struct {
        unsigned int t_min_crit_hp_0:8;
        unsigned int t_min_crit_hp_1:8;
        unsigned int t_min_crit_hp_2:8;
        unsigned int t_min_crit_hp_3:8;
    };

    uint32_t reg32;
} t_min_critical_hp_t;

#define T_MIN_CRITICAL_TIMEOUT_OFFSET 0x14C
#define T_MIN_CRITICAL_TIMEOUT_RESET  0x0A080600
typedef union t_min_critical_timeout_u {
    struct {
        unsigned int t_min_crit_timeout_0:8;
        unsigned int t_min_crit_timeout_1:8;
        unsigned int t_min_crit_timeout_2:8;
        unsigned int t_min_crit_timeout_3:8;
    };

    uint32_t reg32;
} t_min_critical_timeout_t;

#define T_MIN_LOAD_OFFSET 0x150
#define T_MIN_LOAD_RESET  0x08040200
typedef union t_min_load_u {
    struct {
        unsigned int t_min_load_0:8;
        unsigned int t_min_load_1:8;
        unsigned int t_min_load_2:8;
        unsigned int t_min_load_3:8;
    };

    uint32_t reg32;
} t_min_load_t;

#define T_MAX_CRITICAL_HP_OFFSET 0x154
#define T_MAX_CRITICAL_HP_RESET  0x0B0A0901
typedef union t_max_critical_hp_u {
    struct {
        unsigned int t_max_crit_hp_0:8;
        unsigned int t_max_crit_hp_1:8;
        unsigned int t_max_crit_hp_2:8;
        unsigned int t_max_crit_hp_3:8;
    };

    uint32_t reg32;
} t_max_critical_hp_t;

#define T_MAX_CRITICAL_TIMEOUT_OFFSET 0x158
#define T_MAX_CRITICAL_TIMEOUT_RESET  0x0B0A0901
typedef union t_max_critical_timeout_u {
    struct {
        unsigned int t_max_crit_timeout_0:8;
        unsigned int t_max_crit_timeout_1:8;
        unsigned int t_max_crit_timeout_2:8;
        unsigned int t_max_crit_timeout_3:8;
    };

    uint32_t reg32;
} t_max_critical_timeout_t;

#define T_MAX_LOAD_OFFSET 0x15C
#define T_MAX_LOAD_RESET  0x20100804
typedef union t_max_load_u {
    struct {
        unsigned int t_max_load_0:8;
        unsigned int t_max_load_1:8;
        unsigned int t_max_load_2:8;
        unsigned int t_max_load_3:8;
    };

    uint32_t reg32;
} t_max_load_t;

#define AUTO_CAL_CONFIG_OFFSET 0x2A4
#define AUTO_CAL_CONFIG_RESET  0x00A60000
#define AUTO_CAL_CONFIG_WRMASK 0x7FFFFFFF
typedef union auto_cal_config_u {
    struct {
        unsigned int auto_cal_pu_offset:5;  /* 2's complement offset for pull-up value */
        unsigned int undefined_bits_5_7:3;
        unsigned int auto_cal_pd_offset:5;  /* 2's complement offset for pull-down value */
        unsigned int undefined_bits_13_15:3;
        unsigned int auto_cal_step:10;      /* Auto Cal calibration step interval (in emc clocks) - the default is set for 1.0us calibration step at 166MHz */
        unsigned int undefined_bits_26_27:2;
        unsigned int autocal_slw_override:1;/* 0 (Normal operation) pad DRVDN/UP_SLWR/F tied to AUTO_CAL output DRDVDN/UP_SLWR/F[3:0] = AUTO_CAL_PULLDOWN/UP[4:1] 1 (override) use CFG2TMC_*_DRVDN/UP_SLWR/F pins to control pad slew inputs */
        unsigned int auto_cal_enable:1;     /* 1 (normal operation): use EMC generated pullup/dn (override or autocal) 0 (disabled): use cfg2tmc_xm2* register settings for pullup/dn 0 = DISABLED 1 = ENABLED */
        unsigned int auto_cal_override:1;   /* 0 (normal operation): use AUTO_CAL_PU/PD_OFFSET as an offset to the calibration tate machine setting 1 (override) : use AUTO_CAL_PU/PD_OFFSET register values directly */
        unsigned int auto_cal_start:1;      /* Writing a one to this bit starts the calibration state machine. This bit must be set even if the override is set in order to latch in the override value */
    };

    uint32_t reg32;
} auto_cal_config_t;

#define AUTO_CAL_INTERVAL_OFFSET 0x2A8
#define AUTO_CAL_INTERVAL_RESET  0x00000000
typedef union auto_cal_interval_u {
    struct {
        unsigned int auto_cal_interval:28;  /* 0: do calibration once Otherwise, auto-calibration occurs at intervals equivalent to the programmed number of cycles */
        unsigned int undefined_bits_28_31:4;
    };

    uint32_t reg32;
} auto_cal_interval_t;

#define AUTO_CAL_STATUS_OFFSET 0x2AC
#define AUTO_CAL_STATUS_RESET  0x00000000
typedef union auto_cal_status_u {
    struct {
        unsigned int auto_cal_pullup:5;     /* Pullup code generated by auto-calibration */
        unsigned int undefined_bits_5_7:3;
        unsigned int auto_cal_pulldown:5;   /* Pulldown code generated by auto-calibration */
        unsigned int undefined_bits_13_15:3;
        unsigned int auto_cal_pullup_adj:5; /* Pullup code sent to pads */
        unsigned int undefined_bits_21_23:3;
        unsigned int auto_cal_pulldown_adj:5;/* Pulldown code sent to pads */
        unsigned int undefined_bits_29_30:2;
        unsigned int auto_cal_active:1;     /* One when auto calibrate is active - valid only after auto calibrate sequence has completed (EMC_CAL_ACTIVE == 0) */
    };

    uint32_t reg32;
} auto_cal_status_t;

#define REQ_CTRL_OFFSET 0x2B0
#define REQ_CTRL_RESET  0x00000000
typedef union req_ctrl_u {
    struct {
        unsigned int stall_all_reads:1;     /* Stall incoming read transactions (1st non-LL read will stall all transactions) */
        unsigned int stall_all_writes:1;    /* Stall incoming write transactions */
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} req_ctrl_t;

#define EMC_STATUS_OFFSET 0x2B4
#define EMC_STATUS_RESET  0x00000000
typedef union emc_status_u {
    struct {
        unsigned int emc_req_fifo_empty:1;  /* Request fifo is empty */
        unsigned int emc_ll_req_fifo_empty:1;/* LL Request fifo is empty */
        unsigned int no_outstanding_transactions:1;/* All non-stalled requests have completed */
        unsigned int undefined_bit_3:1;
        unsigned int dram_in_powerdown:2;   /* dev[n] has entered powerdown state (incoming req's will awaken if not stalled) */
        unsigned int undefined_bits_6_7:2;
        unsigned int dram_in_self_refresh:2;/* dev[n] has been put into self-refresh (will remain until SR exit cmd) */
        unsigned int undefined_bits_10_11:2;
        unsigned int dram_in_dpd:2;         /* dev[n] has been put into deep powerdown state */
        unsigned int undefined_bits_14_15:2;
        unsigned int mrr_fifo_space:4;      /* mrr fifospace available */
        unsigned int mrr_divld:1;           /* mrr data available for reading */
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} emc_status_t;

#define CFG_2_OFFSET 0x2B8
#define CFG_2_RESET  0x00000003
typedef union cfg_2_u {
    struct {
        unsigned int clkchange_req_enable:1;/* allows EMC and CAR to handshake on PLL divider/source changes. 0 = DISABLED 1 = ENABLED */
        unsigned int clkchange_pd_enable:1; /* Forces dram into power-down during CLKCHANGE. 0 = DISABLED 1 = ENABLED */
        unsigned int clkchange_sr_enable:1; /* Forces dram into self-refresh during CLKCHANGE. Takes precedent over CLKCHANGE_PD_ENABLE if both are set. 0 = DISABLED 1 = ENABLED */
        unsigned int undefined_bits_3_7:5;
        unsigned int pin_config:2;          /* Remaps address/command pins for LPDDR_POP ball-out otherwise uses standard LPDDR2 pin configuration. 0 = LPDDR2; 1 = LPDDR_POP 2 = RESERVED */
        unsigned int use_addr_clk:1;        /* Used to select source for DRAM clock. If enabled, xm2_addr_mclk pins instead of xm2_mclk. the former is located adjacent to addr pins used in lpddr2 (for lower clk to addr skew). If disabled, xm2_addr_mclk will be disabled & xm2_mclk will output DRAM clock (required for LPDDR_POP). 0 = DISABLED 1 = ENABLED */
        unsigned int undefined_bits_11_15:5;
        unsigned int mrr_bytesel:2;         /* Indicates which AP bytelane is connected to DRAM byte 0 (over which MRR data is returned) */
        unsigned int undefined_bits_18_19:2;
        unsigned int mrr_bytesel_x16:2;     /* If using 2 X16 DRAM on a single CS to form 32-bit wide data, indicates which bytelane 2nd DRAM's byte 0 is connected to */
        unsigned int undefined_bits_22_30:9;
        unsigned int dramc_pre_b4_act:1;    /* CYA bit, gives priority to activates over precharges, determining which (precharge/activate) is processed first if both are pending and unblocked. 0 = DISABLED 1 = ENABLED */
    };

    uint32_t reg32;
} cfg_2_t;

#define CFG_DIG_DLL_OFFSET 0x2BC
#define CFG_DIG_DLL_RESET  0x00000057
#define CFG_DIG_DLL_WRMASK 0x3FFFFFFF
typedef union cfg_dig_dll_u {
    struct {
        unsigned int cfg_dll_en:1;          /* Enable digital DLL's. 0 = DISABLED 1 = ENABLED */
        unsigned int cfg_dli_trimmer_en:1;  /* Enable DL trimmer cells (embedded in pads). 0 = DISABLED 1 = ENABLED */
        unsigned int cfg_dll_override_en:1; /* Override DLL's DLI output w/ OVERRIDE_VAL (still uses mult/offset). 0 = DISABLED 1 = ENABLED */
        unsigned int cfg_use_single_dll:1;  /* Turn off upper DLL & use lower dll output to drive all trimmers. 0 = DISABLED 1 = ENABLED */
        unsigned int cfg_perbyte_trimmer_override:1;/* Set trimmer values directly for each byte via FBIO_QUSE_DLY/FBIO_DQS_DLY & FBIO_QUSE_DLY_MSB/FBIO_DQS_DLY_MSB. 0 = DISABLED 1 = ENABLED */
        unsigned int cfg_dll_lowspeed:1;    /* Enable DLL for use w/ lowspeed EMCCLK operation (<200MHz) */
        unsigned int cfg_dll_mode:2;        /* Controls how frequently DLL runs, as follows 0 = RUN_CONTINUOUS : DLL will run continuously (only disabled during reads). This option will consume the most power.  1 = RUN_TIL_LOCK : after DLL_RESET is set, DLL will run until it has locked, then be disabled  2 = RUN_PERIODIC : DLL will be re-enabled w/ each refresh to make sure LOCK is maintained; 3 = RESERVED */
        unsigned int cfg_dll_udset:4;       /* DLL Loop filter control (2^(udset+3)) */
        unsigned int undefined_bits_12_15:4;
        unsigned int cfg_dll_override_val:10;/* Value to use in place of DLI output if CFG_DLL_OVERRIDE_EN is set */
        unsigned int undefined_bit_26:1;
        unsigned int cfg_dll_alarm_disable:1;/* CYA bit -- disable override of DLL logic when DLL_ALM is set (otherwise overrides DLI to 0x3FF) */
        unsigned int cfg_dll_lock_limit:2;  /* CYA in case DLL has problems locking. DLL will be treated as locked after LIMIT emcclk cycles. Counter is reset w/ DLL_RESET (from above) or w/ each periodic update (if using RUN_PERIODIC). Settings are: 00: LIMIT = 2^12 01: LIMIT = 2^15 10: LIMIT = 2^16 11: LIMIT = 2^16 + 2^17 */
        unsigned int dll_reset:1;           /* Writing 1 to this register will send reset pulse to DLL's on next shadow update. Must reset DLL's when changing clock frequency by factor >= 2 */
        unsigned int cfg_dll_use_override_until_lock:1;/* Writing 1 to this register causes override_val to be used in place of DLL output until DLL_LOCK is obtained. Takes effect on next shadow update */
    };

    uint32_t reg32;
} cfg_dig_dll_t;

#define DLL_XFORM_DQS_OFFSET 0x2C0
#define DLL_XFORM_DQS_RESET  0x00000010
typedef union dll_xform_dqs_u {
    struct {
        unsigned int xform_dqs_mult:5;
        unsigned int undefined_bits_5_7:3;
        unsigned int xform_dqs_offs:15;
        unsigned int undefined_bits_23_31:9;
    };

    uint32_t reg32;
} dll_xform_dqs_t;

#define DLL_XFORM_QUSE_OFFSET 0x2C4
#define DLL_XFORM_QUSE_RESET  0x00000008
typedef union dll_xform_quse_u {
    struct {
        unsigned int xform_quse_mult:5;
        unsigned int undefined_bits_5_7:3;
        unsigned int xform_quse_offs:15;
        unsigned int undefined_bits_23_31:9;
    };

    uint32_t reg32;
} dll_xform_quse_t;

#define DIG_DLL_UPPER_STATUS_OFFSET 0x2C8
#define DIG_DLL_UPPER_STATUS_RESET  0x00000000
typedef union dig_dll_upper_status_u {
    struct {
        unsigned int dll_upper_out:10;
        unsigned int undefined_bits_10_12:3;
        unsigned int dll_upper_lock_timeout:1;
        unsigned int dll_upper_alarm:1;
        unsigned int dll_upper_lock:1;
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} dig_dll_upper_status_t;

#define DIG_DLL_LOWER_STATUS_OFFSET 0x2CC
#define DIG_DLL_LOWER_STATUS_RESET  0x00000000
typedef union dig_dll_lower_status_u {
    struct {
        unsigned int dll_lower_out:10;
        unsigned int undefined_bits_10_12:3;
        unsigned int dll_lower_lock_timeout:1;
        unsigned int dll_lower_alarm:1;
        unsigned int dll_lower_lock:1;
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} dig_dll_lower_status_t;

#define CTT_TERM_CTRL_OFFSET 0x2DC
#define CTT_TERM_CTRL_RESET  0x00000802
#define CTT_TERM_CTRL_WRMASK 0xE0F07FFF
typedef union ctt_term_ctrl_u {
    struct {
        unsigned int term_slope:3;          /*  */
        unsigned int undefined_bits_3_7:5;
        unsigned int term_offset:5;         /*  */
        unsigned int undefined_bits_13_14:2;
        unsigned int term_drvdn:5;
        unsigned int undefined_bits_20_23:4;
        unsigned int term_drvup:5;
        unsigned int undefined_bits_29_30:2;
        unsigned int term_override:1;       /* 0 = DISABLED 1 = ENABLED */
    };

    uint32_t reg32;
} ctt_term_ctrl_t;

#define ZCAL_REF_CNT_OFFSET 0x2E0
#define ZCAL_REF_CNT_RESET  0x00000000
typedef union zcal_ref_cnt_u {
    struct {
        unsigned int zcal_ref_interval:24;  /* Number of refreshes to wait between issuance of ZCAL_MRW_CMD. If 0, ZCAL is disabled and internal counter will be reset */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} zcal_ref_cnt_t;

#define ZCAL_WAIT_CNT_OFFSET 0x2E4
#define ZCAL_WAIT_CNT_RESET  0x00000000
typedef union zcal_wait_cnt_u {
    struct {
        unsigned int zcal_wait_cnt:8;       /* Number of emc clocks to wait before issuing any commands after sending ZCAL_MRW_CMD */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} zcal_wait_cnt_t;

#define ZCAL_MRW_CMD_OFFSET 0x2E8
#define ZCAL_MRW_CMD_RESET  0x00000000
typedef union zcal_mrw_cmd_u {
    struct {
        unsigned int zq_mrw_op:8;           /* MRW OP field to be sent after ZCAL_REF_CNT */
        unsigned int undefined_bits_8_15:8;
        unsigned int zq_mrw_ma:8;           /* MRW MA field to be sent after ZCAL_REF_CNT */
        unsigned int undefined_bits_24_29:6;
        unsigned int zq_mrw_dev_selectn:2;  /* active-low chip-select, 0x0 applies command to both devices (will happen 1 at a time), 0x2 to for only dev0, 0x1 for dev1 */
    };

    uint32_t reg32;
} zcal_mrw_cmd_t;

#define CMDQ_OFFSET 0xF0
#define CMDQ_RESET  0x10004408
typedef union cmdq_u {
    struct {
        unsigned int rw_depth:5;
        unsigned int undefined_bits_5_7:3;
        unsigned int act_depth:3;
        unsigned int undefined_bit_11:1;
        unsigned int pre_depth:3;
        unsigned int undefined_bits_15_23:9;
        unsigned int rw_wd_depth:5;
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} cmdq_t;

#define FBIO_SPARE_OFFSET 0x100
#define FBIO_SPARE_RESET  0x00000000
typedef union fbio_spare_u {
    struct {
        unsigned int cfg_fbio_spare:32;
    };

    uint32_t reg32;
} fbio_spare_t;

#define FBIO_WRPTR_EQ_2_OFFSET 0x108
#define FBIO_WRPTR_EQ_2_RESET  0x00000000
#define FBIO_WRPTR_EQ_2_WRMASK 0xFFFFFFF0
typedef union fbio_wrptr_eq_2_u {
    struct {
        unsigned int fb_wrptr_eq_2:4;
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} fbio_wrptr_eq_2_t;

#define CLKEN_OVERRIDE_OFFSET 0x140
#define CLKEN_OVERRIDE_RESET  0x00000000
typedef union clken_override_u {
    struct {
        unsigned int arb_clken_ovr:1;
        unsigned int cmdq_clken_ovr:1;
        unsigned int dramc_clken_ovr:1;
        unsigned int rr_clken_ovr:1;
        unsigned int ll_clken_ovr:1;
        unsigned int llstats_clken_ovr:1;
        unsigned int stats_clken_ovr:1;
        unsigned int undefined_bits_7_31:25;
    };

    uint32_t reg32;
} clken_override_t;

#define STAT_CONTROL_OFFSET 0x160
#define STAT_CONTROL_RESET  0x00000000
typedef union stat_control_u {
    struct {
        unsigned int llmc_gather:3;
        unsigned int undefined_bits_3_7:5;
        unsigned int pwr_gather:2;
        unsigned int undefined_bits_10_15:6;
        unsigned int dram_gather:2;
        unsigned int undefined_bits_18_31:14;
    };

    uint32_t reg32;
} stat_control_t;

#define STAT_STATUS_OFFSET 0x164
#define STAT_STATUS_RESET  0x00000000
#define STAT_STATUS_WRMASK 0xFFFEFEFE
typedef union stat_status_u {
    struct {
        unsigned int llmc_limit:1;
        unsigned int undefined_bits_1_7:7;
        unsigned int pwr_limit:1;
        unsigned int undefined_bits_9_15:7;
        unsigned int dram_limit:1;
        unsigned int undefined_bits_17_31:15;
    };

    uint32_t reg32;
} stat_status_t;

#define STAT_LLMC_ADDR_LOW_OFFSET 0x168
#define STAT_LLMC_ADDR_LOW_RESET  0x00000000
typedef union stat_llmc_addr_low_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int llmc_addr_low:26;
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} stat_llmc_addr_low_t;

#define STAT_LLMC_ADDR_HIGH_OFFSET 0x16C
#define STAT_LLMC_ADDR_HIGH_RESET  0x3FFFFFF0
typedef union stat_llmc_addr_high_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int llmc_addr_high:26;
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} stat_llmc_addr_high_t;

#define STAT_LLMC_CLOCK_LIMIT_OFFSET 0x170
#define STAT_LLMC_CLOCK_LIMIT_RESET  0xFFFFFFFF
typedef union stat_llmc_clock_limit_u {
    struct {
        unsigned int llmc_clock_limit:32;
    };

    uint32_t reg32;
} stat_llmc_clock_limit_t;

#define STAT_LLMC_CLOCKS_OFFSET 0x174
#define STAT_LLMC_CLOCKS_RESET  0x00000000
typedef union stat_llmc_clocks_u {
    struct {
        unsigned int llmc_clocks:32;
    };

    uint32_t reg32;
} stat_llmc_clocks_t;

#define STAT_LLMC_CONTROL_OFFSET 0x178
#define STAT_LLMC_CONTROL_RESET  0x00000000
typedef union stat_llmc_control_u {
    struct {
        unsigned int llmc_control_0:32;
    };

    uint32_t reg32;
} stat_llmc_control_t;

#define STAT_LLMC_HIST_LIMIT_OFFSET 0x180
#define STAT_LLMC_HIST_LIMIT_RESET  0xFFFF0000
typedef union stat_llmc_hist_limit_u {
    struct {
        unsigned int llmc_hist_limit_0:32;
    };

    uint32_t reg32;
} stat_llmc_hist_limit_t;

#define STAT_LLMC_COUNT_OFFSET 0x188
#define STAT_LLMC_COUNT_RESET  0x00000000
typedef union stat_llmc_count_u {
    struct {
        unsigned int llmc_count_0:32;
    };

    uint32_t reg32;
} stat_llmc_count_t;

#define STAT_LLMC_HIST_OFFSET 0x190
#define STAT_LLMC_HIST_RESET  0x00000000
typedef union stat_llmc_hist_u {
    struct {
        unsigned int llmc_hist_0:32;
    };

    uint32_t reg32;
} stat_llmc_hist_t;

#define STAT_PWR_CLOCK_LIMIT_OFFSET 0x198
#define STAT_PWR_CLOCK_LIMIT_RESET  0xFFFFFFFF
typedef union stat_pwr_clock_limit_u {
    struct {
        unsigned int pwr_clock_limit:32;
    };

    uint32_t reg32;
} stat_pwr_clock_limit_t;

#define STAT_PWR_CLOCKS_OFFSET 0x19C
#define STAT_PWR_CLOCKS_RESET  0x00000000
typedef union stat_pwr_clocks_u {
    struct {
        unsigned int pwr_clocks:32;
    };

    uint32_t reg32;
} stat_pwr_clocks_t;

#define STAT_PWR_COUNT_OFFSET 0x1A0
#define STAT_PWR_COUNT_RESET  0x00000000
typedef union stat_pwr_count_u {
    struct {
        unsigned int pwr_count:32;
    };

    uint32_t reg32;
} stat_pwr_count_t;

#define STAT_DRAM_CLOCK_LIMIT_LO_OFFSET 0x1A4
#define STAT_DRAM_CLOCK_LIMIT_LO_RESET  0xFFFFFFFF
typedef union stat_dram_clock_limit_lo_u {
    struct {
        unsigned int dram_clock_limit_lo:32;
    };

    uint32_t reg32;
} stat_dram_clock_limit_lo_t;

#define STAT_DRAM_CLOCK_LIMIT_HI_OFFSET 0x1A8
#define STAT_DRAM_CLOCK_LIMIT_HI_RESET  0x000000FF
typedef union stat_dram_clock_limit_hi_u {
    struct {
        unsigned int dram_clock_limit_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_clock_limit_hi_t;

#define STAT_DRAM_CLOCKS_LO_OFFSET 0x1AC
#define STAT_DRAM_CLOCKS_LO_RESET  0x00000000
typedef union stat_dram_clocks_lo_u {
    struct {
        unsigned int dram_clocks_lo:32;
    };

    uint32_t reg32;
} stat_dram_clocks_lo_t;

#define STAT_DRAM_CLOCKS_HI_OFFSET 0x1B0
#define STAT_DRAM_CLOCKS_HI_RESET  0x00000000
#define STAT_DRAM_CLOCKS_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_clocks_hi_u {
    struct {
        unsigned int dram_clocks_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_clocks_hi_t;

#define STAT_DRAM_DEV0_ACTIVATE_CNT_LO_OFFSET 0x1B4
#define STAT_DRAM_DEV0_ACTIVATE_CNT_LO_RESET  0x00000000
typedef union stat_dram_dev0_activate_cnt_lo_u {
    struct {
        unsigned int dev0_activate_cnt_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev0_activate_cnt_lo_t;

#define STAT_DRAM_DEV0_ACTIVATE_CNT_HI_OFFSET 0x1B8
#define STAT_DRAM_DEV0_ACTIVATE_CNT_HI_RESET  0x00000000
#define STAT_DRAM_DEV0_ACTIVATE_CNT_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev0_activate_cnt_hi_u {
    struct {
        unsigned int dev0_activate_cnt_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev0_activate_cnt_hi_t;

#define STAT_DRAM_DEV0_READ_CNT_LO_OFFSET 0x1BC
#define STAT_DRAM_DEV0_READ_CNT_LO_RESET  0x00000000
typedef union stat_dram_dev0_read_cnt_lo_u {
    struct {
        unsigned int dev0_read_cnt_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev0_read_cnt_lo_t;

#define STAT_DRAM_DEV0_READ_CNT_HI_OFFSET 0x1C0
#define STAT_DRAM_DEV0_READ_CNT_HI_RESET  0x00000000
#define STAT_DRAM_DEV0_READ_CNT_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev0_read_cnt_hi_u {
    struct {
        unsigned int dev0_read_cnt_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev0_read_cnt_hi_t;

#define STAT_DRAM_DEV0_WRITE_CNT_LO_OFFSET 0x1C4
#define STAT_DRAM_DEV0_WRITE_CNT_LO_RESET  0x00000000
typedef union stat_dram_dev0_write_cnt_lo_u {
    struct {
        unsigned int dev0_write_cnt_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev0_write_cnt_lo_t;

#define STAT_DRAM_DEV0_WRITE_CNT_HI_OFFSET 0x1C8
#define STAT_DRAM_DEV0_WRITE_CNT_HI_RESET  0x00000000
#define STAT_DRAM_DEV0_WRITE_CNT_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev0_write_cnt_hi_u {
    struct {
        unsigned int dev0_write_cnt_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev0_write_cnt_hi_t;

#define STAT_DRAM_DEV0_REF_CNT_LO_OFFSET 0x1CC
#define STAT_DRAM_DEV0_REF_CNT_LO_RESET  0x00000000
typedef union stat_dram_dev0_ref_cnt_lo_u {
    struct {
        unsigned int dev0_ref_cnt_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev0_ref_cnt_lo_t;

#define STAT_DRAM_DEV0_REF_CNT_HI_OFFSET 0x1D0
#define STAT_DRAM_DEV0_REF_CNT_HI_RESET  0x00000000
#define STAT_DRAM_DEV0_REF_CNT_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev0_ref_cnt_hi_u {
    struct {
        unsigned int dev0_ref_cnt_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev0_ref_cnt_hi_t;

#define STAT_DRAM_DEV0_CUMM_BANKS_ACTIVE_CKE_EQ1_LO_OFFSET 0x1D4
#define STAT_DRAM_DEV0_CUMM_BANKS_ACTIVE_CKE_EQ1_LO_RESET  0x00000000
typedef union stat_dram_dev0_cumm_banks_active_cke_eq1_lo_u {
    struct {
        unsigned int dev0_cumm_banks_active_cke_eq1_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev0_cumm_banks_active_cke_eq1_lo_t;

#define STAT_DRAM_DEV0_CUMM_BANKS_ACTIVE_CKE_EQ1_HI_OFFSET 0x1D8
#define STAT_DRAM_DEV0_CUMM_BANKS_ACTIVE_CKE_EQ1_HI_RESET  0x00000000
#define STAT_DRAM_DEV0_CUMM_BANKS_ACTIVE_CKE_EQ1_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev0_cumm_banks_active_cke_eq1_hi_u {
    struct {
        unsigned int dev0_cumm_banks_active_cke_eq1_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev0_cumm_banks_active_cke_eq1_hi_t;

#define STAT_DRAM_DEV0_CUMM_BANKS_ACTIVE_CKE_EQ0_LO_OFFSET 0x1DC
#define STAT_DRAM_DEV0_CUMM_BANKS_ACTIVE_CKE_EQ0_LO_RESET  0x00000000
typedef union stat_dram_dev0_cumm_banks_active_cke_eq0_lo_u {
    struct {
        unsigned int dev0_cumm_banks_active_cke_eq0_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev0_cumm_banks_active_cke_eq0_lo_t;

#define STAT_DRAM_DEV0_CUMM_BANKS_ACTIVE_CKE_EQ0_HI_OFFSET 0x1E0
#define STAT_DRAM_DEV0_CUMM_BANKS_ACTIVE_CKE_EQ0_HI_RESET  0x00000000
#define STAT_DRAM_DEV0_CUMM_BANKS_ACTIVE_CKE_EQ0_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev0_cumm_banks_active_cke_eq0_hi_u {
    struct {
        unsigned int dev0_cumm_banks_active_cke_eq0_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev0_cumm_banks_active_cke_eq0_hi_t;

#define STAT_DRAM_DEV0_CKE_EQ1_CLKS_LO_OFFSET 0x1E4
#define STAT_DRAM_DEV0_CKE_EQ1_CLKS_LO_RESET  0x00000000
typedef union stat_dram_dev0_cke_eq1_clks_lo_u {
    struct {
        unsigned int dev0_cke_eq1_clks_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev0_cke_eq1_clks_lo_t;

#define STAT_DRAM_DEV0_CKE_EQ1_CLKS_HI_OFFSET 0x1E8
#define STAT_DRAM_DEV0_CKE_EQ1_CLKS_HI_RESET  0x00000000
#define STAT_DRAM_DEV0_CKE_EQ1_CLKS_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev0_cke_eq1_clks_hi_u {
    struct {
        unsigned int dev0_cke_eq1_clks_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev0_cke_eq1_clks_hi_t;

#define STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_LO_OFFSET 0x1EC
#define STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_LO_RESET  0x00000000
typedef union stat_dram_dev0_extclks_cke_eq1_lo_u {
    struct {
        unsigned int dev0_extclks_cke_eq1_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev0_extclks_cke_eq1_lo_t;

#define STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_HI_OFFSET 0x1F0
#define STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_HI_RESET  0x00000000
#define STAT_DRAM_DEV0_EXTCLKS_CKE_EQ1_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev0_extclks_cke_eq1_hi_u {
    struct {
        unsigned int dev0_extclks_cke_eq1_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev0_extclks_cke_eq1_hi_t;

#define STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_LO_OFFSET 0x1F4
#define STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_LO_RESET  0x00000000
typedef union stat_dram_dev0_extclks_cke_eq0_lo_u {
    struct {
        unsigned int dev0_extclks_cke_eq0_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev0_extclks_cke_eq0_lo_t;

#define STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_HI_OFFSET 0x1F8
#define STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_HI_RESET  0x00000000
#define STAT_DRAM_DEV0_EXTCLKS_CKE_EQ0_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev0_extclks_cke_eq0_hi_u {
    struct {
        unsigned int dev0_extclks_cke_eq0_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev0_extclks_cke_eq0_hi_t;

#define STAT_DRAM_DEV1_ACTIVATE_CNT_LO_OFFSET 0x1FC
#define STAT_DRAM_DEV1_ACTIVATE_CNT_LO_RESET  0x00000000
typedef union stat_dram_dev1_activate_cnt_lo_u {
    struct {
        unsigned int dev1_activate_cnt_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev1_activate_cnt_lo_t;

#define STAT_DRAM_DEV1_ACTIVATE_CNT_HI_OFFSET 0x200
#define STAT_DRAM_DEV1_ACTIVATE_CNT_HI_RESET  0x00000000
#define STAT_DRAM_DEV1_ACTIVATE_CNT_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev1_activate_cnt_hi_u {
    struct {
        unsigned int dev1_activate_cnt_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev1_activate_cnt_hi_t;

#define STAT_DRAM_DEV1_READ_CNT_LO_OFFSET 0x204
#define STAT_DRAM_DEV1_READ_CNT_LO_RESET  0x00000000
typedef union stat_dram_dev1_read_cnt_lo_u {
    struct {
        unsigned int dev1_read_cnt_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev1_read_cnt_lo_t;

#define STAT_DRAM_DEV1_READ_CNT_HI_OFFSET 0x208
#define STAT_DRAM_DEV1_READ_CNT_HI_RESET  0x00000000
#define STAT_DRAM_DEV1_READ_CNT_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev1_read_cnt_hi_u {
    struct {
        unsigned int dev1_read_cnt_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev1_read_cnt_hi_t;

#define STAT_DRAM_DEV1_WRITE_CNT_LO_OFFSET 0x20C
#define STAT_DRAM_DEV1_WRITE_CNT_LO_RESET  0x00000000
typedef union stat_dram_dev1_write_cnt_lo_u {
    struct {
        unsigned int dev1_write_cnt_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev1_write_cnt_lo_t;

#define STAT_DRAM_DEV1_WRITE_CNT_HI_OFFSET 0x210
#define STAT_DRAM_DEV1_WRITE_CNT_HI_RESET  0x00000000
#define STAT_DRAM_DEV1_WRITE_CNT_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev1_write_cnt_hi_u {
    struct {
        unsigned int dev1_write_cnt_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev1_write_cnt_hi_t;

#define STAT_DRAM_DEV1_REF_CNT_LO_OFFSET 0x214
#define STAT_DRAM_DEV1_REF_CNT_LO_RESET  0x00000000
typedef union stat_dram_dev1_ref_cnt_lo_u {
    struct {
        unsigned int dev1_ref_cnt_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev1_ref_cnt_lo_t;

#define STAT_DRAM_DEV1_REF_CNT_HI_OFFSET 0x218
#define STAT_DRAM_DEV1_REF_CNT_HI_RESET  0x00000000
#define STAT_DRAM_DEV1_REF_CNT_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev1_ref_cnt_hi_u {
    struct {
        unsigned int dev1_ref_cnt_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev1_ref_cnt_hi_t;

#define STAT_DRAM_DEV1_CUMM_BANKS_ACTIVE_CKE_EQ1_LO_OFFSET 0x21C
#define STAT_DRAM_DEV1_CUMM_BANKS_ACTIVE_CKE_EQ1_LO_RESET  0x00000000
typedef union stat_dram_dev1_cumm_banks_active_cke_eq1_lo_u {
    struct {
        unsigned int dev1_cumm_banks_active_cke_eq1_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev1_cumm_banks_active_cke_eq1_lo_t;

#define STAT_DRAM_DEV1_CUMM_BANKS_ACTIVE_CKE_EQ1_HI_OFFSET 0x220
#define STAT_DRAM_DEV1_CUMM_BANKS_ACTIVE_CKE_EQ1_HI_RESET  0x00000000
#define STAT_DRAM_DEV1_CUMM_BANKS_ACTIVE_CKE_EQ1_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev1_cumm_banks_active_cke_eq1_hi_u {
    struct {
        unsigned int dev1_cumm_banks_active_cke_eq1_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev1_cumm_banks_active_cke_eq1_hi_t;

#define STAT_DRAM_DEV1_CUMM_BANKS_ACTIVE_CKE_EQ0_LO_OFFSET 0x224
#define STAT_DRAM_DEV1_CUMM_BANKS_ACTIVE_CKE_EQ0_LO_RESET  0x00000000
typedef union stat_dram_dev1_cumm_banks_active_cke_eq0_lo_u {
    struct {
        unsigned int dev1_cumm_banks_active_cke_eq0_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev1_cumm_banks_active_cke_eq0_lo_t;

#define STAT_DRAM_DEV1_CUMM_BANKS_ACTIVE_CKE_EQ0_HI_OFFSET 0x228
#define STAT_DRAM_DEV1_CUMM_BANKS_ACTIVE_CKE_EQ0_HI_RESET  0x00000000
#define STAT_DRAM_DEV1_CUMM_BANKS_ACTIVE_CKE_EQ0_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev1_cumm_banks_active_cke_eq0_hi_u {
    struct {
        unsigned int dev1_cumm_banks_active_cke_eq0_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev1_cumm_banks_active_cke_eq0_hi_t;

#define STAT_DRAM_DEV1_CKE_EQ1_CLKS_LO_OFFSET 0x22C
#define STAT_DRAM_DEV1_CKE_EQ1_CLKS_LO_RESET  0x00000000
typedef union stat_dram_dev1_cke_eq1_clks_lo_u {
    struct {
        unsigned int dev1_cke_eq1_clks_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev1_cke_eq1_clks_lo_t;

#define STAT_DRAM_DEV1_CKE_EQ1_CLKS_HI_OFFSET 0x230
#define STAT_DRAM_DEV1_CKE_EQ1_CLKS_HI_RESET  0x00000000
#define STAT_DRAM_DEV1_CKE_EQ1_CLKS_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev1_cke_eq1_clks_hi_u {
    struct {
        unsigned int dev1_cke_eq1_clks_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev1_cke_eq1_clks_hi_t;

#define STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_LO_OFFSET 0x234
#define STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_LO_RESET  0x00000000
typedef union stat_dram_dev1_extclks_cke_eq1_lo_u {
    struct {
        unsigned int dev1_extclks_cke_eq1_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev1_extclks_cke_eq1_lo_t;

#define STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_HI_OFFSET 0x238
#define STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_HI_RESET  0x00000000
#define STAT_DRAM_DEV1_EXTCLKS_CKE_EQ1_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev1_extclks_cke_eq1_hi_u {
    struct {
        unsigned int dev1_extclks_cke_eq1_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev1_extclks_cke_eq1_hi_t;

#define STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_LO_OFFSET 0x23C
#define STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_LO_RESET  0x00000000
typedef union stat_dram_dev1_extclks_cke_eq0_lo_u {
    struct {
        unsigned int dev1_extclks_cke_eq0_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev1_extclks_cke_eq0_lo_t;

#define STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_HI_OFFSET 0x240
#define STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_HI_RESET  0x00000000
#define STAT_DRAM_DEV1_EXTCLKS_CKE_EQ0_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev1_extclks_cke_eq0_hi_u {
    struct {
        unsigned int dev1_extclks_cke_eq0_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev1_extclks_cke_eq0_hi_t;

#define STAT_DRAM_DEV0_NO_BANKS_ACTIVE_CKE_EQ1_LO_OFFSET 0x244
#define STAT_DRAM_DEV0_NO_BANKS_ACTIVE_CKE_EQ1_LO_RESET  0x00000000
typedef union stat_dram_dev0_no_banks_active_cke_eq1_lo_u {
    struct {
        unsigned int dev0_no_banks_active_cke_eq1_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev0_no_banks_active_cke_eq1_lo_t;

#define STAT_DRAM_DEV0_NO_BANKS_ACTIVE_CKE_EQ1_HI_OFFSET 0x248
#define STAT_DRAM_DEV0_NO_BANKS_ACTIVE_CKE_EQ1_HI_RESET  0x00000000
#define STAT_DRAM_DEV0_NO_BANKS_ACTIVE_CKE_EQ1_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev0_no_banks_active_cke_eq1_hi_u {
    struct {
        unsigned int dev0_no_banks_active_cke_eq1_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev0_no_banks_active_cke_eq1_hi_t;

#define STAT_DRAM_DEV0_NO_BANKS_ACTIVE_CKE_EQ0_LO_OFFSET 0x24C
#define STAT_DRAM_DEV0_NO_BANKS_ACTIVE_CKE_EQ0_LO_RESET  0x00000000
typedef union stat_dram_dev0_no_banks_active_cke_eq0_lo_u {
    struct {
        unsigned int dev0_no_banks_active_cke_eq0_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev0_no_banks_active_cke_eq0_lo_t;

#define STAT_DRAM_DEV0_NO_BANKS_ACTIVE_CKE_EQ0_HI_OFFSET 0x250
#define STAT_DRAM_DEV0_NO_BANKS_ACTIVE_CKE_EQ0_HI_RESET  0x00000000
#define STAT_DRAM_DEV0_NO_BANKS_ACTIVE_CKE_EQ0_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev0_no_banks_active_cke_eq0_hi_u {
    struct {
        unsigned int dev0_no_banks_active_cke_eq0_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev0_no_banks_active_cke_eq0_hi_t;

#define STAT_DRAM_DEV1_NO_BANKS_ACTIVE_CKE_EQ1_LO_OFFSET 0x254
#define STAT_DRAM_DEV1_NO_BANKS_ACTIVE_CKE_EQ1_LO_RESET  0x00000000
typedef union stat_dram_dev1_no_banks_active_cke_eq1_lo_u {
    struct {
        unsigned int dev1_no_banks_active_cke_eq1_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev1_no_banks_active_cke_eq1_lo_t;

#define STAT_DRAM_DEV1_NO_BANKS_ACTIVE_CKE_EQ1_HI_OFFSET 0x258
#define STAT_DRAM_DEV1_NO_BANKS_ACTIVE_CKE_EQ1_HI_RESET  0x00000000
#define STAT_DRAM_DEV1_NO_BANKS_ACTIVE_CKE_EQ1_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev1_no_banks_active_cke_eq1_hi_u {
    struct {
        unsigned int dev1_no_banks_active_cke_eq1_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev1_no_banks_active_cke_eq1_hi_t;

#define STAT_DRAM_DEV1_NO_BANKS_ACTIVE_CKE_EQ0_LO_OFFSET 0x25C
#define STAT_DRAM_DEV1_NO_BANKS_ACTIVE_CKE_EQ0_LO_RESET  0x00000000
typedef union stat_dram_dev1_no_banks_active_cke_eq0_lo_u {
    struct {
        unsigned int dev1_no_banks_active_cke_eq0_lo:32;
    };

    uint32_t reg32;
} stat_dram_dev1_no_banks_active_cke_eq0_lo_t;

#define STAT_DRAM_DEV1_NO_BANKS_ACTIVE_CKE_EQ0_HI_OFFSET 0x260
#define STAT_DRAM_DEV1_NO_BANKS_ACTIVE_CKE_EQ0_HI_RESET  0x00000000
#define STAT_DRAM_DEV1_NO_BANKS_ACTIVE_CKE_EQ0_HI_WRMASK 0xFFFFFF00
typedef union stat_dram_dev1_no_banks_active_cke_eq0_hi_u {
    struct {
        unsigned int dev1_no_banks_active_cke_eq0_hi:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} stat_dram_dev1_no_banks_active_cke_eq0_hi_t;

#define CFG_CLKTRIM_OFFSET 0x2D0
#define CFG_CLKTRIM_RESET  0x00000000
typedef union cfg_clktrim_u {
    struct {
        unsigned int cfg_data0_clktrim:6;
        unsigned int cfg_data1_clktrim:6;
        unsigned int cfg_data2_clktrim:6;
        unsigned int cfg_data3_clktrim:6;
        unsigned int cfg_mclk_addr_clktrim:6;
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} cfg_clktrim_t;

#define CFG_CLKTRIM_1_OFFSET 0x2D4
#define CFG_CLKTRIM_1_RESET  0x00000000
typedef union cfg_clktrim_1_u {
    struct {
        unsigned int cfg_dqs0_clktrim:6;
        unsigned int cfg_dqs1_clktrim:6;
        unsigned int cfg_dqs2_clktrim:6;
        unsigned int cfg_dqs3_clktrim:6;
        unsigned int cfg_mclk_clktrim:6;
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} cfg_clktrim_1_t;

#define CFG_CLKTRIM_2_OFFSET 0x2D8
#define CFG_CLKTRIM_2_RESET  0x00000000
typedef union cfg_clktrim_2_u {
    struct {
        unsigned int cfg_dq0_clktrim:6;
        unsigned int cfg_dq1_clktrim:6;
        unsigned int cfg_dq2_clktrim:6;
        unsigned int cfg_dq3_clktrim:6;
        unsigned int cfg_cmd_clktrim:6;
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} cfg_clktrim_2_t;

#endif // TEGRA_EMC_H
