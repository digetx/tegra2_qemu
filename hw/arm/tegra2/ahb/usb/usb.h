/*
 * ARM NVIDIA Tegra2 emulation.
 *
 * Copyright (c) 2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* Autogenerated from TRM v02p */

#ifndef TEGRA_USB_H
#define TEGRA_USB_H

#define USB2_CONTROLLER_USB2D_ID_OFFSET 0x0
#define USB2_CONTROLLER_USB2D_ID_RESET  0x0033FA05
#define USB2_CONTROLLER_USB2D_ID_WRMASK 0xFF000000
typedef union usb2_controller_usb2d_id_u {
    struct {
        unsigned int id:8;                  /* Configuration number. This field is set to 0x05 */
        unsigned int nid:8;                 /* Ones complement version of ID. This field is set  to 0xFA. */
        unsigned int revision:8;            /* Revision number of the USB controller. This is set  to 0x33. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_id_t;

#define USB2_CONTROLLER_USB2D_HW_GENERAL_OFFSET 0x4
#define USB2_CONTROLLER_USB2D_HW_GENERAL_RESET  0x00000035
#define USB2_CONTROLLER_USB2D_HW_GENERAL_WRMASK 0xFFFFFE08
typedef union usb2_controller_usb2d_hw_general_u {
    struct {
        unsigned int rt:1;                  /* VUSB_HS_RESET_TYPE : set to 1 = asynchronous reset */
        unsigned int clkc:2;                /* VUSB_HS_CLOCK_CONFIGURATION : Clock configuration  2 selected */
        unsigned int undefined_bit_3:1;
        unsigned int phyw:2;                /* VUSB_HS_PHY16_8 : Width of the UTMI parallel  interface. Set to 3 : 16-bit UTMI parallel interface software programmable to  8-bit */
        unsigned int phym:3;                /* VUSB_HS_PHY_MODE : set to 0 for UTMI PHY */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} usb2_controller_usb2d_hw_general_t;

#define USB2_CONTROLLER_USB2D_HW_HOST_OFFSET 0x8
#define USB2_CONTROLLER_USB2D_HW_HOST_RESET  0x00000001
#define USB2_CONTROLLER_USB2D_HW_HOST_WRMASK 0xFFFFFFF0
typedef union usb2_controller_usb2d_hw_host_u {
    struct {
        unsigned int hc:1;                  /* VUSB_HS_HOST: Indicates support for host mode. Set  to 1. */
        unsigned int nport:3;               /* VUSB_HS_NUM_PORT-1: This host controller has only  1 port. So this field will always be 0. */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} usb2_controller_usb2d_hw_host_t;

#define USB2_CONTROLLER_USB2D_HW_DEVICE_OFFSET 0xC
#define USB2_CONTROLLER_USB2D_HW_DEVICE_RESET  0x00000021
#define USB2_CONTROLLER_USB2D_HW_DEVICE_WRMASK 0xFFFFFFC0
typedef union usb2_controller_usb2d_hw_device_u {
    struct {
        unsigned int dc:1;                  /* Device capable: Set to 1 indicating support for device mode. */
        unsigned int devep:5;               /* VUSB_HS_DV_EP: No. of endpoints supported by this device controller. Set to 16. This includes control endpoint 0. */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} usb2_controller_usb2d_hw_device_t;

#define USB2_CONTROLLER_USB2D_HW_TXBUF_OFFSET 0x10
#define USB2_CONTROLLER_USB2D_HW_TXBUF_RESET  0x00070B08
#define USB2_CONTROLLER_USB2D_HW_TXBUF_WRMASK 0xFF000000
typedef union usb2_controller_usb2d_hw_txbuf_u {
    struct {
        unsigned int tcburst:8;             /* VUSB_HS_TX_BURST: Maximum burst size supported by the transmit endpoints for data transfers. Set to 8. */
        unsigned int txadd:8;               /* VUSB_HS_TX_ADD: Total no. of address bits for the transmit buffer. Set to 11. The total depth of the transmit buffer is 2048 words. */
        unsigned int txchanadd:8;           /* VUSB_HS_TX_CHAN_ADD: Total no. of address bits for the transmit buffer of each transmit endpoint. Set to 7. Each transmit buffer is 128 words deep. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_hw_txbuf_t;

#define USB2_CONTROLLER_USB2D_HW_RXBUF_OFFSET 0x14
#define USB2_CONTROLLER_USB2D_HW_RXBUF_RESET  0x00000708
#define USB2_CONTROLLER_USB2D_HW_RXBUF_WRMASK 0xFFFF0000
typedef union usb2_controller_usb2d_hw_rxbuf_u {
    struct {
        unsigned int rxburst:8;             /* VUSB_HS_RX_BURST: Maximum burst size supported by the receive endpoints for data transfers. Set to 8. */
        unsigned int rxadd:8;               /* VUSB_HS_RX_ADD: Total no. of address bits for the receive buffer. Set to 7. The total depth of the receive buffer is 128 words */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_usb2d_hw_rxbuf_t;

#define USB2_CONTROLLER_USB2D_CAPLENGTH_OFFSET 0x100
#define USB2_CONTROLLER_USB2D_CAPLENGTH_RESET  0x00000040
#define USB2_CONTROLLER_USB2D_CAPLENGTH_WRMASK 0xFFFFFF00
typedef union usb2_controller_usb2d_caplength_u {
    struct {
        unsigned int caplength:8;           /* Indicates which offset to add to the register base address at the beginning of the Operational Register. Set to 0x40. */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} usb2_controller_usb2d_caplength_t;

#define USB2_CONTROLLER_USB2D_HCIVERSON_OFFSET 0x102
#define USB2_CONTROLLER_USB2D_HCIVERSON_RESET  0x00000100
#define USB2_CONTROLLER_USB2D_HCIVERSON_WRMASK 0xFFFF0000
typedef union usb2_controller_usb2d_hciverson_u {
    struct {
        unsigned int hciversion:16;         /* Contains a BCD encoding of the EHCI revision number supported by this host controller. The most significant byte of this register represents a major revision and the least significant byte is the minor revision. This host controller supports EHCI revision 1.00. */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_usb2d_hciverson_t;

#define USB2_CONTROLLER_USB2D_HCSPARAMS_OFFSET 0x104
#define USB2_CONTROLLER_USB2D_HCSPARAMS_RESET  0x01100011
#define USB2_CONTROLLER_USB2D_HCSPARAMS_WRMASK 0xF00F00E0
typedef union usb2_controller_usb2d_hcsparams_u {
    struct {
        unsigned int n_ports:4;             /* Number of downstream ports. This field specifies the number of physical downstream ports implemented on this host controller. This field is fixed to 1, since this host controller only supports 1 port. */
        unsigned int ppc:1;                 /* Port Power Control: indicates whether the host controller implementation includes port power control.  1 = Ports have port power switches         0= Ports do not have port power switches. This field affects the functionality of the port Power field in each port status and control register. This field is set to 1. */
        unsigned int undefined_bits_5_7:3;
        unsigned int n_pcc:4;               /* Number of Ports per Companion Controller: indicates the number of ports supported per internal companion controller. This field is set to 0. */
        unsigned int n_cc:4;                /* Number of Companion Controller: indicates the number of companion controllers. This field is set to 0. */
        unsigned int undefined_bits_16_19:4;
        unsigned int n_ptt:4;               /* Number of Ports per Transaction Translator: indicates the number of ports assigned to each transaction translator within the USB2.0 host controller. Field always equals N_PORTS. This is a non-EHCI field to support embedded TT. */
        unsigned int n_tt:4;                /* Number of Transaction Translators: indicates the number of embedded transaction translators associated with the USB2.0 host controller. This field is always set to 1 indicating only 1 embedded TT is implemented in this implementation. This is a non-EHCI field to support embedded TT. */
        unsigned int undefined_bits_28_31:4;
    };

    uint32_t reg32;
} usb2_controller_usb2d_hcsparams_t;

#define USB2_CONTROLLER_USB2D_HCCPARAMS_OFFSET 0x108
#define USB2_CONTROLLER_USB2D_HCCPARAMS_RESET  0x00000006
#define USB2_CONTROLLER_USB2D_HCCPARAMS_WRMASK 0xFFFF0009
typedef union usb2_controller_usb2d_hccparams_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int pfl:1;                 /* Programmable Frame List Flag.  0 = System software must use a frame list length of 1024 elements with this host controller. The USBCMD register Frame List Size field is a read-only register and must be set to zero.  1 = System software can specify and use a smaller frame list and configure the host controller via the USBCMD register Frame List Size field.  The frame list must always be aligned on a 4K-page boundary.  This requirement ensures that the frame list is always physically contiguous.  This field will always be "1".  */
        unsigned int asp:1;                 /* Asynchronous Schedule Park Capability.  1 = (Default) the host controller supports the park feature for high-speed queue heads in the Asynchronous Schedule. The feature can be disabled or enabled and set to a specific level by using the Asynchronous Schedule Park Mode Enable and Asynchronous Schedule Park Mode Count fields in the USBCMD register.  This field is always 1. */
        unsigned int undefined_bit_3:1;
        unsigned int ist:4;                 /* Isochronous Scheduling Threshold. This field indicates, relative to the current position of the executing host controller, where software can reliably update the isochronous schedule. When bit [7] is zero, the value of the least significant 3 bits indicates the number of micro-frames a host controller can hold a set of isochronous data structures  (one or more) before flushing the state. When bit [7] is a one, then host software assumes the host controller may cache an isochronous data structure for an entire frame. This field will always be "0".  */
        unsigned int eecp:8;                /* EHCI Extended Capabilities Pointer: indicates a capabilities list exists. A value of 00h indicates no extended capabilities are implemented. For this implementation this field is always "0".  */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_usb2d_hccparams_t;

#define USB2_CONTROLLER_USB2D_DCIVERSION_OFFSET 0x120
#define USB2_CONTROLLER_USB2D_DCIVERSION_RESET  0x00000001
#define USB2_CONTROLLER_USB2D_DCIVERSION_WRMASK 0xFFFF0000
typedef union usb2_controller_usb2d_dciversion_u {
    struct {
        unsigned int dciversion:16;         /* The device controller interface conforms to the two-byte BCD encoding of the interface version number contained in this  register.  */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_usb2d_dciversion_t;

#define USB2_CONTROLLER_USB2D_DCCPARAMS_OFFSET 0x124
#define USB2_CONTROLLER_USB2D_DCCPARAMS_RESET  0x00000190
#define USB2_CONTROLLER_USB2D_DCCPARAMS_WRMASK 0xFFFFFE60
typedef union usb2_controller_usb2d_dccparams_u {
    struct {
        unsigned int den:5;                 /* Device Endpoint Number: Number of endpoints built into the device controller. This is set to 16. */
        unsigned int undefined_bits_5_6:2;
        unsigned int dc:1;                  /* Device Capable: 1 = Controller is capable of operating as USB 2.0 device. This field is set to 1. */
        unsigned int hc:1;                  /* Host Capable: 1 = This controller is capable of operating as an EHCI compatible USB 2 0 host controller operating as an EHCI  compatible USB 2.0 host controller. This field is set to 1. */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} usb2_controller_usb2d_dccparams_t;

#define USB2_CONTROLLER_USB2D_USBCMD_OFFSET 0x140
#define USB2_CONTROLLER_USB2D_USBCMD_RESET  0x00080B00
#define USB2_CONTROLLER_USB2D_USBCMD_WRMASK 0xFFFFFF7F
typedef union usb2_controller_usb2d_usbcmd_u {
    struct {
        unsigned int rs:1;                  /* Run/Stop:  Host Controller:  When set to a 1, the Host Controller proceeds with the execution of the schedule.   The Host Controller continues execution as long as this bit is set to a one.  When this bit is set to 0, the Host Controller completes the current transaction on the USB and then halts.  The HCHalted bit in the status register indicates when the Host Controller has finished the transaction and has entered the stopped state.  Software should not write a one to this field unless the host controller is in the Halted state (i.e. HCHalted in the USBSTS register is a one).  Device Controller:  Writing a one to this bit will cause the device  controller to enable a pull-up on D+ and initiate an attach event. This  control bit is not directly connected to the pull-up enable, as the pull-up  will become disabled upon transitioning into high-speed mode. Software should  use this bit to prevent an attach event before the device controller has been  properly initialized. Writing a 0 to this will cause a detach event.  */
        unsigned int rst:1;                 /* Controller Reset. Software uses this bit to reset the controller. This bit is set to zero by the Host/Device Controller when the reset process is complete. Software cannot terminate the reset process early by writing a zero to this register.  Host Controller:  When software writes a one to this bit, the Host Controller resets its internal pipelines, timers, counters, state machines etc. to their initial value. Any transaction currently in progress on USB is immediately terminated. A USB reset is not driven on downstream ports. Software should not set this bit to a one when the HCHalted bit in the USBSTS register is a zero.  Attempting to reset an actively running host controller results in undefined behavior.    Device Controller:  When software writes a one to this bit, the Device  Controller resets its internal pipelines, timers, counters, state machines  etc. to their initial value. Any transaction currently in progress on USB is  immediately terminated. Writing a one to this bit in device mode is not  recommended.  */
        unsigned int fs1_fs0:2;             /* Frame List Size . (Read/Write).  000 = Default This field is Read/Write only if Programmable Frame List Flag in the HCCPARAMS registers is set to one.  Hence this field is Read/Write for this implementation. This field specifies the size of the frame list that controls which bits in the Frame Index Register should be used for the Frame List Current index.  Note that this field is made up from USBCMD bits 15, 3 and 2.  000 = 1024 elements (4096 bytes) Default value  001 = 512 elements (2048 bytes)  010 = 256 elements (1024 bytes)   011 = 128 elements (512 bytes)  100 = 64 elements (256 bytes)  101 = 32 elements (128 bytes)  110 = 16 elements (64 bytes)  111 = 8 elements (32 bytes)        Only the host controller uses this field.  */
        unsigned int pse:1;                 /* Periodic Schedule Enable.This bit controls whether the host controller skips processing the Periodic Schedule.  0 = Do not process the Periodic Schedule  1 = Use the PERIODICLISTBASE register to access the Periodic  Schedule.  Only the host controller uses this bit.  */
        unsigned int ase:1;                 /* Asynchronous Schedule Enable. This bit controls whether the host controller skips processing the Asynchronous Schedule.  0 = Do not process the Asynchronous Schedule.  1 = Use the ASYNCLISTADDR register to access the  Asynchronous Schedule.  Only the host controller uses this bit.  */
        unsigned int iaa:1;                 /* Interrupt on Async Advance Doorbell. When the host controller has evicted all  appropriate cached schedule states, it sets the Interrupt on Async Advance  status bit in the USBSTS register. If the Interrupt on Sync Advance Enable  bit in the USBINTR register is one, then the host controller will assert an  interrupt at the next interrupt threshold. The host controller sets this bit  to zero after it has set the Interrupt on Sync Advance status bit in the  USBSTS register to one. Software should not write a one to this bit when the  asynchronous schedule is inactive. Doing so will yield undefined results. This  bit is only used in host mode. Writing a one to this bit when device mode is  selected will have undefined results.  */
        unsigned int lr:1;                  /* Light Host/Device Controller Reset (OPTIONAL) .  Read Only. Not Implemented. This field will always be "0".  */
        unsigned int asp1_asp0:2;           /* Asynchronous Schedule Park Mode Count (OPTIONAL) Read/Write.  If the Asynchronous Park Capability bit in the HCCPARAMS register is a one,  then this field defaults to 3h and is R/W. Otherwise it defaults to zero and  is RO. It contains a count of the number of successive transactions the host  controller is allowed to execute from a high-speed queue head on the  Asynchronous schedule before continuing traversal of the Asynchronous  schedule. Valid values are 1h to 3h. Software must not write a zero to this  bit when Park Mode Enable is a one as this will result in undefined behavior.  This field is set to 3h in this implementation and is Read/Write capable.  */
        unsigned int undefined_bit_10:1;
        unsigned int aspe:1;                /* Asynchronous Schedule Park mode Enable. Software uses this bit to enable or disable Park mode. When this bit is one, Park mode is enabled. When this bit is a zero, Park mode is disabled.  This field is set to "1" in this  implementation.  */
        unsigned int undefined_bit_12:1;
        unsigned int sutw:1;                /* Setup Tripwire. This bit is used as a semaphore when the 8 bytes  of setup data read extracted by the firmware. If the setup lockout mode is  off, then there exists a hazard when new setup data arrives and firmware is  copying setup data from the QH for a previous setup packet. This bit is set  and cleared by software and will be cleared by hardware when a hazard exists. */
        unsigned int atdtw:1;               /* Add DTD Tripwire. This bit is used as a semaphore when a dTD is  added to an active (primed) endpoint. This bit is set and cleared by software  and will be cleared by hardware when a hazard exists such that adding a dTD  to a primed endpoint may go unnoticed. */
        unsigned int fs2:1;                 /* Bit 2 of Frame List Size. */
        unsigned int itc:8;                 /* Interrupt Threshold Control .Read/Write. Default 08h. The system software uses this field to set the maximum rate at which the host/device controller will issue interrupts. ITC contains the maximum interrupt interval measured in micro-frames. Valid values are shown below.   Value          Maximum Interrupt Interval  00h              Immediate (no threshold)  01h                1 micro-frame  02h           2 micro-frames  04h          4 micro-frames  08h          8 micro-frames  10h          16 micro-frames  20h         32 micro-frames  40h         64 micro-frames */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_usbcmd_t;

#define USB2_CONTROLLER_USB2D_USBSTS_OFFSET 0x144
#define USB2_CONTROLLER_USB2D_USBSTS_RESET  0x00001000
#define USB2_CONTROLLER_USB2D_USBSTS_WRMASK 0xFFFFDFEF
typedef union usb2_controller_usb2d_usbsts_u {
    struct {
        unsigned int ui:1;                  /* USB Interrupt. This bit is set by the Host/Device Controller when  the cause of an interrupt is a completion of a USB transaction where the  Transfer Descriptor (TD) as an interrupt on complete (IOC) bit set. This bit  is also set by the Host/Device Controller when a short packet is detected. A  short packet is when the actual number of bytes received was less than the  expected number of bytes.  */
        unsigned int uei:1;                 /* USB Error Interrupt. This bit gets set by the Host/Device controller  when completion of a USB transaction results in an error condition. This bit  is set along with the USBINT bit, if the TD on which the error interrupt  occurred also ad its interrupt on complete (IOC) bit set.  */
        unsigned int pci:1;                 /* Port Change Detect. The Host Controller sets this bit to a 1 when on  any port a Connect Status occurs, a Port Enable/Disable Change occurs, or the  Force Port Resume bit is set as the result of a J-K transition on the  suspended port. The Device Controller sets this bit to a one when the port  controller enters the full or high-speed operational state. When the port  controller exits the full or high-speed operational states due to Reset or  Suspend events, the notification mechanisms are the USB Reset Received bit  and the DCSuspend bits respectively. This bit is not EHCI compatible.  */
        unsigned int fri:1;                 /* Frame List Rollover. The Host Controller sets this bit to a 1 when  the Frame List Index rolls over from its maximum value to 0. The exact  value at which the rollover occurs depends on the frame list size. For  example. If the frame list size (as programmed in the Frame List Size field  of the USBCMD register) is 1024, the Frame Index Register rolls over every  time FRINDEX [1 3] toggles. Similarly, if the size is 512, the Host  Controller sets this bit to a 1 every time FHINDEX [12] toggles. Only used  by the host controller.  */
        unsigned int sei:1;                 /* System Error. This bit is not used in this  implementation and will always be set to "0".  */
        unsigned int aai:1;                 /* Interrupt and Asynchronous Advance. System software can force the host controller to  issue an interrupt the next time the host controller advances the  asynchronous schedule by writing a one to the Interrupt on Async Advance  Doorbell bit in the USBCMD register. This status bit indicates the assertion  of that interrupt source. Only used by the host controller */
        unsigned int uri:1;                 /* USB Reset Received. When the device controller detects a USB Reset and  enters the default state, this bit is set to a 1. Software can write a 1 to  this bit to clear the USB Reset Received status bit. Only used by the device  controller.  */
        unsigned int sri:1;                 /* SOF Received. When the device controller detects a Start Of (micro) Frame, this bit will be set to a one. When a SOF is extremely late, the device controller will automatically set this bit to indicate that an SOF was expected.  Therefore, this bit will be set roughly every 1ms in device FS mode and every 125us in HS mode and will be synchronized to the actual SOF that is received. Since device controller is initialized to FS before connect, this bit Will be set at an interval of 1ms during the prelude to the connect and chirp. In host mode, this bit will be set every 125us and can be used by host controller driver as a time base.  Software writes a 1 to this bit to clear it. This  is a non-EHCI status bit.  */
        unsigned int sli:1;                 /* DCSuspend. When a device controller enters a suspend state  from an active state, this bit will be set to a 1. The device controller  clears the bit upon exiting from a suspend state. Only used by the device  controller.  */
        unsigned int undefined_bits_9_11:3;
        unsigned int hch:1;                 /* HCHalted. 1 = Default. This bit is a zero  whenever the Run/Stop bit is a one. The Host Controller sets this bit to one  after it has stopped executing because of the Run/Stop bit being set to 0,  either by software or by the Host Controller hardware (e.g. internal error). Only  used by the host controller.  */
        unsigned int rcl:1;                 /* Reclamation. This is a read-only status bit used to detect an  empty asynchronous schedule. Only used by the host controller.  */
        unsigned int ps:1;                  /* Periodic Schedule Status. This bit reports the current real status of the Periodic Schedule.  When set to zero the periodic schedule is disabled, and if set to one the status is enabled.   The Host Controller is not required to immediately disable or enable the Periodic Schedule when software transitions the Periodic Schedule Enable bit in the USBCMD register.   If PS = PSE then: 1 = Periodic Schedule is enabled or 0 = Periodic Schedule is disabled Only used by the host controller.  */
        unsigned int as:1;                  /* Asynchronous Schedule Status. This bit reports the current real status of the Asynchronous Schedule.  When set to zero the asynchronous schedule status is disabled and if set to one the status is enabled.  The Host Controller is not required to immediately disable or enable the Asynchronous Schedule when software transitions the Asynchronous Schedule Enable bit in the USBCMD register.   If AS = ASE:  1= Enable Asynchronous Schedule    0= Disable Asynchronous Schedule Only used by the host controller.  */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_usb2d_usbsts_t;

#define USB2_CONTROLLER_USB2D_USBINTR_OFFSET 0x148
#define USB2_CONTROLLER_USB2D_USBINTR_RESET  0x00000000
typedef union usb2_controller_usb2d_usbintr_u {
    struct {
        unsigned int ue:1;                  /* USB Interrupt Enable. 1 = Host/device issues an interrupt at the next  interrupt threshold if the USBINT bit in USBSTS = 1.  The interrupt is  acknowledged by software clearing the USBINT bit. */
        unsigned int uee:1;                 /* USB Error Interrupt Enable. 1 = Host controller issues an interrupt at the  next interrupt threshold if the USBERRINT bit in USBSTS = 1.  The interrupt is  acknowledged by software clearing the USBERRINT bit in the USBSTS register.  */
        unsigned int pce:1;                 /* Port Change Detect Enable. 1 = Host/device controller issues an interrupt if  Port Change Detect bit in USBSTS register = 1.  The interrupt is acknowledged  by software clearing the Port Change Detect bit. */
        unsigned int fre:1;                 /* Frame List Rollover Enable. 1 = Host controller issues an interrupt if Frame  List Rollover bit in the USBSTS register = 1. The interrupt is acknowledged  by software clearing the Frame List Rollover bit. Only used by the host  controller.  */
        unsigned int see:1;                 /* System Error Enable. 1 = Host/device controller issues an interrupt if  the System Error bit in USBSTS register = 1. The interrupt is acknowledged by  software clearing the System Error bit.  */
        unsigned int aae:1;                 /* Interrupt on Asynchronous Advance Enable. 1 = the host controller issues an interrupt at the  next interrupt threshold if Interrupt on Async Advance bit in USBSTS register  = 1.  The interrupt is acknowledged by software clearing the Interrupt on  Async Advance bit. Only used by the host controller.  */
        unsigned int ure:1;                 /* USB Reset Enable.1 = Device controller issues an interrupt if USB Reset Received bit in USBSTS register  = 1  The interrupt is acknowledged by software clearing  the USB Reset Received bit. Only used by the device controller.  */
        unsigned int sre:1;                 /* SOF Received Enable. 1 = Device controller issues an interrupt if SOF Received bit in USBSTS register = 1. The interrupt is acknowledged by software clearing  the SOF Received bit.  */
        unsigned int sle:1;                 /* Sleep Enable. 1 = Device controller issues an interrupt if  DCSuspend bit in USBSTS register transitions.  The interrupt is acknowledged by SW by writing a 1 to the DCSuspend bit. Only used by the device controller.  */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} usb2_controller_usb2d_usbintr_t;

#define USB2_CONTROLLER_USB2D_FRINDEX_OFFSET 0x14C
#define USB2_CONTROLLER_USB2D_FRINDEX_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_FRINDEX_WRMASK 0xFFFFC000
typedef union usb2_controller_usb2d_frindex_u {
    struct {
        unsigned int frindex:14;            /* Frame Index.   The value in this register increments at the end of each time frame (micro-frame).  Bits [N: 3] are used for the Frame List current index. Each location of the frame list is accessed 8 times (frames or micro-frames) before moving to the next index.   The following illustrates values of N based on the value of the Frame List Size field in the USBCMD register, when used in host mode.  USBCMD          [Frame List Size] Number        Elements N    000b                   (1024)                  12    001b                   (512)                   11    010b                   (256)                   10    011b                   (128)                   9    100b            (64)                    8    101b            (32)                    7    110b            (16)                    6    111b            (8)                     5  In device mode the value is the current frame  number of the last frame transmitted. It is not used as an index. In either  mode bits 2:0 indicate the current micro-frame.  */
        unsigned int undefined_bits_14_31:18;
    };

    uint32_t reg32;
} usb2_controller_usb2d_frindex_t;

#define USB2_CONTROLLER_USB2D_PERIODICLISTBASE_OFFSET 0x154
#define USB2_CONTROLLER_USB2D_PERIODICLISTBASE_RESET  0x00000000
typedef union usb2_controller_usb2d_periodiclistbase_u {
    struct {
        unsigned int undefined_bits_0_11:12;
        unsigned int usbadr:7;              /* Device mode. The upper seven bits of this register represent the device address. After any controller reset or a USB reset, the device address is set to the default address (0). The default address will match all incoming addresses. Software shall reprogram the address after receiving a SET_ADDRESS request.  */
    };

    uint32_t reg32;
} usb2_controller_usb2d_periodiclistbase_t;

#define USB2_CONTROLLER_USB2D_ASYNCLISTADDR_OFFSET 0x158
#define USB2_CONTROLLER_USB2D_ASYNCLISTADDR_RESET  0x00000000
typedef union usb2_controller_usb2d_asynclistaddr_u {
    struct {
        unsigned int undefined_bits_0_4:5;
        unsigned int epbase:21;             /* Device mode. This register contains the address of the top of the endpoint list in system memory. These bits correspond to memory address signals [31:11], respectively. This field will reference a list of up to 32 Queue Heads (QH). Only used by the device controller. */
    };

    uint32_t reg32;
} usb2_controller_usb2d_asynclistaddr_t;

#define USB2_CONTROLLER_USB2D_ASYNCTTSTS_OFFSET 0x15C
#define USB2_CONTROLLER_USB2D_ASYNCTTSTS_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ASYNCTTSTS_WRMASK 0xFFFFFFFE
typedef union usb2_controller_usb2d_asyncttsts_u {
    struct {
        unsigned int ttas:1;                /* Embedded TT Async Buffers Status. (Read Only) This  read only bit will be 1 if one or more transactions are being held in the  embedded TT Async. Buffers. When this bit is a zero, then all outstanding  transactions in the embedded TT have been flushed.  */
        unsigned int ttac:1;                /* Embedded TT Async Buffers Clear. (Read/Write to  set) This field will clear all pending transactions in the embedded TT Async  Buffer(s). The clear will take as much time as necessary to clear buffer  without interfering with a transaction in progress. TTAC will return to zero  after being set by software only after the actual clear occurs.  */
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} usb2_controller_usb2d_asyncttsts_t;

#define USB2_CONTROLLER_USB2D_BURSTSIZE_OFFSET 0x160
#define USB2_CONTROLLER_USB2D_BURSTSIZE_RESET  0x00000808
typedef union usb2_controller_usb2d_burstsize_u {
    struct {
        unsigned int rxpburst:8;            /* Programmable RX Burst Length.  (Read/Write) This register represents the maximum length of a burst in 32-bit words while moving data from the USB bus to system memory. */
        unsigned int txpburst:8;            /* Programmable TX Burst Length.  (Read/Write) This register represents the maximum length of a burst in 32-bit words while moving data from system memory to the USB bus. */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_usb2d_burstsize_t;

#define USB2_CONTROLLER_USB2D_TXFILLTUNING_OFFSET 0x164
#define USB2_CONTROLLER_USB2D_TXFILLTUNING_RESET  0x00020000
typedef union usb2_controller_usb2d_txfilltuning_u {
    struct {
        unsigned int txschoh:8;             /* Scheduler Overhead.  (Read/Write)  [Default = 0] This register adds an additional fixed offset to the schedule time estimator described above as Tff.  As an approximation, the value chosen for this register should limit the number of back-off events captured in the TXSCHHEALTH to less than 10 per second in a highly utilized bus.  Choosing a value that is too high for this register is not desired as it can needlessly reduce USB utilization. The time unit represented in this register is 1.267us when a device is connected in High-Speed Mode. The time unit represented in this register is 6.333us when a device is connected in Low/Full Speed Mode */
        unsigned int txschhealth:5;         /* Scheduler Health Counter.  (Read/Write To Clear)  [Default = 0] This register increments when the host controller fails to fill the TX latency FIFO to the level programmed by TXFIFOTHRES before running out of time to send the packet before the next Start-Of-Frame. This health counter measures the number of times this occurs to provide feedback to selecting a proper TXSCHOH.  Writing to this register will clear the counter and this counter will max. at 31. */
        unsigned int undefined_bits_13_15:3;
        unsigned int txfifothres:6;         /* FIFO Burst Threshold.  (Read/Write) This register controls the number of data bursts that are posted to the TX latency FIFO in host mode before the packet begins on to the bus.  The minimum value is 2 and this value should be a low as possible to maximize USB performance.  A higher value can be used in systems with unpredicable latency and/or insufficient bandwidth where the FIFO may underrun because the data transferred from the latency FIFO to USB occurs before it can be replenished from system memory.  This value is ignored if the Stream Disable bit in USBMODE register is set. */
        unsigned int undefined_bits_22_31:10;
    };

    uint32_t reg32;
} usb2_controller_usb2d_txfilltuning_t;

#define USB2_CONTROLLER_USB2D_PORTSC1_OFFSET 0x184
#define USB2_CONTROLLER_USB2D_PORTSC1_RESET  0x00001004
#define USB2_CONTROLLER_USB2D_PORTSC1_WRMASK 0x13FF114E
typedef union usb2_controller_usb2d_portsc1_u {
    struct {
        unsigned int ccs:1;                 /* Current Connect Status:  In Host Mode: 1=Device is present on port.                0=No device is present (default)  This value reflects the current state of the port, and may not correspond directly to the event that caused the Connect Status Change bit (Bit 1) to be set. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode.  In Device Mode: 1=Attached                    0=Not Attached (default)  A one indicates that the device successfully attached and is operating in either high speed or full speed as indicated by the High Speed Port bit in this register. A zero indicates that the device did not attach successfully or was forcibly disconnected by the software writing a zero to the Run bit in the USBCMD register. It does not state the device being disconnected or suspended.  */
        unsigned int csc:1;                 /* Connect Status Change: 1 =Change in Current Connect Status. 0=No change (default)  In Host Mode:  Indicates a change has occurred in the port's Current Connect Status. The host/device controller sets this bit for all changes to the port device connect status, even if system software has not cleared an existing connect status change. For example, the insertion status changes twice before system software has cleared the changed condition, hub hardware will be 'setting' an already-set bit (i.e., the bit will remain set).  Software clears this bit by writing a one to it. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode.  This bit is undefined in device controller mode.  */
        unsigned int pe:1;                  /* Port Enabled/Disabled: 1=Enable. 0=Disable (default) In Host Mode:  Ports can only be enabled by the host controller as a part of the reset and enable. Software cannot enable a port by writing a one to this field. Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by the host software. Note that the bit status does not change until the port state actually changes. There may be a delay in disabling or enabling a port due to other host controller and bus events.  When the port is disabled, (0b) downstream propagation of data is blocked except for reset. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode.  In Device Mode:  The device port is always enabled. (This bit will  be one)  */
        unsigned int pec:1;                 /* Port Enable/Disable Change: 1=Port enabled/disabled status has changed. 0=No change. In Host Mode:  For the root hub, this bit gets set to a one only when a port is disabled due to disconnect on the port or due to the appropriate conditions existing at the EOF2 point (See Chapter 11 of the USB Specification). Software clears this by writing a one to it. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero.  In Device mode:   The device port is always enabled. (This bit will  be zero)  */
        unsigned int oca:1;                 /* Over-current Active: Not supported */
        unsigned int occ:1;                 /* Over-current Change: Not supported */
        unsigned int fpr:1;                 /* Force Port Resume. 1= Resume detected/driven on port. 0=No resume (K state) detected/driven on port.  In Host Mode:  Software sets this bit to one to drive resume signaling. The Host Controller sets this bit to one if a J-to-K transition is detected while the port is in the Suspend state. When this bit transitions to a one because a J-to-K transition is detected, the Port Change Detect bit in the USBSTS register is also set to one.  This bit will automatically change to zero after the resume sequence is complete. This behavior is different from EHCI where the host controller driver is required to set this bit to a zero after the resume duration is timed in the driver.  Note that when the Host controller owns the port, the resume sequence follows the defined sequence documented in the USB Specification Revision 2.0. The resume signaling (Full-speed 'K') is driven on the port as long as this bit remains a one.  This bit remains a one until the port has switched to the high-speed idle.  Writing a zero has no effect because the port controller will time the resume operation to clear the bit when the port control state switches to HS or FS idle. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode. This bit is not-EHCI compatible.  In Device mode:   After the device has been in Suspend State for 5ms or more, software must set this bit to one to drive resume signaling before clearing. The Device Controller will set this bit to one if a J-to-K transition is detected while the port is in the Suspend state. The bit will be cleared when the device returns to normal operation. Also, when this bit transitions to a one because a J-to-K transition is detected, the Port Change Detect bit in the USBSTS register is also set to one.  Software should ensure that the PHY clock is operational before writing a 1 to this bit to start the resume sequence. This is true for both Device and Host modes. */
        unsigned int susp:1;                /* Port suspend. 1=Port in suspend state. 0=Port not in suspend state.  In Host Mode: Read/Write.  Port Enabled Bit and Suspend bit of this register define the port states as follows:  Bits [Port Enabled, Suspend]    Port State         0x                        Disable    10                        Enable     11                        Suspend  When in suspend state, downstream propagation of data is blocked on this port, except for port reset. The blocking occurs at the end of the current transaction if a transaction was in progress when this bit was written to 1. In the suspend state, the port is sensitive to resume detection. Note that the bit status does not change until the port is suspended and that there may be a delay in suspending a port if there is a transaction currently in progress on the USB. The host controller will unconditionally set this bit to zero when software sets the Force Port Resume bit to zero. A write of zero to this bit is ignored by the host controller. If host software sets this bit to a one when the port is not enabled (i.e. Port enabled bit is a zero) the results are undefined. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode. In Device Mode: Read Only. This bit is a read only status bit.  */
        unsigned int pr:1;                  /* This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero.  In Host Mode: Read/Write. 1=Port is in Reset. 0=Port is not in Reset. When software writes a one to this bit the bus-reset sequence as defined in the USB Specification Revision 2.0 is started. This bit will automatically change to zero after the reset sequence is complete. This behavior is different from EHCI where the host controller driver is required to set this bit to a zero after the reset duration is timed in the driver.   In Device Mode: This bit is a read only status  bit. Device reset from the USB bus is also indicated in the USBSTS register.  */
        unsigned int hsp:1;                 /* When the bit is one, the host/device connected to the port is in high-speed mode and if set to zero, the host/device connected to the port is not in a high-speed mode.  Note: HSP is redundant with PSPD(27:26).  This bit is not defined in the EHCI specification. */
        unsigned int ls:2;                  /* Line state. These bits reflect the current logical levels of the D+ (bit 10) and D- (bit 11) signal lines. The encoding of the bits are: 00b = SE0  01b = J-state  10b = K-state  11b = Undefined  The value of this field is undefined if Port  Power(PP) and B-Host Enable(BHEN) is zero in host mode. In host mode, the use  of line-state by the host controller driver is not necessary (unlike EHCI),  because the port controller state machine and the port routing manage the  connection of LS and FS. In device mode, the use of line-state by the device  controller driver is not necessary.  */
        unsigned int pp:1;                  /* Port Power: The function of this bit depends on the value of the Port Power Switching (PPC) field in the HCSPARAMS register. The behavior is as follows:  PPC                       PP  Operation  0b                           0b Read Only. A device controller with no OTG capability does not have port power control switches.  1b                          1b/0b RW.  Host/OTG controller requires port power control switches.  This bit represents the current setting of the switch (0=off, 1=on).  When power is not available on a port (i.e. PP equals a 0), the port is non-functional and will not report attaches, detaches, etc.  When an over-current condition is detected on a  powered port and PPC is a one, the PP bit in each affected port may be  transitioned by the host controller driver from a one to a zero (removing  power from the port).  */
        unsigned int po:1;                  /* Port Owner. Port owner handoff is not implemented in this design, therefore this bit will  always be 0.  */
        unsigned int pic:2;                 /* Port Indicator Control: This field is not supported in the current  implementation. Please use a GPIO if you wish to use Port Indicators. */
        unsigned int ptc:4;                 /* Port Test Control: Any other value than zero indicates that the port is operating in test mode.    Value                  Specific Test   0000b                Not enabled   0001b                  J_ STATE   0010b             K_STATE   0011b              SEQ_NAK   0100b              Packet   0101b               FORCE_ENABLE   0110b to 1111b         Reserved  Refer to Chapter 7 of the USB Specification  Revision 2.0 for details on each test mode.  */
        unsigned int wkcn:1;                /* Wake on Connect Enable: Writing this bit to a one enables the port to be sensitive to device connects as wake-up events. This field is zero if Port Power(PP)  and B-Host Enable(BHEN) is zero or in device mode.  This bit should only be used when operating in Host mode. Writing this bit to 1 while the controller is working in device mode can result in undefined behaviour.  This bit should not be written to 1 while the  device is connected. After the device connection is detected, this bit should  be cleared to 0. */
        unsigned int wkds:1;                /* Wake on Disconnect Enable: Writing this bit to a one enables the port to be sensitive to device disconnects as wake-up events. This field is zero if Port Power(PP)  and B-Host Enable(BHEN) is zero or in device mode.  This bit should only be used when operating in Host mode. Writing this bit to 1 while the controller is working in device mode can result in undefined behaviour.  This bit should not be written to 1 if there is no  device connected. After the device disconnect is detected, this bit should be  cleared to 0. */
        unsigned int wkoc:1;                /* Default = 0b. Wake on Over-current Enable: Writing this bit to a one enables  the port to be sensitive to over-current conditions as wake-up events. This  field is zero if Port Power(PP) is zero. This bit should only be used when  operating in Host mode. Writing this bit to 1 while the controller is working  in device mode can result in undefined behavior. */
        unsigned int undefined_bit_23:1;
        unsigned int pfsc:1;                /* Port Force Full Speed Connect: Writing this bit to a 1b forces the port to connect at Full Speed only. It disables the chirp sequence that allows the port to identify itself as High Speed. This is useful for testing FS configurations with a HS host, hub or device. This bit is not defined in the EHCI specification. */
        unsigned int undefined_bit_25:1;
        unsigned int pspd:2;                /* This register field indicates the speed at which the port is operating.  00 = Full Speed 01 = Low Speed 10 = High Speed  This bit is not defined in the EHCI specification.   */
        unsigned int undefined_bit_28:1;
        unsigned int ptw:1;                 /* Parallel Transceiver Width. Fixed to 0. This bit is not defined in the EHCI specification.   */
        unsigned int sts:1;                 /* 0 = Serial transceiver not selected. This is the  only value supported. This bit is not defined in the EHCI specification.  */
        unsigned int pts:1;                 /* 0 = UTMI interface. This is the only value  supported. This bit is not defined in the EHCI specification.  */
    };

    uint32_t reg32;
} usb2_controller_usb2d_portsc1_t;

#define USB2_CONTROLLER_USB2D_OTGSC_OFFSET 0x1A4
#define USB2_CONTROLLER_USB2D_OTGSC_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_OTGSC_WRMASK 0xFFFF80FF
typedef union usb2_controller_usb2d_otgsc_u {
    struct {
        unsigned int vd:1;                  /* VBUS_Discharge. Read/write. Setting this bit  causes Vbus to discharge through a resistor.  */
        unsigned int vc:1;                  /* VBUS Charge. Setting this bit causes the VBus line to be  charged. This is used for VBus pulsing during SRP.  */
        unsigned int undefined_bit_2:1;
        unsigned int ot:1;                  /* OTG Termination. This bit must be set when the OTG device is in device mode, this controls the pulldown on DM.  */
        unsigned int dp:1;                  /* Data Pulsing. Setting this bit causes the pull-up on DP to be  asserted for data pulsing during SRP.  */
        unsigned int undefined_bits_5_7:3;
        unsigned int id:1;                  /* USB ID: 0 = A-device  1 = B-device */
        unsigned int avv:1;                 /* A VBus Valid. Indicates VBus is above the A VBus valid threshold */
        unsigned int asv:1;                 /* A Session Valid. Indicates VBus is above the A session valid  threshold */
        unsigned int bsv:1;                 /* B Session Valid. Indicates VBus is above the B session valid  threshold */
        unsigned int bse:1;                 /* B session End. Indicates VBus is below the B session end  threshold */
        unsigned int onemst:1;              /* 1 millisecond timer toggle. This bit toggles once per millisecond */
        unsigned int dps:1;                 /* Data Bus Pulsing Status. A 1 indicates data bus pulsing is being detected  on the port.  */
        unsigned int undefined_bit_15:1;
        unsigned int idis:1;                /* USB ID Interrupt Status. This bit is set when a change on the ID input has been detected. Software writes a 1 to clear this bit.  */
        unsigned int avvis:1;               /* A VBus Valid Interrupt Status. This bit is set when VBus has either risen above  or fallen below the VBus valid threshold (4.4 VDC) on an A device. Software  writes a 1 to clear this bit.  */
        unsigned int asvis:1;               /* A Session Valid Interrupt Status. This bit is set when VBus has either risen above  or fallen below the A session valid threshold (0.8 VDC). Software writes a  one to clear this bit.  */
        unsigned int bsvis:1;               /* B Session Valid Interrupt Status. This bit is set when VBus has either risen above  or fallen below the B session valid threshold (0.8 VDC). Software writes a 1  to clear this bit.  */
        unsigned int bseis:1;               /* B Session End Interrupt Status. This bit is set when VBus has fallen below the B  session end threshold. Software writes a 1 to clear this bit . */
        unsigned int onemss:1;              /* 1 millisecond timer Interrupt Status: This bit is set once every millisecond. Software  writes a 1 to clear it. */
        unsigned int dpis:1;                /* Data Pulse Interrupt Status. This bit is set when data bus pulsing occurs on DP or DM.  Data bus pulsing is only detected when USBMODE.CM = Host (11) and PORTSC(0).PortPower = Off (0). Software writes a 1 to clear this bit. */
        unsigned int undefined_bit_23:1;
        unsigned int idie:1;                /* USB ID Interrupt Enable. Setting this bit enables the USB ID interrupt */
        unsigned int avvie:1;               /* A VBus Valid Interrupt Enable. Setting this bit enables the A VBus valid  interrupt */
        unsigned int asvie:1;               /* A Session Valid Interrupt Enable. Setting this bit enables the A session valid  interrupt */
        unsigned int bsvie:1;               /* B Session Valid Interrupt Enable. Setting this bit enables the B session valid  interrupt */
        unsigned int bseie:1;               /* B Session End Interrupt Enable. Setting this bit enables the B session end  interrupt */
        unsigned int onemse:1;              /* 1 millisecond timer Interrupt enable. Setting this bit enables the 1 millisecond timer  interrupt. */
        unsigned int dpie:1;                /* Data Pulse Interrupt Enable. Setting this bit enables the Data pulse interrupt. */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} usb2_controller_usb2d_otgsc_t;

#define USB2_CONTROLLER_USB2D_USBMODE_OFFSET 0x1A8
#define USB2_CONTROLLER_USB2D_USBMODE_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_USBMODE_WRMASK 0xFFFFFFE0
typedef union usb2_controller_usb2d_usbmode_u {
    struct {
        unsigned int cm:2;                  /* Controller Mode: The controller mode will default to an idle state and will need to be initialized to the desired operating mode after reset. This register can only be written once after reset. If it is necessary to switch modes, software must reset the controller by writing to the RESET bit in the USBCMD register before reprogramming this register.  00 = Idle [Default]  01 = Reserved  10 = Device Controller   11 = Host Controller  */
        unsigned int es:1;                  /* Endian Select: Note: For this implementation, this should be  always set to 0 (little endian). */
        unsigned int slom:1;                /* Setup Lockout Mode: In device mode, this bit controls the behavior of the setup lockout mechanism. 0 - Setup lockout is ON (default) 1  Setup lockout is OFF. Firmware requires the  use of setup tripwire semaphore in USB2D_USBCMD register. */
        unsigned int sdis:1;                /* Stream disbable: 1 Streaming is disabled - helpful to avoid overrun/underruns when system load is too high. */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} usb2_controller_usb2d_usbmode_t;

#define USB2_CONTROLLER_USB2D_ENDPTSETUPSTAT_OFFSET 0x1AC
#define USB2_CONTROLLER_USB2D_ENDPTSETUPSTAT_RESET  0x00000000
typedef union usb2_controller_usb2d_endptsetupstat_u {
    struct {
        unsigned int endptsetupstat0:1;     /* Endpoint 0 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat1:1;     /* Endpoint 1 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat2:1;     /* Endpoint 2 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat3:1;     /* Endpoint 3 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat4:1;     /* Endpoint 4 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat5:1;     /* Endpoint 5 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat6:1;     /* Endpoint 6 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat7:1;     /* Endpoint 7 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat8:1;     /* Endpoint 8 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat9:1;     /* Endpoint 9 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat10:1;    /* Endpoint 10 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat11:1;    /* Endpoint 11 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat12:1;    /* Endpoint 12 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat13:1;    /* Endpoint 13 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat14:1;    /* Endpoint 14 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat15:1;    /* Endpoint 15 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptsetupstat_t;

#define USB2_CONTROLLER_USB2D_ENDPTPRIME_OFFSET 0x1B0
#define USB2_CONTROLLER_USB2D_ENDPTPRIME_RESET  0x00000000
typedef union usb2_controller_usb2d_endptprime_u {
    struct {
        unsigned int perb0:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb1:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb2:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb3:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb4:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb5:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb6:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb7:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb8:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb9:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb10:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb11:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb12:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb13:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb14:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb15:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int petb0:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb1:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb2:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb3:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb4:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb5:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb6:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb7:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb8:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb9:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb10:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb11:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb12:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb13:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb14:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb15:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptprime_t;

#define USB2_CONTROLLER_USB2D_ENDPTFLUSH_OFFSET 0x1B4
#define USB2_CONTROLLER_USB2D_ENDPTFLUSH_RESET  0x00000000
typedef union usb2_controller_usb2d_endptflush_u {
    struct {
        unsigned int ferb0:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb1:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb2:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb3:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb4:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb5:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb6:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb7:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb8:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb9:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb10:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb11:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb12:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb13:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb14:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb15:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb0:1;               /* Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb1:1;               /*  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb2:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb3:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb4:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb5:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb6:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb7:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb8:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb9:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb10:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb11:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb12:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb13:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb14:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb15:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptflush_t;

#define USB2_CONTROLLER_USB2D_ENDPTSTATUS_OFFSET 0x1B8
#define USB2_CONTROLLER_USB2D_ENDPTSTATUS_RESET  0x00000000
typedef union usb2_controller_usb2d_endptstatus_u {
    struct {
        unsigned int erbr0:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr1:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr2:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr3:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr4:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr5:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr6:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr7:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr8:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr9:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr10:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr11:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr12:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr13:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr14:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr15:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr0:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr1:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr2:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr3:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr4:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr5:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr6:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr7:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr8:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr9:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr10:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr11:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr12:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr13:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr14:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr15:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptstatus_t;

#define USB2_CONTROLLER_USB2D_ENDPTCOMPLETE_OFFSET 0x1BC
#define USB2_CONTROLLER_USB2D_ENDPTCOMPLETE_RESET  0x00000000
typedef union usb2_controller_usb2d_endptcomplete_u {
    struct {
        unsigned int erce0:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce1:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce2:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce3:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce4:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce5:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce6:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce7:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce8:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce9:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce10:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce11:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce12:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce13:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce14:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce15:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int etce0:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce1:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce2:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce3:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce4:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce5:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce6:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce7:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce8:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce9:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce10:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce11:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce12:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce13:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce14:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce15:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptcomplete_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL0_OFFSET 0x1C0
#define USB2_CONTROLLER_USB2D_ENDPTCTRL0_RESET  0x00800080
#define USB2_CONTROLLER_USB2D_ENDPTCTRL0_WRMASK 0xFF72FF72
typedef union usb2_controller_usb2d_endptctrl0_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: Software can write a one to this bit to force the  endpoint to return a STALL handshake to the Host. It will continue returning  STALL until the bit is cleared by software or it will automatically be  cleared upon receipt of a new SETUP request.  */
        unsigned int undefined_bit_1:1;
        unsigned int rxt:2;                 /* RX Endpoint Type. Endpoint 0 is fixed as a Control Endpoint.  */
        unsigned int undefined_bits_4_6:3;
        unsigned int rxe:1;                 /*  RX Endpoint Enable. Endpoint 0 is always  enabled.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: Software can write a one to this bit to force the  endpoint to return a STALL handshake to the Host. It will continue returning  STALL until the bit is cleared by software or it will automatically be  cleared upon receipt of a new SETUP request.  */
        unsigned int undefined_bit_17:1;
        unsigned int txt:2;                 /* TX Endpoint Type. Endpoint0 is fixed as a Control Endpoint.  */
        unsigned int undefined_bits_20_22:3;
        unsigned int txe:1;                 /* TX Endpoint Enable. Endpoint 0 is always  enabled.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl0_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL1_OFFSET 0x1C4
#define USB2_CONTROLLER_USB2D_ENDPTCTRL1_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL1_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl1_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above,  */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl1_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL2_OFFSET 0x1C8
#define USB2_CONTROLLER_USB2D_ENDPTCTRL2_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL2_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl2_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl2_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL3_OFFSET 0x1CC
#define USB2_CONTROLLER_USB2D_ENDPTCTRL3_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL3_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl3_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl3_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL4_OFFSET 0x1D0
#define USB2_CONTROLLER_USB2D_ENDPTCTRL4_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL4_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl4_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl4_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL5_OFFSET 0x1D4
#define USB2_CONTROLLER_USB2D_ENDPTCTRL5_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL5_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl5_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl5_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL6_OFFSET 0x1D8
#define USB2_CONTROLLER_USB2D_ENDPTCTRL6_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL6_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl6_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl6_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL7_OFFSET 0x1DC
#define USB2_CONTROLLER_USB2D_ENDPTCTRL7_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL7_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl7_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl7_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL8_OFFSET 0x1E0
#define USB2_CONTROLLER_USB2D_ENDPTCTRL8_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL8_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl8_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl8_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL9_OFFSET 0x1E4
#define USB2_CONTROLLER_USB2D_ENDPTCTRL9_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL9_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl9_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl9_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL10_OFFSET 0x1E8
#define USB2_CONTROLLER_USB2D_ENDPTCTRL10_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL10_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl10_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl10_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL11_OFFSET 0x1EC
#define USB2_CONTROLLER_USB2D_ENDPTCTRL11_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL11_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl11_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl11_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL12_OFFSET 0x1F0
#define USB2_CONTROLLER_USB2D_ENDPTCTRL12_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL12_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl12_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl12_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL13_OFFSET 0x1F4
#define USB2_CONTROLLER_USB2D_ENDPTCTRL13_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL13_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl13_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl13_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL14_OFFSET 0x1F8
#define USB2_CONTROLLER_USB2D_ENDPTCTRL14_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL14_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl14_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl14_t;

#define USB2_CONTROLLER_USB2D_ENDPTCTRL15_OFFSET 0x1FC
#define USB2_CONTROLLER_USB2D_ENDPTCTRL15_RESET  0x00000000
#define USB2_CONTROLLER_USB2D_ENDPTCTRL15_WRMASK 0xFFFDFFFD
typedef union usb2_controller_usb2d_endptctrl15_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_usb2d_endptctrl15_t;

#define USB1_IF_USB_SUSP_CTRL_OFFSET 0x400
#define USB1_IF_USB_SUSP_CTRL_RESET  0x00000000
#define USB1_IF_USB_SUSP_CTRL_WRMASK 0xFFFFFE3E
typedef union usb1_if_usb_susp_ctrl_u {
    struct {
        unsigned int usb_wakeup_int_sts:1;  /* USB wakeup interrupt status This bit is set whenever USB wakes up from suspend (a wakeup event is generated). Software must write a 1 to clear this bit. Note that during the wakeup sequence, PHY clocks will be resumed from suspend. Software can check when the PHY clocks are resumed by reading the bit USB_PHY_CLK_VALID. There is also a separate interrupt generated when PHY clock is resumed if USB_PHY_CLK_VALID_INT_EN is set. During the wakeup sequence, first USB_WAKEUP_INT_STS will be set, and it will take some time for the PHY clock to resume, which can be detected by checking USB_PHY_CLK_VALID. */
        unsigned int usb_wakeup_int_enb:1;  /* USB wakeup interrupt enable If this bit is enabled, interrupt is generated whenever USB wakeup event is generated. */
        unsigned int usb_wake_on_resume_en:1; /* Wake on resume enable If this bit is enabled, USB will wakeup from suspend whenever a resume event is detected on USB. This is valid for both USB device and USB host modes. */
        unsigned int usb_wake_on_cnnt_en_dev:1; /* Wake on Connect Enable (device mode) When enabled (1), USB device will wakeup from suspend on a connect event. This is only valid when USB controller is in device mode, it is not applicable when USB controller is in host mode. */
        unsigned int usb_wake_on_discon_en_dev:1; /* Wake on Disconnect Enable (device mode) When enabled (1), USB device will wakeup from suspend on a disconnect event. This is only valid when USB controller is in device mode, it is not applicable when USB controller is in host mode. */
        unsigned int usb_susp_clr:1;        /* Suspend Clear Software must write a 1 to this bit to bring the PHY out of suspend mode. This is used when the software stops the PHY clock during suspend and then wants to initiate a resume. Software should also write 0 to clear it. NOTE: It is required that software generate a  positive pulse on this bit to guarantee proper operation. */
        unsigned int usb_clken:1;           /* USB AHB clock enable status. Indicates whether the AHB clock to the USB controller is enabled or not. If AHB clock to USB controller is enabled, this bit is set to 1, else it is set to 0. NOTE: even when this is set to 0, all essential blocks that are required to resume USB clocks from suspend will be active and their AHB clock will not be suspended. */
        unsigned int usb_phy_clk_valid:1;   /* USB PHY clock valid status This bit indicates whether the USB PHY is generating a valid clock to  the USB controller. If USB PHY clock is running, this bit is set to 1, else it is set to 0. */
        unsigned int usb_phy_clk_valid_int_sts:1; /* USB PHY clock valid interrupt status This bit is set whenever USB PHY clock is waked up from suspend. Software must write a 1 to clear this bit. */
        unsigned int usb_phy_clk_valid_int_enb:1; /* USB PHY clock valid interrupt enable If this bit is enabled, interrupt is generated whenever USB clocks are resumed from a suspend. */
        unsigned int usb_susp_pol:1;        /* Polarity of the suspend signal going to USB PHY. 0 = Active low (default) 1 = Active high This should not be changed by software. */
        unsigned int utmip_reset:1;         /* Reset going to UTMIP PHY (active high). This should be set to 1 whenever programming the UTMIP config registers. It should be cleared to 0 after the programming of UTMIP config registers is done. UTMIP config registers should be programmed only once before doing any transactions on USB. The UTMIP PHY registers should be programmed while UTMIP is in reset. */
        unsigned int undefined_bits_12_13:2;
        unsigned int usb_susp_set:1;        /* Suspend Set Software must write a 1 to this bit to set the PHY into suspend mode. Software should also write 0 to clear it. NOTE: It is required that software generate a  positive pulse on this bit to guarantee proper operation. */
        unsigned int undefined_bit_15:1;
        unsigned int usb_wakeup_debounce_count:3; /* USB PHY wakeup debounce counter USB will debounce any wakeup event by the number of clocks programmed  in this counter. A value of 0 results in no debounce. */
        unsigned int undefined_bits_19_31:13;
    };

    uint32_t reg32;
} usb1_if_usb_susp_ctrl_t;

#define USB1_IF_USB_PHY_VBUS_SENSORS_OFFSET 0x404
#define USB1_IF_USB_PHY_VBUS_SENSORS_RESET  0x00000000
#define USB1_IF_USB_PHY_VBUS_SENSORS_WRMASK 0xF9F9F9F9
typedef union usb1_if_usb_phy_vbus_sensors_u {
    struct {
        unsigned int b_sess_end_int_en:1;   /* B_SESS_END interrupt enable If this field is set to 1, an interrupt is generated whenever B_SESS_END_CHG_DET is set to 1. */
        unsigned int b_sess_end_chg_det:1;  /* B_SESS_END change detect. This field is set by hardware whenever a change is detected in the value of B_SESS_END. software writes a 1 to clear it */
        unsigned int b_sess_end_sts:1;      /* B_SESS_END status This is set to 1 whenever B_SESS_END sensor output is 1. */
        unsigned int b_sess_end_sw_en:1;    /* B_SESS_END software enable Enable Software Controlled B_SESS_END Software sets this bit to drive the value in B_SESS_END_SW_VALUE to the USB controller. */
        unsigned int b_sess_end_sw_value:1; /* B_SESS_END software value Software should write the appropriate value (1/0) to set/unset the B_SESS_END status. This is only valid when B_SESS_END_SW_EN is set. */
        unsigned int b_sess_end_deb_sel_b:1; /* B_SESS_END debounce A/B select Selects between the two debounce values  UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. */
        unsigned int b_sess_end_wakeup_en:1; /* B_SESS_END wakeup enable If this bit is enabled, USB will wakeup from suspend whenever a change is detected on B_SESS_END. */
        unsigned int undefined_bit_7:1;
        unsigned int b_sess_vld_int_en:1;   /* B_SESS_VLD interrupt enable If this field is set to 1, an interrupt is generated whenever B_SESS_VLD_CHG_DET is set to 1. */
        unsigned int b_sess_vld_chg_det:1;  /* B_SESS_VLD change detect. This field is set by hardware whenever a change is detected in the value of B_SESS_VLD. software writes a 1 to clear it */
        unsigned int b_sess_vld_sts:1;      /* B_SESS_VLD status This is set to 1 whenever B_SESS_VLD sensor output is 1. */
        unsigned int b_sess_vld_sw_en:1;    /* B_SESS_VLD software enable Enable Software Controlled B_SESS_VLD. Software sets this bit to drive the value in B_SESS_VLD_SW_VALUE to the USB controller. */
        unsigned int b_sess_vld_sw_value:1; /* B_SESS_VLD software value Software should write the appropriate value (1/0) to set/unset the B_SESS_VLD status. This is only valid when B_SESS_VLD_SW_EN is set. */
        unsigned int b_sess_vld_deb_sel_b:1; /* B_SESS_VLD debounce A/B select Selects between the two debounce values  UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. */
        unsigned int b_sess_vld_wakeup_en:1; /* B_SESS_VLD wakeup enable If this bit is enabled, USB will wakeup from suspend whenever a change is detected on B_SESS_VLD. */
        unsigned int undefined_bit_15:1;
        unsigned int a_sess_vld_int_en:1;   /* A_SESS_VLD interrupt enable If this field is set to 1, an interrupt is generated whenever A_SESS_VLD_CHG_DET is set to 1. */
        unsigned int a_sess_vld_chg_det:1;  /* A_SESS_VLD change detect. This field is set by hardware whenever a change is detected in the value of A_SESS_VLD. software writes a 1 to clear it */
        unsigned int a_sess_vld_sts:1;      /* A_SESS_VLD status This is set to 1 whenever A_SESS_VLD sensor output is 1. */
        unsigned int a_sess_vld_sw_en:1;    /* A_SESS_VLD software enable Enable Software Controlled A_SESS_VLD. Software sets this bit to drive the value in A_SESS_VLD_SW_VALUE to the USB controller. */
        unsigned int a_sess_vld_sw_value:1; /* A_SESS_VLD software value Software should write the appropriate value (1/0) to set/unset the A_SESS_VLD status. This is only valid when A_SESS_VLD_SW_EN is set. */
        unsigned int a_sess_vld_deb_sel_b:1; /* A_SESS_VLD debounce A/B select Selects between the two debounce values  UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. */
        unsigned int a_sess_vld_wakeup_en:1; /* A_SESS_VLD wakeup enable If this bit is enabled, USB will wakeup from suspend whenever a change is detected on A_SESS_VLD. */
        unsigned int undefined_bit_23:1;
        unsigned int a_vbus_vld_int_en:1;   /* A_VBUS_VLD interrupt enable If this field is set to 1, an interrupt is generated whenever A_VBUS_VLD_CHG_DET is set to 1. */
        unsigned int a_vbus_vld_chg_det:1;  /* A_VBUS_VLD change detect. This field is set by hardware whenever a change is detected in the value of A_VBUS_VLD. software writes a 1 to clear it */
        unsigned int a_vbus_vld_sts:1;      /* A_VBUS_VLD status This is set to 1 whenever A_VBUS_VLD sensor output is 1. */
        unsigned int a_vbus_vld_sw_en:1;    /* A_VBUS_VLD software enable Enable Software Controlled A_VBUS_VLD. Software sets this bit to drive the value in A_VBUS_VLD_SW_VALUE to the USB controller. */
        unsigned int a_vbus_vld_sw_value:1; /* A_VBUS_VLD software value Software should write the appropriate value (1/0) to set/unset the A_VBUS_VLD status. This is only valid when A_VBUS_VLD_SW_EN is set. */
        unsigned int a_vbus_vld_deb_sel_b:1; /* A_VBUS_VLD debounce A/B select Selects between the two debounce values  UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. */
        unsigned int a_vbus_vld_wakeup_en:1; /* A_VBUS_VLD wakeup enable If this bit is enabled, USB will wakeup from suspend whenever a change is detected on A_VBUS_VLD. */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} usb1_if_usb_phy_vbus_sensors_t;

#define USB1_IF_USB_PHY_VBUS_WAKEUP_ID_OFFSET 0x408
#define USB1_IF_USB_PHY_VBUS_WAKEUP_ID_RESET  0x00000040
#define USB1_IF_USB_PHY_VBUS_WAKEUP_ID_WRMASK 0xFFF9F9F9
typedef union usb1_if_usb_phy_vbus_wakeup_id_u {
    struct {
        unsigned int id_int_en:1;           /* ID interrupt enable If this field is set to 1, an interrupt is generated whenever ID_CHG_DET is set to 1. */
        unsigned int id_chg_det:1;          /* ID change detect. This field is set by hardware whenever a change is detected in the value of ID. software writes a 1 to clear it */
        unsigned int id_sts:1;              /* ID status This is set to 1 whenever ID sensor output is 1. */
        unsigned int id_sw_en:1;            /* ID software enable Enable Software Controlled ID. Software sets this bit to drive the value in ID_SW_VALUE to the USB controller */
        unsigned int id_sw_value:1;         /* ID software value Software should write the appropriate value (1/0) to set/unset the ID status. This is only valid when ID_SW_EN is set. */
        unsigned int id_deb_sel_b:1;        /* ID debounce A/B select Selects between the two debounce values  UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. */
        unsigned int id_pu:1;               /* ID pullup enable. Set to 1. */
        unsigned int undefined_bit_7:1;
        unsigned int vbus_wakeup_int_en:1;  /* VBUS wakeup interrupt enable If this field is set to 1, an interrupt is generated whenever VBUS_WAKEUP_CHG_DET is set to 1. */
        unsigned int vbus_wakeup_chg_det:1; /* VBUS wakeup change detect. This field is set by hardware whenever a change is detected in the value of VBUS_WAKEUP. software writes a 1 to clear it */
        unsigned int vbus_wakeup_sts:1;     /* VBUS wakeup status This is set to 1 whenever VBUS_WAKEUP sensor output is 1. */
        unsigned int vbus_wakeup_sw_en:1;   /* VBUS wakeup software enable Enable Software Controlled VBUS_WAKEUP. Software sets this bit to drive the value in VBUS_WAKEUP_SW_VALUE to the USB controller. */
        unsigned int vbus_wakeup_sw_value:1; /* VBUS wakeup software value Software should write the appropriate value (1/0) to set/unset the VBUS_WAKEUP status. This is only valid when VBUS_WAKEUP_SW_EN is set. */
        unsigned int vbus_wakeup_deb_sel_b:1; /* VBUS_WAKEUP debounce A/B select Selects between the two debounce values  UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. */
        unsigned int undefined_bits_14_15:2;
        unsigned int vdat_det_int_en:1;     /* VDAT_DET interrupt enable If this field is set to 1, an interrupt is generated whenever VDAT_DET_CHG_DET is set to 1. */
        unsigned int vdat_det_chg_det:1;    /* VDAT_DET change detect. This field is set by hardware whenever a change is detected in the value of VDAT_DET. software writes a 1 to clear it */
        unsigned int vdat_det_sts:1;        /* VDAT_DET status This is set to 1 whenever VDAT_DET sensor output is 1. */
        unsigned int vdat_det_sw_en:1;      /* VDAT_DET software enable Enable Software Controlled VDAT_DET. Software sets this bit to drive the value in VDAT_DET_SW_VALUE to the USB controller */
        unsigned int vdat_det_sw_value:1;   /* VDAT_DET software value Software should write the appropriate value (1/0) to set/unset the VDAT_DET status. This is only valid when VDAT_DET_SW_EN is set. */
        unsigned int vdat_det_deb_sel_b:1;  /* VDAT_DET debounce A/B select Selects between the two debounce values  UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. */
        unsigned int undefined_bits_22_29:8;
        unsigned int vbus_wakeup_wakeup_en:1; /* VBUS_WAKEUP wakeup enable If this bit is enabled, USB will wakeup from suspend whenever a change is detected on VBUS_WAKEUP. */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} usb1_if_usb_phy_vbus_wakeup_id_t;

#define USB1_IF_USB_PHY_ALT_VBUS_STS_OFFSET 0x40C
#define USB1_IF_USB_PHY_ALT_VBUS_STS_RESET  0x00000000
#define USB1_IF_USB_PHY_ALT_VBUS_STS_WRMASK 0xFFFFFF80
typedef union usb1_if_usb_phy_alt_vbus_sts_u {
    struct {
        unsigned int vbus_wakeup_alt:1;     /* Vbus wakeup alternate status */
        unsigned int a_vbus_vld_alt:1;      /* A_VBUS_VLD alternate status */
        unsigned int static_gpi_alt:1;      /* Static GPI alternate status */
        unsigned int b_sess_end_alt:1;      /* B_SESS_END alternate status */
        unsigned int id_dig_alt:1;          /* ID alternate status */
        unsigned int b_sess_vld_alt:1;      /* B_SESS_VLD alternate status */
        unsigned int a_sess_vld_alt:1;      /* A_SESS_VLD alternate status */
        unsigned int undefined_bits_7_31:25;
    };

    uint32_t reg32;
} usb1_if_usb_phy_alt_vbus_sts_t;

#define USB1_IF_USB1_LEGACY_CTRL_OFFSET 0x410
#define USB1_IF_USB1_LEGACY_CTRL_RESET  0x00000000
typedef union usb1_if_usb1_legacy_ctrl_u {
    struct {
        unsigned int usb1_no_legacy_mode:1; /* Legacy registers select The default is to select legacy mode registers in  APB_MISC for USB1. Selects new registers if this is set to 1. */
        unsigned int usb1_vbus_sense_ctl:2; /* Vbus_sense control Controls which VBUS sensor input is driven to the controller. 00: Use VBUS_WAKEUP. 01: Use (A_SESS_VLD || B_SESS_VLD) output from the PHY if the PHY clock is available. Otherwise, use VBUS_WAKEUP. 10: Use (A_SESS_VLD || B_SESS_VLD) output from the PHY 11: Use A_SESS_VLD output from the PHY */
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} usb1_if_usb1_legacy_ctrl_t;

#define USB1_IF_USB_INTER_PKT_DELAY_CTRL_OFFSET 0x420
#define USB1_IF_USB_INTER_PKT_DELAY_CTRL_RESET  0x00000006
typedef union usb1_if_usb_inter_pkt_delay_ctrl_u {
    struct {
        unsigned int ip_delay_tx2tx_hs:6;   /* HS Tx to Tx inter-packet delay. Software should not change this. */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} usb1_if_usb_inter_pkt_delay_ctrl_t;

#define USB1_IF_USB_DEBUG_OFFSET 0x480
#define USB1_IF_USB_DEBUG_RESET  0x00000000
typedef union usb1_if_usb_debug_u {
    struct {
        unsigned int undefined_bits_0_4:5;
        unsigned int usb_buf_ahb_if_sel:1;  /* Route USB buffers to AHB interface for debug. When this is set to 1, normal USB operations cannot be done. */
        unsigned int usb_buf_low32bits_sel:1; /* Lower 32-bits select. Only valid for Tx and Rx memories that have 36-bit interface. When 0, selects upper 4-bits. When 1, selects lower 32-bits. */
        unsigned int undefined_bits_7_31:25;
    };

    uint32_t reg32;
} usb1_if_usb_debug_t;

#define USB1_IF_USB_PHY_SELF_TEST_OFFSET 0x484
#define USB1_IF_USB_PHY_SELF_TEST_RESET  0x10150008
#define USB1_IF_USB_PHY_SELF_TEST_WRMASK 0xFFFF7FF3
typedef union usb1_if_usb_phy_self_test_u {
    struct {
        unsigned int tstenb:1;              /* Place UTMIP in test mode. This does not start the test. */
        unsigned int tston:1;               /* Sw writes a 1 to start the test. It writes a 0 to  end the test */
        unsigned int tstend:1;              /* Goes to 1 when the test finishes. At that time,  TSTPASS is valid and indicates the tests pass/fail status */
        unsigned int tstps:1;               /* When test is started, this status signal starts as  1 and is set to 0 if an error is detected. Can be sampled when TSTEND is  asserted. */
        unsigned int xcvr:2;                /* XCVR_select: */
        unsigned int term:1;                /* Term_select */
        unsigned int undefined_bit_7:1;
        unsigned int opmode:2;              /* Operational Mode */
        unsigned int undefined_bits_10_11:2;
        unsigned int dmpd:1;                /* Enable pulldown on DM */
        unsigned int dppd:1;                /* Enable pulldown on DP */
        unsigned int sof_en:1;              /* Enable transmission of SOF */
        unsigned int discon:1;              /* Status of Disconnect signal from PHY */
        unsigned int ipkt_dly:8;            /* Interpacket delay between two consecutive packets in no of 60 Mhz cycles */
        unsigned int test_pkt_cnt:8;        /* No of test packets to be sent. 0 = infinite, continue sending packets until test mode is disabled. */
    };

    uint32_t reg32;
} usb1_if_usb_phy_self_test_t;

#define USB1_IF_USB_PHY_SELF_TEST2_OFFSET 0x488
#define USB1_IF_USB_PHY_SELF_TEST2_RESET  0x00000000
typedef union usb1_if_usb_phy_self_test2_u {
    struct {
        unsigned int test_sof_j:1;          /* If enabled, send SOF with EOP of J, else send SOF with EOP of K */
        unsigned int send_test_j:1;         /* Enable TEST_K transmission */
        unsigned int send_test_k:1;         /* Enable TEST_J transmission */
        unsigned int send_test_pkt:1;       /* Enable transmission of test packets */
        unsigned int rcv_test_pkt:1;        /* Enable reception of test packets */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} usb1_if_usb_phy_self_test2_t;

#define USB1_IF_USB_PHY_SELF_TEST_DEBUG_OFFSET 0x48C
#define USB1_IF_USB_PHY_SELF_TEST_DEBUG_RESET  0x00000000
#define USB1_IF_USB_PHY_SELF_TEST_DEBUG_WRMASK 0xFFFC00C0
typedef union usb1_if_usb_phy_self_test_debug_u {
    struct {
        unsigned int fail_rx_byte:6;        /* Failed RX byte index: Points to the Rx byte no. in  the current packet which fails */
        unsigned int undefined_bits_6_7:2;
        unsigned int fail_pkt_no:8;         /* Failed packet no: Points to the failed packet no */
        unsigned int rxvhf:1;               /* Rx valid/Rx validh fail: Indicates that the  Rxvalid/Rxvalidh werent generated according to protocol */
        unsigned int rxcmf:1;               /* RX compare fail. Comparison on RX data failed. */
        unsigned int undefined_bits_18_31:14;
    };

    uint32_t reg32;
} usb1_if_usb_phy_self_test_debug_t;

#define USB1_UTMIP_PLL_CFG0_OFFSET 0x800
#define USB1_UTMIP_PLL_CFG0_RESET  0x00280180
typedef union usb1_utmip_pll_cfg0_u {
    struct {
        unsigned int utmip_pll_lockenable:1; /* LOCK_ENABLE input of USB_PHY PLL. Normally only used during test. See cell specification. */
        unsigned int utmip_pll_locksel:6;   /* LOCKSEL[5:0] input of USB_PHY PLL. Used in test modes only. See cell specification. */
        unsigned int utmip_pll_vcomultby2:1; /* VCOMULTBY2 control of the UTMIP PHY PLL. Recommended setting is on. Additional divide by 2 on the  VCO feedback. Which is setting the bit to 1. See cell spec. */
        unsigned int utmip_pll_mdiv:8;      /* MDIV[7:0] input of the USB_PHY PLL. This is the predivide on the PLL.  0x0 is not allowed. See cell specification. */
        unsigned int utmip_pll_ndiv:8;      /* NDIV[7:0] input of USB_PHY PLL.  This is the feedback divider on the VCO feedback.  0x0 is not allowed. See cell specification. */
        unsigned int utmip_pll_pdiv:3;      /* PDIV[2:0] input of the USB_PHY PLL. Reserved. Keep at 0x0. Currently there is no post divider on this PLL.  See cell specification. */
        unsigned int utmip_pll_pdivrst:1;   /* PDIVRST of the UTMIP PHY PLL. Reserved. Keep at 0x0. Currently there is no post divider on this PLL.  See cell specification. */
        unsigned int utmip_pll_select:3;    /* Selects which of the eight 60MHz clock phases to produce at the output  of the USB PHY PLL. This is for a test mode. See cell specification. */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} usb1_utmip_pll_cfg0_t;

#define USB1_UTMIP_PLL_CFG1_OFFSET 0x804
#define USB1_UTMIP_PLL_CFG1_RESET  0x182000C0
typedef union usb1_utmip_pll_cfg1_u {
    struct {
        unsigned int utmip_xtal_freq_count:12; /* Determines the time to wait until the output of USB_PHY PLL is considered stable.  */
        unsigned int utmip_force_pll_active_powerdown:1; /* Force USB_PHY PLL pll_active input off. (Overrides FORCE_PLL_ACTIVE_POWERUP.) */
        unsigned int utmip_force_pll_active_powerup:1; /* Force USB_PHY PLL pll_active input on.  */
        unsigned int utmip_force_pll_enable_powerdown:1; /* Force USB_PHY PLL pll_enable input off. (Overrides FORCE_PLL_ENABLE_POWERUP.) */
        unsigned int utmip_force_pll_enable_powerup:1; /* Force USB_PHY PLL pll_enable input on.  */
        unsigned int utmip_force_pllu_powerdown:1; /* Force PLL_U into power down. (Overrides FORCE_PLLU_POWERUP.)   */
        unsigned int utmip_force_pllu_powerup:1; /* Force PLL_U into power up. */
        unsigned int utmip_pll_setup:9;     /* SETUP[8:0] input of USB_PHY PLL. */
        unsigned int utmip_pllu_enable_dly_count:5; /* Controls the wait time to enable PLL_U when coming out of suspend or reset. */
    };

    uint32_t reg32;
} usb1_utmip_pll_cfg1_t;

#define USB1_UTMIP_XCVR_CFG0_OFFSET 0x808
#define USB1_UTMIP_XCVR_CFG0_RESET  0x20202500
typedef union usb1_utmip_xcvr_cfg0_u {
    struct {
        unsigned int utmip_xcvr_setup:4;    /* SETUP[3:0] input of XCVR cell. HS driver output control. 4 LSBs. */
        unsigned int utmip_xcvr_hsslew:2;   /* HS slew rate control. The two LSBs. */
        unsigned int utmip_xcvr_fsslew:2;   /* FS slew rate control. */
        unsigned int utmip_xcvr_lsrslew:2;  /* LS rising slew rate control. */
        unsigned int utmip_xcvr_lsfslew:2;  /* LS falling slew rate control. */
        unsigned int utmip_xcvr_hsloopback:1; /* Internal loopback inside XCVR cell. Used for IOBIST. */
        unsigned int utmip_xcvr_termen:1;   /* Enable HS termination. */
        unsigned int utmip_force_pd_powerdown:1; /* Force PD input into power down. (Overrides FORCE_PD_POWERUP.) */
        unsigned int utmip_force_pd_powerup:1; /* Force PD input into power up.  */
        unsigned int utmip_force_pd2_powerdown:1; /* Force PD2 input into power down. (Overrides FORCE_PD2_POWERUP.) */
        unsigned int utmip_force_pd2_powerup:1; /* Force PD2 input into power up. */
        unsigned int utmip_force_pdzi_powerdown:1; /* Force PDZI input into power down. (Overrides FORCE_PDZI_POWERUP.) */
        unsigned int utmip_force_pdzi_powerup:1; /* Force PDZI input into power up. */
        unsigned int utmip_xcvr_discon_method:1; /* Disconnect method on the usb transceiver pad */
        unsigned int utmip_xcvr_lsbias_sel:1; /* Low speed bias selection method for usb transceiver pad */
        unsigned int utmip_xcvr_setup_msb:3; /* Most significant bits of SETUP. */
        unsigned int utmip_xcvr_hsslew_msb:7; /* Most significant bits of HS_SLEW. */
    };

    uint32_t reg32;
} usb1_utmip_xcvr_cfg0_t;

#define USB1_UTMIP_BIAS_CFG0_OFFSET 0x80C
#define USB1_UTMIP_BIAS_CFG0_RESET  0x00000000
typedef union usb1_utmip_bias_cfg0_u {
    struct {
        unsigned int utmip_hssquelch_level:2; /* HS squelch detector level. */
        unsigned int utmip_hsdiscon_level:2; /* HS disconnect detector level. */
        unsigned int utmip_hschirp_level:2; /* HS chirp detector level. */
        unsigned int utmip_sess_level_level:2; /* SessionEnd detector level. */
        unsigned int utmip_vbus_level_level:2; /* Vbus detector level. */
        unsigned int utmip_biaspd:1;        /* Power down bias circuit. */
        unsigned int utmip_otgpd:1;         /* Power down OTG circuit. */
        unsigned int utmip_active_pullup_offset:3; /* Active 1.5K pullup control offset. */
        unsigned int utmip_active_term_offset:3; /* Active termination control offset. */
        unsigned int utmip_gpi_sel:1;       /* 0: StaticGpi = IdDig. 1: StaticGpi = GPI_VAL. */
        unsigned int utmip_gpi_val:1;       /* See GPI_SEL. */
        unsigned int utmip_iddig_sel:1;     /* 0: IdDig = IdDig. 1: IdDig = IDDIG_VAL. */
        unsigned int utmip_iddig_val:1;     /* See IDDIG_SEL. */
        unsigned int utmip_idpd_sel:1;      /* 0: IDPD = ~IdPullup. 1: IDPD = IDPD_VAL. */
        unsigned int utmip_idpd_val:1;      /* See IDPD_SEL. */
        unsigned int utmip_hsdiscon_level_msb:1; /* Most significant bit of UTMIP_HSDISCON_LEVEL, bit 2 */
        unsigned int undefined_bits_25_31:7;
    };

    uint32_t reg32;
} usb1_utmip_bias_cfg0_t;

#define USB1_UTMIP_HSRX_CFG0_OFFSET 0x810
#define USB1_UTMIP_HSRX_CFG0_RESET  0x91653400
typedef union usb1_utmip_hsrx_cfg0_u {
    struct {
        unsigned int utmip_use4sync_tran:1; /* Require 4 sync pattern transitions (01) instead of 3 */
        unsigned int utmip_three_syncbits:1; /* Sync pattern detection needs 3 consecutive samples instead of 4 */
        unsigned int utmip_phase_adjust:2;  /* Based on incoming edges and current sampling position, adjust phase */
        unsigned int utmip_pcount_inertia:2; /* Retime the path.  */
        unsigned int utmip_pass_feedback:1; /* Pass through the feedback, do not block it. */
        unsigned int utmip_pass_chirp:1;    /* When in Chirp Mode, allow chirp rx data through */
        unsigned int utmip_elastic_underrun_disable:1; /* Do not declare underrun errors */
        unsigned int utmip_elastic_overrun_disable:1; /* Do not declare overrun errors until overflow of FIFO */
        unsigned int utmip_elastic_limit:5; /* Depth of elastic input store */
        unsigned int utmip_idle_wait:5;     /* Number of cycles of idle to declare IDLE.  */
        unsigned int utmip_no_stripping:1;  /* Do not strip incoming data */
        unsigned int utmip_squelch_eop_dly:3; /* Limit the delay of the squelch at EOP time */
        unsigned int utmip_pcount_updn_div:4; /* The number of (edges-1) needed to move the sampling point */
        unsigned int utmip_realign_on_new_pkt:1; /* Realign the inertia counters on a new packet */
        unsigned int utmip_allow_consec_updn:1; /* Allow consecutive ups and downs on the bits, debug only, set to 0. */
        unsigned int utmip_keep_patt_on_active:2; /* Keep the stay alive pattern on active */
    };

    uint32_t reg32;
} usb1_utmip_hsrx_cfg0_t;

#define USB1_UTMIP_HSRX_CFG1_OFFSET 0x814
#define USB1_UTMIP_HSRX_CFG1_RESET  0x00000013
typedef union usb1_utmip_hsrx_cfg1_u {
    struct {
        unsigned int utmip_hs_allow_keep_alive:1; /* Allow Keep Alive packets  */
        unsigned int utmip_hs_sync_start_dly:5; /* How long to wait before start of sync launches RxActive */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} usb1_utmip_hsrx_cfg1_t;

#define USB1_UTMIP_FSLSRX_CFG0_OFFSET 0x818
#define USB1_UTMIP_FSLSRX_CFG0_RESET  0xFD548429
typedef union usb1_utmip_fslsrx_cfg0_u {
    struct {
        unsigned int utmip_fsls_idle_count_limit:1; /* Give up on packet if a long sequence of J  */
        unsigned int utmip_fsls_idle_count_max:6; /* 20 bits of idle should end the packet if FsLsIdleCountLimitCfg=1. */
        unsigned int utmip_fsls_idle_wait_limit:1; /* Enable the reset of the state machine on extended SE0 */
        unsigned int utmip_fsls_idle_wait_max:6; /* 4 bits of of SEO should exceed the time limit */
        unsigned int utmip_fsls_active_on_full_sync:1; /* Require a full sync pattern to declare the data received */
        unsigned int utmip_fsls_kcount_limit:1; /* Limit the number of bit times a K can last */
        unsigned int utmip_fsls_kcount_max:6; /* Number of K bits in question */
        unsigned int utmip_fsls_eop_ends_at_se0:1; /* Only look for transitioning out of EOP */
        unsigned int utmip_fsls_lwr_dribble_size:3; /* Do not allow >= dribble bits  */
        unsigned int utmip_fsls_upr_dribble_size:3; /* Do not allow <= dribble bits */
        unsigned int utmip_fsls_serial_se0_rcv:1;
        unsigned int utmip_fsls_se1_filter:1; /* Filter SE1 */
        unsigned int utmip_fsls_se1_dribble_filter:1; /* One SE1, don't allow dribble */
    };

    uint32_t reg32;
} usb1_utmip_fslsrx_cfg0_t;

#define USB1_UTMIP_FSLSRX_CFG1_OFFSET 0x81C
#define USB1_UTMIP_FSLSRX_CFG1_RESET  0x02267400
typedef union usb1_utmip_fslsrx_cfg1_u {
    struct {
        unsigned int utmip_fs_eop_length:1; /* Whether full speed EOP  is determined within 3(0) or 4(1) 60MHz cycles */
        unsigned int utmip_fs_debounce:1;   /* Whether full speed uses debouncing */
        unsigned int utmip_fs_weak_sync:1;  /* Only look for a KK pattern, instead of KJKK */
        unsigned int utmip_fs_lenient_dribble:1; /* Allow for large dribble in full speed mode */
        unsigned int utmip_ls_lenient_dribble:1; /* Allow for large dribble in low  speed mode */
        unsigned int utmip_ls_se0_count:6;  /* Only for this number of 60MHz of SEO and Idle to end packet */
        unsigned int utmip_ls_eop_start_count:6; /* Number of SEO clock cycles to block bit extraction */
        unsigned int utmip_ls_extraction_count:6; /* Phase count on which LS bits are extracted */
        unsigned int utmip_ls_bounce_length:3; /* Number of clock cycle of LS stable */
        unsigned int utmip_early_line_state_filter:1; /* Assumes line state filtering table is inclusive, not exclusive */
        unsigned int undefined_bits_27_31:5;
    };

    uint32_t reg32;
} usb1_utmip_fslsrx_cfg1_t;

#define USB1_UTMIP_TX_CFG0_OFFSET 0x820
#define USB1_UTMIP_TX_CFG0_RESET  0x00010200
typedef union usb1_utmip_tx_cfg0_u {
    struct {
        unsigned int utmip_no_sync_no_eop:1; /* Do not sent SYNC or EOP */
        unsigned int utmip_no_encoding:1;   /* No encoding, static programming */
        unsigned int utmip_no_stuffing:1;   /* No bit stuffing, static programming */
        unsigned int utmip_sof_on_no_encode:1; /* Sof when OpMode 2 -- not likely, for Chirp */
        unsigned int utmip_sof_on_no_stuff:1; /* Sof when OpMode 3 -- perhaps, when sending controller made packets */
        unsigned int utmip_sie_resume_on_linestate:1; /* SIE, not macrocell, detects LineState change to resume */
        unsigned int utmip_hs_preamble_output_enable:1; /* output enable turns on  1 cycle before */
        unsigned int utmip_hs_postamble_output_enable:1; /* output enable turns off 1 cycle after */
        unsigned int utmip_hs_discon_disable:1; /* Disable high speed disconnect */
        unsigned int utmip_hs_discon_eop_only:1; /* Only check during EOP */
        unsigned int utmip_hs_tx_ipg_dly:5;
        unsigned int utmip_hs_ready_wait_for_valid:1;
        unsigned int utmip_fsls_allow_sop_tx_stuff_err:1; /* Allow SOP to be source of transmit error stuffing */
        unsigned int utmip_fs_preamble_output_enable:1; /* output enable turns on  1/2 cycle before */
        unsigned int utmip_fs_postamble_output_enable:1; /* output enable turns off 1/2 cycle after  */
        unsigned int utmip_fs_preamble_j:1; /* output enable sends an initial J before sync pattern */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} usb1_utmip_tx_cfg0_t;

#define USB1_UTMIP_MISC_CFG0_OFFSET 0x824
#define USB1_UTMIP_MISC_CFG0_RESET  0x03E00078
typedef union usb1_utmip_misc_cfg0_u {
    struct {
        unsigned int utmip_comb_terms:1;    /* Use combinational terminations or synced through CLKXTAL */
        unsigned int utmip_always_free_running_terms:1; /* Use free running terminations at all time */
        unsigned int utmip_never_free_running_terms:1; /* Ignore free running terminations, even when no clock */
        unsigned int utmip_no_free_on_suspend:1; /* Don't use free running terminations during suspend. */
        unsigned int utmip_stable_all:1;    /* Determines if all signal need to be stable to not change a config. */
        unsigned int utmip_stable_count:3;  /* Number of cycles of crystal clock of signal not changing to consider stable. */
        unsigned int utmip_force_pulldn_dm:1; /* Force DM pulldown active. */
        unsigned int utmip_force_pulldn_dp:1; /* Force DP pulldown active. */
        unsigned int utmip_force_pullup_dm:1; /* Force DM pullup active.       */
        unsigned int utmip_force_pullup_dp:1; /* Force DP pullup active. */
        unsigned int utmip_disable_pulldn_dm:1; /* Force DM pulldown inactive. (Overrides FORCE_PULLDN_DM.) */
        unsigned int utmip_disable_pulldn_dp:1; /* Force DP pulldown inactive. (Overrides FORCE_PULLDN_DP.) */
        unsigned int utmip_disable_pullup_dm:1; /* Force DM pullup inactive. (Overrides FORCE_PULLUP_DM.) */
        unsigned int utmip_disable_pullup_dp:1; /* Force DP pullup inactive. (Overrides FORCE_PULLUP_DP.) */
        unsigned int utmip_force_hs_term:1; /* Force HS termination active. */
        unsigned int utmip_disable_hs_term:1; /* Force HS termination inactive. */
        unsigned int utmip_force_hs_clock_on:1; /* Force HS clock always on. */
        unsigned int utmip_inject_error_type:2; /* Force error insertion into RX path. (Used for IOBIST.) */
        unsigned int utmip_ls_to_fs_skip_4ms:1; /* Don't block changes for 4ms when going from LS to FS (should not happen) */
        unsigned int utmip_suspend_exit_on_edge:1; /* Suspend exit requires edge or simply a value... */
        unsigned int utmip_force_fs_disable_on_dev_chirp:1;
        unsigned int utmip_allow_ls_on_soft_discon:1;
        unsigned int utmip_keep_xcvr_pd_on_soft_discon:1;
        unsigned int utmip_dpdm_observe:1;  /* Use DP/DM as obs bus */
        unsigned int utmip_dpdm_observe_sel:4; /* Select DP/DM obs signals */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} usb1_utmip_misc_cfg0_t;

#define USB1_UTMIP_MISC_CFG1_OFFSET 0x828
#define USB1_UTMIP_MISC_CFG1_RESET  0x40198024
typedef union usb1_utmip_misc_cfg1_u {
    struct {
        unsigned int utmip_xcvrsel3:2;      /* Bit 0: 0: 0xa5 -> treat as KeepAlive         1: treat as regular packet  Bit 1: 0: Turn on FS EOP detection        1: Turn off FS EOP detection */
        unsigned int utmip_suspend_termsel:1;
        unsigned int utmip_flip_fsls_polarity:1;
        unsigned int utmip_rx_error_cnt_en:1;
        unsigned int utmip_rx_error_cnt_clr:1;
        unsigned int utmip_pllu_stable_count:12; /* WRONG! This should be 1ms -> 0x50 */
        unsigned int utmip_pll_active_dly_count:5; /* 5 us / (1/19.2MHz) = 96 / 16 = 6 */
        unsigned int utmip_force_iobist_clk_on:1;
        unsigned int utmip_fsls_tdm:1;
        unsigned int utmip_obs_sel:2;
        unsigned int utmip_linestate_xcvrsel3:1; /* 0: Use FS filtering on line state when XcvrSel=3 1: Use LS filtering on line state when XcvrSel=3 */
        unsigned int utmip_linestate_neg:1; /* Use neg edge sync for linestate */
        unsigned int utmip_linestate_bypass:1; /* Bypass LineState reclocking logic */
        unsigned int utmip_phy_xtal_clocken:1; /* Selects whether to enable the crystal clock in the module. */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} usb1_utmip_misc_cfg1_t;

#define USB1_UTMIP_DEBOUNCE_CFG0_OFFSET 0x82C
#define USB1_UTMIP_DEBOUNCE_CFG0_RESET  0xFFFFFFFF
typedef union usb1_utmip_debounce_cfg0_u {
    struct {
        unsigned int utmip_bias_debounce_a:16; /* simulation value -- Used for interrupts */
        unsigned int utmip_bias_debounce_b:16; /* simulation value -- Used for interrupts */
    };

    uint32_t reg32;
} usb1_utmip_debounce_cfg0_t;

#define USB1_UTMIP_BAT_CHRG_CFG0_OFFSET 0x830
#define USB1_UTMIP_BAT_CHRG_CFG0_RESET  0x00000000
typedef union usb1_utmip_bat_chrg_cfg0_u {
    struct {
        unsigned int utmip_pd_chrg:1;       /* Power down charger circuit */
        unsigned int utmip_op_sink_en:1;
        unsigned int utmip_on_sink_en:1;
        unsigned int utmip_op_src_en:1;
        unsigned int utmip_on_src_en:1;
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} usb1_utmip_bat_chrg_cfg0_t;

#define USB1_UTMIP_SPARE_CFG0_OFFSET 0x834
#define USB1_UTMIP_SPARE_CFG0_RESET  0xFFFF0000
typedef union usb1_utmip_spare_cfg0_u {
    struct {
        unsigned int utmip_spare:32;        /* Spare register bits 0: HS_RX_IPG_ERROR_ENABLE 1: HS_RX_FLUSH_ALAP. Flush as late as possible 2: HS_RX_LATE_SQUELCH. Delay Squelch by 1 CLK480 cycle. 3: FUSE_SETUP_SEL. Select between regular CFG value and JTAG values for UX_SETUP 31 to 4: Reserved */
    };

    uint32_t reg32;
} usb1_utmip_spare_cfg0_t;

#define USB1_UTMIP_XCVR_CFG1_OFFSET 0x838
#define USB1_UTMIP_XCVR_CFG1_RESET  0x0000822A
typedef union usb1_utmip_xcvr_cfg1_u {
    struct {
        unsigned int utmip_force_pddisc_powerdown:1; /* Force PDDISC input into power down. (Overrides FORCE_PDDISC_POWERUP.) */
        unsigned int utmip_force_pddisc_powerup:1; /* Force PDDISC input into power up. */
        unsigned int utmip_force_pdchrp_powerdown:1; /* Force PDCHRP input input into power down. (Overrides FORCE_PDCHRP_POWERUP.) */
        unsigned int utmip_force_pdchrp_powerup:1; /* Force PDCHRP input into power up. */
        unsigned int utmip_force_pddr_powerdown:1; /* Force PDDR input input into power down. (Overrides FORCE_PDDR_POWERUP.) */
        unsigned int utmip_force_pddr_powerup:1; /* Force PDDR input into power up. */
        unsigned int utmip_tctrl_sw_val:5;  /* Encoded value to use on TCTRL when software override is enabled, 0 to 16 only */
        unsigned int utmip_tctrl_sw_set:1;  /* Use a software override on TCTRL instead of automatic bias control */
        unsigned int utmip_rctrl_sw_val:5;  /* Encoded value to use on RCTRL when software override is enabled, 0 to 16 only */
        unsigned int utmip_rctrl_sw_set:1;  /* Use a software override on RCTRL instead of automatic bias control */
        unsigned int utmip_xcvr_term_range_adj:4; /* Range adjusment on terminations. */
        unsigned int utmip_xcvr_spare:2;    /* Spare bits for usb transceiver pad ECO. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb1_utmip_xcvr_cfg1_t;

#define USB1_UTMIP_BIAS_CFG1_OFFSET 0x83C
#define USB1_UTMIP_BIAS_CFG1_RESET  0x0000002A
typedef union usb1_utmip_bias_cfg1_u {
    struct {
        unsigned int utmip_force_pdtrk_powerdown:1; /* Force PDTRK input into power down. (Overrides FORCE_PDTRK_POWERUP.) */
        unsigned int utmip_force_pdtrk_powerup:1; /* Force PDTRK input into power up. */
        unsigned int utmip_vbus_wakeup_powerdown:1; /* Force VBUS_WAKEUP input into power down. */
        unsigned int utmip_bias_pdtrk_count:5; /* Control the BIAS cell power down lag. The lag should be 20us. For a Xtal clock of 13MHz it should be set a 5.  */
        unsigned int utmip_bias_debounce_timescale:6; /* Debouncer time scaling, factor-1 to slow down debouncing by. So 0 is 1, 1 is 2, etc. */
        unsigned int undefined_bits_14_31:18;
    };

    uint32_t reg32;
} usb1_utmip_bias_cfg1_t;

#define USB1_UTMIP_BIAS_STS0_OFFSET 0x840
#define USB1_UTMIP_BIAS_STS0_RESET  0x00000000
typedef union usb1_utmip_bias_sts0_u {
    struct {
        unsigned int utmip_rctrl:16;        /* Thermal encoding output from USB bias pad.  */
        unsigned int utmip_tctrl:16;        /* Thermal encoding output from USB bias pad.  */
    };

    uint32_t reg32;
} usb1_utmip_bias_sts0_t;

#define USB2_QH_USB2D_QH_EP_0_OUT_OFFSET 0x1000
#define USB2_QH_USB2D_QH_EP_0_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_0_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 0  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 0. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_0_out_t;

#define USB2_QH_USB2D_QH_EP_0_IN_OFFSET 0x1040
#define USB2_QH_USB2D_QH_EP_0_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_0_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 0.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 0. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_0_in_t;

#define USB2_QH_USB2D_QH_EP_1_OUT_OFFSET 0x1080
#define USB2_QH_USB2D_QH_EP_1_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_1_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 1  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 1. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_1_out_t;

#define USB2_QH_USB2D_QH_EP_1_IN_OFFSET 0x10C0
#define USB2_QH_USB2D_QH_EP_1_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_1_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 1.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 1. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_1_in_t;

#define USB2_QH_USB2D_QH_EP_2_OUT_OFFSET 0x1100
#define USB2_QH_USB2D_QH_EP_2_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_2_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 2  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 2. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_2_out_t;

#define USB2_QH_USB2D_QH_EP_2_IN_OFFSET 0x1140
#define USB2_QH_USB2D_QH_EP_2_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_2_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 2.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 2. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_2_in_t;

#define USB2_QH_USB2D_QH_EP_3_OUT_OFFSET 0x1180
#define USB2_QH_USB2D_QH_EP_3_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_3_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 3  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 3. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_3_out_t;

#define USB2_QH_USB2D_QH_EP_3_IN_OFFSET 0x11C0
#define USB2_QH_USB2D_QH_EP_3_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_3_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 3.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 3. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_3_in_t;

#define USB2_QH_USB2D_QH_EP_4_OUT_OFFSET 0x1200
#define USB2_QH_USB2D_QH_EP_4_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_4_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 4  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 4. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_4_out_t;

#define USB2_QH_USB2D_QH_EP_4_IN_OFFSET 0x1240
#define USB2_QH_USB2D_QH_EP_4_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_4_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 4.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 4. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_4_in_t;

#define USB2_QH_USB2D_QH_EP_5_OUT_OFFSET 0x1280
#define USB2_QH_USB2D_QH_EP_5_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_5_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 5  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 5. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_5_out_t;

#define USB2_QH_USB2D_QH_EP_5_IN_OFFSET 0x12C0
#define USB2_QH_USB2D_QH_EP_5_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_5_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 5.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 5. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_5_in_t;

#define USB2_QH_USB2D_QH_EP_6_OUT_OFFSET 0x1300
#define USB2_QH_USB2D_QH_EP_6_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_6_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 6  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 6. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_6_out_t;

#define USB2_QH_USB2D_QH_EP_6_IN_OFFSET 0x1340
#define USB2_QH_USB2D_QH_EP_6_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_6_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 6.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 6. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_6_in_t;

#define USB2_QH_USB2D_QH_EP_7_OUT_OFFSET 0x1380
#define USB2_QH_USB2D_QH_EP_7_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_7_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 7  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 7. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_7_out_t;

#define USB2_QH_USB2D_QH_EP_7_IN_OFFSET 0x13C0
#define USB2_QH_USB2D_QH_EP_7_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_7_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 7.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 7. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_7_in_t;

#define USB2_QH_USB2D_QH_EP_8_OUT_OFFSET 0x1400
#define USB2_QH_USB2D_QH_EP_8_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_8_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 8  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 8. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_8_out_t;

#define USB2_QH_USB2D_QH_EP_8_IN_OFFSET 0x1440
#define USB2_QH_USB2D_QH_EP_8_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_8_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 8.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 8. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_8_in_t;

#define USB2_QH_USB2D_QH_EP_9_OUT_OFFSET 0x1480
#define USB2_QH_USB2D_QH_EP_9_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_9_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 9  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 9. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_9_out_t;

#define USB2_QH_USB2D_QH_EP_9_IN_OFFSET 0x14C0
#define USB2_QH_USB2D_QH_EP_9_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_9_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 9.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 9. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_9_in_t;

#define USB2_QH_USB2D_QH_EP_10_OUT_OFFSET 0x1500
#define USB2_QH_USB2D_QH_EP_10_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_10_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 10  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 10. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_10_out_t;

#define USB2_QH_USB2D_QH_EP_10_IN_OFFSET 0x1540
#define USB2_QH_USB2D_QH_EP_10_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_10_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 10.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 10. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_10_in_t;

#define USB2_QH_USB2D_QH_EP_11_OUT_OFFSET 0x1580
#define USB2_QH_USB2D_QH_EP_11_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_11_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 11  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 11. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_11_out_t;

#define USB2_QH_USB2D_QH_EP_11_IN_OFFSET 0x15C0
#define USB2_QH_USB2D_QH_EP_11_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_11_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 11.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 11. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_11_in_t;

#define USB2_QH_USB2D_QH_EP_12_OUT_OFFSET 0x1600
#define USB2_QH_USB2D_QH_EP_12_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_12_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 12  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 12. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_12_out_t;

#define USB2_QH_USB2D_QH_EP_12_IN_OFFSET 0x1640
#define USB2_QH_USB2D_QH_EP_12_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_12_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 12.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 12. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_12_in_t;

#define USB2_QH_USB2D_QH_EP_13_OUT_OFFSET 0x1680
#define USB2_QH_USB2D_QH_EP_13_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_13_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 13  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 13. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_13_out_t;

#define USB2_QH_USB2D_QH_EP_13_IN_OFFSET 0x16C0
#define USB2_QH_USB2D_QH_EP_13_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_13_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 13.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 13. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_13_in_t;

#define USB2_QH_USB2D_QH_EP_14_OUT_OFFSET 0x1700
#define USB2_QH_USB2D_QH_EP_14_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_14_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 14  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 14. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_14_out_t;

#define USB2_QH_USB2D_QH_EP_14_IN_OFFSET 0x1740
#define USB2_QH_USB2D_QH_EP_14_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_14_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 14.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 14. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_14_in_t;

#define USB2_QH_USB2D_QH_EP_15_OUT_OFFSET 0x1780
#define USB2_QH_USB2D_QH_EP_15_OUT_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_15_out_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for OUT endpoint 15  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for OUT endpoint 15. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_15_out_t;

#define USB2_QH_USB2D_QH_EP_15_IN_OFFSET 0x17C0
#define USB2_QH_USB2D_QH_EP_15_IN_RESET  0x00000000
typedef union usb2_qh_usb2d_qh_ep_15_in_u {
    struct {
        unsigned int usb2d_qh:32;           /* Queue Head for IN endpoint 15.  This is used to store a local Queue Head data structure for either device mode or host mode. In device mode, it holds the Queue Head for IN endpoint 15. */
    };

    uint32_t reg32;
} usb2_qh_usb2d_qh_ep_15_in_t;

#define USB2_RX_MEM_USB2_RX_MEM_OFFSET 0x1800
#define USB2_RX_MEM_USB2_RX_MEM_RESET  0x00000000
typedef union usb2_rx_mem_usb2_rx_mem_u {
    struct {
        unsigned int usb2_rx_mem:32;        /* RX buffer memory */
    };

    uint32_t reg32;
} usb2_rx_mem_usb2_rx_mem_t;

#define USB2_TX_MEM_USB2_TX_MEM_OFFSET 0x2000
#define USB2_TX_MEM_USB2_TX_MEM_RESET  0x00000000
typedef union usb2_tx_mem_usb2_tx_mem_u {
    struct {
        unsigned int usb2_tx_mem:32;        /* TX buffer memory */
    };

    uint32_t reg32;
} usb2_tx_mem_usb2_tx_mem_t;

#define USB2_CONTROLLER_1_USB2D_ID_OFFSET 0x0
#define USB2_CONTROLLER_1_USB2D_ID_RESET  0x0033FA05
#define USB2_CONTROLLER_1_USB2D_ID_WRMASK 0xFF000000
typedef union usb2_controller_1_usb2d_id_u {
    struct {
        unsigned int id:8;                  /* Configuration number. This field is set to 0x05 */
        unsigned int nid:8;                 /* Ones complement version of ID. This field is set  to 0xFA. */
        unsigned int revision:8;            /* Revision number of the USB controller. This is set  to 0x33. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_id_t;

#define USB2_CONTROLLER_1_USB2D_HW_GENERAL_OFFSET 0x4
#define USB2_CONTROLLER_1_USB2D_HW_GENERAL_RESET  0x00000035
#define USB2_CONTROLLER_1_USB2D_HW_GENERAL_WRMASK 0xFFFFFE08
typedef union usb2_controller_1_usb2d_hw_general_u {
    struct {
        unsigned int rt:1;                  /* VUSB_HS_RESET_TYPE : set to 1 = asynchronous reset */
        unsigned int clkc:2;                /* VUSB_HS_CLOCK_CONFIGURATION : Clock configuration  2 selected */
        unsigned int undefined_bit_3:1;
        unsigned int phyw:2;                /* VUSB_HS_PHY16_8 : Width of the UTMI parallel  interface. Set to 3 : 16-bit UTMI parallel interface software programmable to  8-bit */
        unsigned int phym:3;                /* VUSB_HS_PHY_MODE : set to 0 for UTMI PHY */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_hw_general_t;

#define USB2_CONTROLLER_1_USB2D_HW_HOST_OFFSET 0x8
#define USB2_CONTROLLER_1_USB2D_HW_HOST_RESET  0x00000001
#define USB2_CONTROLLER_1_USB2D_HW_HOST_WRMASK 0xFFFFFFF0
typedef union usb2_controller_1_usb2d_hw_host_u {
    struct {
        unsigned int hc:1;                  /* VUSB_HS_HOST: Indicates support for host mode. Set  to 1. */
        unsigned int nport:3;               /* VUSB_HS_NUM_PORT-1: This host controller has only  1 port. So this field will always be 0. */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_hw_host_t;

#define USB2_CONTROLLER_1_USB2D_HW_DEVICE_OFFSET 0xC
#define USB2_CONTROLLER_1_USB2D_HW_DEVICE_RESET  0x00000021
#define USB2_CONTROLLER_1_USB2D_HW_DEVICE_WRMASK 0xFFFFFFC0
typedef union usb2_controller_1_usb2d_hw_device_u {
    struct {
        unsigned int dc:1;                  /* Device capable: Set to 1 indicating support for device mode. */
        unsigned int devep:5;               /* VUSB_HS_DV_EP: No. of endpoints supported by this device controller. Set to 16. This includes control endpoint 0. */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_hw_device_t;

#define USB2_CONTROLLER_1_USB2D_HW_TXBUF_OFFSET 0x10
#define USB2_CONTROLLER_1_USB2D_HW_TXBUF_RESET  0x00070B08
#define USB2_CONTROLLER_1_USB2D_HW_TXBUF_WRMASK 0xFF000000
typedef union usb2_controller_1_usb2d_hw_txbuf_u {
    struct {
        unsigned int tcburst:8;             /* VUSB_HS_TX_BURST: Maximum burst size supported by the transmit endpoints for data transfers. Set to 8. */
        unsigned int txadd:8;               /* VUSB_HS_TX_ADD: Total no. of address bits for the transmit buffer. Set to 11. The total depth of the transmit buffer is 2048 words. */
        unsigned int txchanadd:8;           /* VUSB_HS_TX_CHAN_ADD: Total no. of address bits for the transmit buffer of each transmit endpoint. Set to 7. Each transmit buffer is 128 words deep. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_hw_txbuf_t;

#define USB2_CONTROLLER_1_USB2D_HW_RXBUF_OFFSET 0x14
#define USB2_CONTROLLER_1_USB2D_HW_RXBUF_RESET  0x00000708
#define USB2_CONTROLLER_1_USB2D_HW_RXBUF_WRMASK 0xFFFF0000
typedef union usb2_controller_1_usb2d_hw_rxbuf_u {
    struct {
        unsigned int rxburst:8;             /* VUSB_HS_RX_BURST: Maximum burst size supported by the receive endpoints for data transfers. Set to 8. */
        unsigned int rxadd:8;               /* VUSB_HS_RX_ADD: Total no. of address bits for the receive buffer. Set to 7. The total depth of the receive buffer is 128 words */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_hw_rxbuf_t;

#define USB2_CONTROLLER_1_USB2D_CAPLENGTH_OFFSET 0x100
#define USB2_CONTROLLER_1_USB2D_CAPLENGTH_RESET  0x00000040
#define USB2_CONTROLLER_1_USB2D_CAPLENGTH_WRMASK 0xFFFFFF00
typedef union usb2_controller_1_usb2d_caplength_u {
    struct {
        unsigned int caplength:8;           /* Indicates which offset to add to the register base address at the beginning of the Operational Register. Set to 0x40. */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_caplength_t;

#define USB2_CONTROLLER_1_USB2D_HCIVERSON_OFFSET 0x102
#define USB2_CONTROLLER_1_USB2D_HCIVERSON_RESET  0x00000100
#define USB2_CONTROLLER_1_USB2D_HCIVERSON_WRMASK 0xFFFF0000
typedef union usb2_controller_1_usb2d_hciverson_u {
    struct {
        unsigned int hciversion:16;         /* Contains a BCD encoding of the EHCI revision number supported by this host controller. The most significant byte of this register represents a major revision and the least significant byte is the minor revision. This host controller supports EHCI revision 1.00. */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_hciverson_t;

#define USB2_CONTROLLER_1_USB2D_HCSPARAMS_OFFSET 0x104
#define USB2_CONTROLLER_1_USB2D_HCSPARAMS_RESET  0x01100011
#define USB2_CONTROLLER_1_USB2D_HCSPARAMS_WRMASK 0xF00F00E0
typedef union usb2_controller_1_usb2d_hcsparams_u {
    struct {
        unsigned int n_ports:4;             /* Number of downstream ports. This field specifies the number of physical downstream ports implemented on this host controller. This field is fixed to 1, since this host controller only supports 1 port. */
        unsigned int ppc:1;                 /* Port Power Control: indicates whether the host controller implementation includes port power control.  1 = Ports have port power switches         0= Ports do not have port power switches. This field affects the functionality of the port Power field in each port status and control register. This field is set to 1. */
        unsigned int undefined_bits_5_7:3;
        unsigned int n_pcc:4;               /* Number of Ports per Companion Controller: indicates the number of ports supported per internal companion controller. This field is set to 0. */
        unsigned int n_cc:4;                /* Number of Companion Controller: indicates the number of companion controllers. This field is set to 0. */
        unsigned int undefined_bits_16_19:4;
        unsigned int n_ptt:4;               /* Number of Ports per Transaction Translator: indicates the number of ports assigned to each transaction translator within the USB2.0 host controller. Field always equals N_PORTS. This is a non-EHCI field to support embedded TT. */
        unsigned int n_tt:4;                /* Number of Transaction Translators: indicates the number of embedded transaction translators associated with the USB2.0 host controller. This field is always set to 1 indicating only 1 embedded TT is implemented in this implementation. This is a non-EHCI field to support embedded TT. */
        unsigned int undefined_bits_28_31:4;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_hcsparams_t;

#define USB2_CONTROLLER_1_USB2D_HCCPARAMS_OFFSET 0x108
#define USB2_CONTROLLER_1_USB2D_HCCPARAMS_RESET  0x00000006
#define USB2_CONTROLLER_1_USB2D_HCCPARAMS_WRMASK 0xFFFF0009
typedef union usb2_controller_1_usb2d_hccparams_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int pfl:1;                 /* Programmable Frame List Flag.  0 = System software must use a frame list length of 1024 elements with this host controller. The USBCMD register Frame List Size field is a read-only register and must be set to zero.  1 = System software can specify and use a smaller frame list and configure the host controller via the USBCMD register Frame List Size field.  The frame list must always be aligned on a 4K-page boundary.  This requirement ensures that the frame list is always physically contiguous.  This field will always be "1".  */
        unsigned int asp:1;                 /* Asynchronous Schedule Park Capability.  1 = (Default) the host controller supports the park feature for high-speed queue heads in the Asynchronous Schedule. The feature can be disabled or enabled and set to a specific level by using the Asynchronous Schedule Park Mode Enable and Asynchronous Schedule Park Mode Count fields in the USBCMD register.  This field is always 1. */
        unsigned int undefined_bit_3:1;
        unsigned int ist:4;                 /* Isochronous Scheduling Threshold. This field indicates, relative to the current position of the executing host controller, where software can reliably update the isochronous schedule. When bit [7] is zero, the value of the least significant 3 bits indicates the number of micro-frames a host controller can hold a set of isochronous data structures  (one or more) before flushing the state. When bit [7] is a one, then host software assumes the host controller may cache an isochronous data structure for an entire frame. This field will always be "0".  */
        unsigned int eecp:8;                /* EHCI Extended Capabilities Pointer: indicates a capabilities list exists. A value of 00h indicates no extended capabilities are implemented. For this implementation this field is always "0".  */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_hccparams_t;

#define USB2_CONTROLLER_1_USB2D_DCIVERSION_OFFSET 0x120
#define USB2_CONTROLLER_1_USB2D_DCIVERSION_RESET  0x00000001
#define USB2_CONTROLLER_1_USB2D_DCIVERSION_WRMASK 0xFFFF0000
typedef union usb2_controller_1_usb2d_dciversion_u {
    struct {
        unsigned int dciversion:16;         /* The device controller interface conforms to the two-byte BCD encoding of the interface version number contained in this  register.  */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_dciversion_t;

#define USB2_CONTROLLER_1_USB2D_DCCPARAMS_OFFSET 0x124
#define USB2_CONTROLLER_1_USB2D_DCCPARAMS_RESET  0x00000190
#define USB2_CONTROLLER_1_USB2D_DCCPARAMS_WRMASK 0xFFFFFE60
typedef union usb2_controller_1_usb2d_dccparams_u {
    struct {
        unsigned int den:5;                 /* Device Endpoint Number: Number of endpoints built into the device controller. This is set to 16. */
        unsigned int undefined_bits_5_6:2;
        unsigned int dc:1;                  /* Device Capable: 1 = Controller is capable of operating as USB 2.0 device. This field is set to 1. */
        unsigned int hc:1;                  /* Host Capable: 1 = This controller is capable of operating as an EHCI compatible USB 2 0 host controller operating as an EHCI  compatible USB 2.0 host controller. This field is set to 1. */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_dccparams_t;

#define USB2_CONTROLLER_1_USB2D_USBCMD_OFFSET 0x140
#define USB2_CONTROLLER_1_USB2D_USBCMD_RESET  0x00080B00
#define USB2_CONTROLLER_1_USB2D_USBCMD_WRMASK 0xFFFFFF7F
typedef union usb2_controller_1_usb2d_usbcmd_u {
    struct {
        unsigned int rs:1;                  /* Run/Stop:  Host Controller:  When set to a 1, the Host Controller proceeds with the execution of the schedule.   The Host Controller continues execution as long as this bit is set to a one.  When this bit is set to 0, the Host Controller completes the current transaction on the USB and then halts.  The HCHalted bit in the status register indicates when the Host Controller has finished the transaction and has entered the stopped state.  Software should not write a one to this field unless the host controller is in the Halted state (i.e. HCHalted in the USBSTS register is a one).  Device Controller:  Writing a one to this bit will cause the device  controller to enable a pull-up on D+ and initiate an attach event. This  control bit is not directly connected to the pull-up enable, as the pull-up  will become disabled upon transitioning into high-speed mode. Software should  use this bit to prevent an attach event before the device controller has been  properly initialized. Writing a 0 to this will cause a detach event.  */
        unsigned int rst:1;                 /* Controller Reset. Software uses this bit to reset the controller. This bit is set to zero by the Host/Device Controller when the reset process is complete. Software cannot terminate the reset process early by writing a zero to this register.  Host Controller:  When software writes a one to this bit, the Host Controller resets its internal pipelines, timers, counters, state machines etc. to their initial value. Any transaction currently in progress on USB is immediately terminated. A USB reset is not driven on downstream ports. Software should not set this bit to a one when the HCHalted bit in the USBSTS register is a zero.  Attempting to reset an actively running host controller results in undefined behavior.    Device Controller:  When software writes a one to this bit, the Device  Controller resets its internal pipelines, timers, counters, state machines  etc. to their initial value. Any transaction currently in progress on USB is  immediately terminated. Writing a one to this bit in device mode is not  recommended.  */
        unsigned int fs1_fs0:2;             /* Frame List Size . (Read/Write).  000 = Default This field is Read/Write only if Programmable Frame List Flag in the HCCPARAMS registers is set to one.  Hence this field is Read/Write for this implementation. This field specifies the size of the frame list that controls which bits in the Frame Index Register should be used for the Frame List Current index.  Note that this field is made up from USBCMD bits 15, 3 and 2.  000 = 1024 elements (4096 bytes) Default value  001 = 512 elements (2048 bytes)  010 = 256 elements (1024 bytes)   011 = 128 elements (512 bytes)  100 = 64 elements (256 bytes)  101 = 32 elements (128 bytes)  110 = 16 elements (64 bytes)  111 = 8 elements (32 bytes)        Only the host controller uses this field.  */
        unsigned int pse:1;                 /* Periodic Schedule Enable.This bit controls whether the host controller skips processing the Periodic Schedule.  0 = Do not process the Periodic Schedule  1 = Use the PERIODICLISTBASE register to access the Periodic  Schedule.  Only the host controller uses this bit.  */
        unsigned int ase:1;                 /* Asynchronous Schedule Enable. This bit controls whether the host controller skips processing the Asynchronous Schedule.  0 = Do not process the Asynchronous Schedule.  1 = Use the ASYNCLISTADDR register to access the  Asynchronous Schedule.  Only the host controller uses this bit.  */
        unsigned int iaa:1;                 /* Interrupt on Async Advance Doorbell. When the host controller has evicted all  appropriate cached schedule states, it sets the Interrupt on Async Advance  status bit in the USBSTS register. If the Interrupt on Sync Advance Enable  bit in the USBINTR register is one, then the host controller will assert an  interrupt at the next interrupt threshold. The host controller sets this bit  to zero after it has set the Interrupt on Sync Advance status bit in the  USBSTS register to one. Software should not write a one to this bit when the  asynchronous schedule is inactive. Doing so will yield undefined results. This  bit is only used in host mode. Writing a one to this bit when device mode is  selected will have undefined results.  */
        unsigned int lr:1;                  /* Light Host/Device Controller Reset (OPTIONAL) .  Read Only. Not Implemented. This field will always be "0".  */
        unsigned int asp1_asp0:2;           /* Asynchronous Schedule Park Mode Count (OPTIONAL) Read/Write.  If the Asynchronous Park Capability bit in the HCCPARAMS register is a one,  then this field defaults to 3h and is R/W. Otherwise it defaults to zero and  is RO. It contains a count of the number of successive transactions the host  controller is allowed to execute from a high-speed queue head on the  Asynchronous schedule before continuing traversal of the Asynchronous  schedule. Valid values are 1h to 3h. Software must not write a zero to this  bit when Park Mode Enable is a one as this will result in undefined behavior.  This field is set to 3h in this implementation and is Read/Write capable.  */
        unsigned int undefined_bit_10:1;
        unsigned int aspe:1;                /* Asynchronous Schedule Park mode Enable. Software uses this bit to enable or disable Park mode. When this bit is one, Park mode is enabled. When this bit is a zero, Park mode is disabled.  This field is set to "1" in this  implementation.  */
        unsigned int undefined_bit_12:1;
        unsigned int sutw:1;                /* Setup Tripwire. This bit is used as a semaphore when the 8 bytes  of setup data read extracted by the firmware. If the setup lockout mode is  off, then there exists a hazard when new setup data arrives and firmware is  copying setup data from the QH for a previous setup packet. This bit is set  and cleared by software and will be cleared by hardware when a hazard exists. */
        unsigned int atdtw:1;               /* Add DTD Tripwire. This bit is used as a semaphore when a dTD is  added to an active (primed) endpoint. This bit is set and cleared by software  and will be cleared by hardware when a hazard exists such that adding a dTD  to a primed endpoint may go unnoticed. */
        unsigned int fs2:1;                 /* Bit 2 of Frame List Size. */
        unsigned int itc:8;                 /* Interrupt Threshold Control .Read/Write. Default 08h. The system software uses this field to set the maximum rate at which the host/device controller will issue interrupts. ITC contains the maximum interrupt interval measured in micro-frames. Valid values are shown below.   Value          Maximum Interrupt Interval  00h              Immediate (no threshold)  01h                1 micro-frame  02h           2 micro-frames  04h          4 micro-frames  08h          8 micro-frames  10h          16 micro-frames  20h         32 micro-frames  40h         64 micro-frames */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_usbcmd_t;

#define USB2_CONTROLLER_1_USB2D_USBSTS_OFFSET 0x144
#define USB2_CONTROLLER_1_USB2D_USBSTS_RESET  0x00001000
#define USB2_CONTROLLER_1_USB2D_USBSTS_WRMASK 0xFFFEDFEF
typedef union usb2_controller_1_usb2d_usbsts_u {
    struct {
        unsigned int ui:1;                  /* USB Interrupt. This bit is set by the Host/Device Controller when  the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) as an interrupt on complete (IOC) bit set. This bit  is also set by the Host/Device Controller when a short packet is detected. A  short packet is when the actual number of bytes received was less than the  expected number of bytes.  */
        unsigned int uei:1;                 /* USB Error Interrupt.  This bit gets set by the Host/Device controller  when completion of a USB transaction results in an error condition. This bit  is set along with the USBINT bit, if the TD on which the error interrupt occurred also ad its interrupt on complete (IOC) bit set.  */
        unsigned int pci:1;                 /* Port Change Detect.  The Host Controller sets this bit to a 1 when on any port a Connect Status occurs, a Port Enable/Disable Change occurs, or the  Force Port Resume bit is set as the result of a J-K transition on the suspended port. The Device Controller sets this bit to a one when the port  controller enters the full or high-speed operational state. When the port  controller exits the full or high-speed operational states due to Reset or  Suspend events, the notification mechanisms are the USB Reset Received bit  and the DCSuspend bits respectively.  This bit is not EHCI compatible.  */
        unsigned int fri:1;                 /* Frame List Rollover.  The Host Controller sets this bit to a 1 when the Frame List Index rolls over from its maximum value to 0. The exact  value at which the rollover occurs depends on the frame list size. For  example. If the frame list size (as programmed in the Frame List Size field  of the USBCMD register) is 1024, the Frame Index Register rolls over every  time FRINDEX [1 3] toggles. Similarly, if the size is 512, the Host  Controller sets this bit to a 1 every time FHINDEX [12] toggles.  Only used  by the host controller.  */
        unsigned int sei:1;                 /* System Error.  This bit is not used in this  implementation and will always be set to "0".  */
        unsigned int aai:1;                 /* Interrupt and Asynchronous Advance.  System software can force the host controller to  issue an interrupt the next time the host controller advances the  asynchronous schedule by writing a one to the Interrupt on Async Advance  Doorbell bit in the USBCMD register. This status bit indicates the assertion  of that interrupt source. Only used by the host controller */
        unsigned int uri:1;                 /* USB Reset Received.  When the device controller detects a USB Reset  and  enters the default state, this bit is set to a 1. Software can write a 1 to  this bit to clear the USB Reset Received status bit.  Only used by the device  controller.  */
        unsigned int sri:1;                 /* SOF Received. When the device controller detects a Start Of (micro) Frame, this bit will be set to a one.  When a SOF is extremely late, the device controller will automatically  set this bit to indicate that an SOF was expected.   Therefore, this bit will be set roughly every 1ms in device FS mode and every 125us in HS mode and will be synchronized to the actual SOF that  is received. Since device controller is initialized to FS before connect,  this bit Will be set at an interval of 1ms during the prelude to the connect and chirp.  In host mode, this bit will be set every 125us and can be used by host controller driver as a time base.  Software writes a 1 to this bit to clear it. This  is a non-EHCI status bit.  */
        unsigned int sli:1;                 /* DCSuspend. When a device controller enters a suspend state from an active state, this bit will be set to a 1.  The device controller  clears the bit upon exiting from a suspend state. Only used by the device  controller.  */
        unsigned int undefined_bit_9:1;
        unsigned int ulpi_int:1;            /* ULPI Interrupt. This bit is set whenever an interrupt is received from ULPI PHY. Software writes 1 to clear it. */
        unsigned int undefined_bit_11:1;
        unsigned int hch:1;                 /* HCHalted. 1 = Default.  This bit is a zero  whenever the Run/Stop bit is a one.  The Host Controller sets this bit to one  after it has stopped  executing because of the Run/Stop bit being set to 0,  either by software or by the Host Controller hardware (e.g. internal error).  Only  used by the host controller.  */
        unsigned int rcl:1;                 /* Reclamation.  This is a read-only status bit used to detect an empty asynchronous schedule. Only used by the host controller.  */
        unsigned int ps:1;                  /* Periodic Schedule Status. This bit reports the current real status of the Periodic Schedule.  When set to zero the periodic schedule is disabled, and if set to one the status is enabled. The Host Controller is not required to immediately disable or enable the Periodic Schedule when software transitions the Periodic Schedule Enable bit in the USBCMD register.   If PS = PSE then: 1 = Periodic Schedule is enabled or 0 = Periodic Schedule is disabled Only used by the host controller.  */
        unsigned int as:1;                  /* Asynchronous Schedule Status.  This bit reports the current real status of the Asynchronous Schedule.   When set to zero the asynchronous schedule status is disabled and  if set to one the status is enabled.  The Host Controller is not required to  immediately disable or enable the Asynchronous Schedule when software transitions the Asynchronous Schedule Enable bit in the USBCMD register.   If AS = ASE:  1= Enable Asynchronous Schedule 0= Disable Asynchronous Schedule Only used by the host controller.  */
        unsigned int naki:1;                /* NAK Interrupt Bit  Read Only. This bit is readonly. It is set by hardware when for a particular endpoint both the TX/RX Endpoint NAK bit and the corresponding TX/RX Endpoint NAK Enable bit are set. This bit is automatically cleared by hardware when the all the enabled TX/RX Endpoint NAK bits are cleared. */
        unsigned int undefined_bit_17:1;
        unsigned int uai:1;                 /* USB Host Asynchronous Interrupt (USBHSTASYNCINT)  R/WC. This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set AND the TD was from the asynchronous schedule. This bit is also set by the Host when a short packet is detected AND the packet is on the asynchronous schedule. A short packet is when the actual number of bytes received was less than the expected number of bytes. This bit is not used by the device controller and will always be zero. */
        unsigned int upa:1;                 /* USB Host Periodic Interrupt (USBHSTPERINT)  R/WC. This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set and the TD was from the periodic schedule. This bit is also set by the Host Controller when a short packet is detected AND the packet is on the periodic schedule. A short packet is when the actual number of bytes received was less than the expected number of bytes. This bit is not used by the device controller and will always be zero. */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_usbsts_t;

#define USB2_CONTROLLER_1_USB2D_USBINTR_OFFSET 0x148
#define USB2_CONTROLLER_1_USB2D_USBINTR_RESET  0x00000000
typedef union usb2_controller_1_usb2d_usbintr_u {
    struct {
        unsigned int ue:1;                  /* USB Interrupt Enable. 1 = Host/device issues an interrupt at the next  interrupt threshold if the USBINT bit in USBSTS = 1.  The interrupt is  acknowledged by software clearing the USBINT bit. */
        unsigned int uee:1;                 /* USB Error Interrupt Enable. 1 = Host controller issues an interrupt at the  next interrupt threshold if the USBERRINT bit in USBSTS = 1.  The interrupt is  acknowledged by software clearing the USBERRINT bit in the USBSTS register.  */
        unsigned int pce:1;                 /* Port Change Detect Enable. 1 = Host/device controller issues an interrupt if  Port Change Detect bit in USBSTS register = 1.  The interrupt is acknowledged  by software clearing the Port Change Detect bit. */
        unsigned int fre:1;                 /* Frame List Rollover Enable. 1 = Host controller issues an interrupt if Frame  List Rollover bit in the USBSTS register = 1. The interrupt is acknowledged  by software clearing the Frame List Rollover bit. Only used by the host  controller.  */
        unsigned int see:1;                 /* System Error Enable. 1 = Host/device controller issues an interrupt if  the System Error bit in USBSTS register = 1. The interrupt is acknowledged by  software clearing the System Error bit.  */
        unsigned int aae:1;                 /* Interrupt on Asynchronous Advance Enable. 1 = the host controller issues an interrupt at the  next interrupt threshold if Interrupt on Async Advance bit in USBSTS register  = 1.  The interrupt is acknowledged by software clearing the Interrupt on  Async Advance bit. Only used by the host controller.  */
        unsigned int ure:1;                 /* USB Reset Enable.1 = Device controller issues an interrupt if USB Reset Received bit in USBSTS register  = 1  The interrupt is acknowledged by software clearing  the USB Reset Received bit. Only used by the device controller.  */
        unsigned int sre:1;                 /* SOF Received Enable. 1 = Device controller issues an interrupt if SOF Received bit in USBSTS register = 1. The interrupt is acknowledged by software clearing  the SOF Received bit.  */
        unsigned int sle:1;                 /* Sleep Enable. 1 = Device controller issues an interrupt if  DCSuspend bit in USBSTS register transitions.  The interrupt is acknowledged by SW by writing a 1 to the DCSuspend bit. Only used by the device controller.  */
        unsigned int undefined_bit_9:1;
        unsigned int ulpie:1;               /* ULPI Interrupt Enable. 1 = USB controller issues an interrupt if ULPI_INT bit in USBSTS register transitions. The interrupt is acknowledged by SW by writing a 1 to the ULPI_INT bit. */
        unsigned int undefined_bits_11_15:5;
        unsigned int nake:1;                /* NAK Interrupt Enable. 1 = USB controller issues an interrupt if NAKI bit in USBSTS register transitions. */
        unsigned int undefined_bit_17:1;
        unsigned int uaie:1;                /* UAIE Interrupt Enable. 1 = USB controller issues an interrupt if UAI bit in USBSTS register transitions. */
        unsigned int upie:1;                /* UPIE Interrupt Enable. 1 = USB controller issues an interrupt if UPA bit in USBSTS register transitions. */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_usbintr_t;

#define USB2_CONTROLLER_1_USB2D_FRINDEX_OFFSET 0x14C
#define USB2_CONTROLLER_1_USB2D_FRINDEX_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_FRINDEX_WRMASK 0xFFFFC000
typedef union usb2_controller_1_usb2d_frindex_u {
    struct {
        unsigned int frindex:14;            /* Frame Index.   The value in this register increments at the end of each time frame (micro-frame).  Bits [N: 3] are used for the Frame List current index. Each location of the frame list is accessed 8 times (frames or micro-frames) before moving to the next index.   The following illustrates values of N based on the value of the Frame List Size field in the USBCMD register, when used in host mode.  USBCMD          [Frame List Size] Number        Elements N    000b                   (1024)                  12    001b                   (512)                   11    010b                   (256)                   10    011b                   (128)                   9    100b            (64)                    8    101b            (32)                    7    110b            (16)                    6    111b            (8)                     5  In device mode the value is the current frame  number of the last frame transmitted. It is not used as an index. In either  mode bits 2:0 indicate the current micro-frame.  */
        unsigned int undefined_bits_14_31:18;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_frindex_t;

#define USB2_CONTROLLER_1_USB2D_PERIODICLISTBASE_OFFSET 0x154
#define USB2_CONTROLLER_1_USB2D_PERIODICLISTBASE_RESET  0x00000000
typedef union usb2_controller_1_usb2d_periodiclistbase_u {
    struct {
        unsigned int undefined_bits_0_11:12;
        unsigned int usbadra:1;             /* Device Address Advance. Default=0.  When this bit is 0, any writes to USBADR are instantaneous.  When this bit is written to a 1 at the same time or before USBADR is written,  the write to the USBADR field is staged and held in a hidden register.  After an IN occurs on endpoint 0 and is ACKed, USBADR will be loaded from the holding register. Hardware will automatically clear this bit on the following conditions: 1) IN is ACKed to endpoint 0. (USBADR is updated from staging register). 2) OUT/SETUP occur to endpoint 0. (USBADR is not updated). 3) Device Reset occurs (USBADR is reset to 0).  Note: After the status phase of the SET_ADDRESS descriptor, the DCD has 2 ms to program the USBADR field. This mechanism will ensure this specification is met when  the DCD can not write of the device address within 2ms from the SET_ADDRESS status phase.  If the DCD writes the USBADR with USBADRA=1 after the SET_ADDRESS data phase  (before the prime of the status phase), the USBADR will be programmed instantly  at the correct time and meet the 2ms USB requirement. */
        unsigned int usbadr:7;              /* Device mode. The upper seven bits of this register represent the device address.  After any controller reset or a USB reset, the device address is set to the default address (0). The default address will match all incoming addresses.  Software shall reprogram the address after receiving a SET_ADDRESS request.  */
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_periodiclistbase_t;

#define USB2_CONTROLLER_1_USB2D_ASYNCLISTADDR_OFFSET 0x158
#define USB2_CONTROLLER_1_USB2D_ASYNCLISTADDR_RESET  0x00000000
typedef union usb2_controller_1_usb2d_asynclistaddr_u {
    struct {
        unsigned int undefined_bits_0_4:5;
        unsigned int epbase:21;             /* Device mode. This register contains the address of the top of the endpoint list in system memory. These bits correspond to memory address signals [31:11], respectively. This field will reference a list of up to 32 Queue Heads (QH). Only used by the device controller. */
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_asynclistaddr_t;

#define USB2_CONTROLLER_1_USB2D_ASYNCTTSTS_OFFSET 0x15C
#define USB2_CONTROLLER_1_USB2D_ASYNCTTSTS_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ASYNCTTSTS_WRMASK 0xFFFFFFFE
typedef union usb2_controller_1_usb2d_asyncttsts_u {
    struct {
        unsigned int ttas:1;                /* Embedded TT Async Buffers Status. (Read Only) This  read only bit will be 1 if one or more transactions are being held in the  embedded TT Async. Buffers. When this bit is a zero, then all outstanding  transactions in the embedded TT have been flushed.  */
        unsigned int ttac:1;                /* Embedded TT Async Buffers Clear. (Read/Write to  set) This field will clear all pending transactions in the embedded TT Async  Buffer(s). The clear will take as much time as necessary to clear buffer  without interfering with a transaction in progress. TTAC will return to zero  after being set by software only after the actual clear occurs.  */
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_asyncttsts_t;

#define USB2_CONTROLLER_1_USB2D_BURSTSIZE_OFFSET 0x160
#define USB2_CONTROLLER_1_USB2D_BURSTSIZE_RESET  0x00000808
typedef union usb2_controller_1_usb2d_burstsize_u {
    struct {
        unsigned int rxpburst:8;            /* Programmable RX Burst Length.  (Read/Write) This register represents the maximum length of a burst in 32-bit words while moving data from the USB bus to system memory. */
        unsigned int txpburst:8;            /* Programmable TX Burst Length.  (Read/Write) This register represents the maximum length of a burst in 32-bit words while moving data from system memory to the USB bus. */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_burstsize_t;

#define USB2_CONTROLLER_1_USB2D_TXFILLTUNING_OFFSET 0x164
#define USB2_CONTROLLER_1_USB2D_TXFILLTUNING_RESET  0x00020000
typedef union usb2_controller_1_usb2d_txfilltuning_u {
    struct {
        unsigned int txschoh:8;             /* Scheduler Overhead.  (Read/Write)  [Default = 0] This register adds an additional fixed offset to the schedule time estimator described above as Tff.  As an approximation, the value chosen for this register should limit the number of back-off events captured in the TXSCHHEALTH to less than 10 per second in a highly utilized bus.  Choosing a value that is too high for this register is not desired as it can needlessly reduce USB utilization. The time unit represented in this register is 1.267us when a device is connected in High-Speed Mode. The time unit represented in this register is 6.333us when a device is connected in Low/Full Speed Mode */
        unsigned int txschhealth:5;         /* Scheduler Health Counter.  (Read/Write To Clear)  [Default = 0] This register increments when the host controller fails to fill the TX latency FIFO to the level programmed by TXFIFOTHRES before running out of time to send the packet before the next Start-Of-Frame. This health counter measures the number of times this occurs to provide feedback to selecting a proper TXSCHOH.  Writing to this register will clear the counter and this counter will max. at 31. */
        unsigned int undefined_bits_13_15:3;
        unsigned int txfifothres:6;         /* FIFO Burst Threshold.  (Read/Write) This register controls the number of data bursts that are posted to the TX latency FIFO in host mode before the packet begins on to the bus.  The minimum value is 2 and this value should be a low as possible to maximize USB performance.  A higher value can be used in systems with unpredicable latency and/or insufficient bandwidth where the FIFO may underrun because the data transferred from the latency FIFO to USB occurs before it can be replenished from system memory.  This value is ignored if the Stream Disable bit in USBMODE register is set. */
        unsigned int undefined_bits_22_31:10;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_txfilltuning_t;

#define USB2_CONTROLLER_1_USB2D_ICUSB_CTRL_OFFSET 0x16C
#define USB2_CONTROLLER_1_USB2D_ICUSB_CTRL_RESET  0x00000000
typedef union usb2_controller_1_usb2d_icusb_ctrl_u {
    struct {
        unsigned int ic_vdd1:3;             /* ICUSB voltage select. It selects which voltage is being supplied to the ICUSB peripheral. 000 -> No voltage 001 -> 1.0V - reserved 010 -> 1.2V - reserved 011 -> 1.5V - reserved 100 -> 1.8V 101 -> 3.0V 110 -> reserved 111 -> reserved The Voltage negotiation should happen between enabling port power (PP) and asserting the run/stop bit in register. */
        unsigned int ic_enb1:1;             /* ICUSB transceiver enable.  This bit enables the ICUSB transceiver .  To enable the interface, the bits PTS must be set to 11 in the PORTSCx. Writing a '1' to this bit selects the IC_USB interface. */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_icusb_ctrl_t;

#define USB2_CONTROLLER_1_USB2D_ULPI_VIEWPORT_OFFSET 0x170
#define USB2_CONTROLLER_1_USB2D_ULPI_VIEWPORT_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ULPI_VIEWPORT_WRMASK 0xF7FF00FF
typedef union usb2_controller_1_usb2d_ulpi_viewport_u {
    struct {
        unsigned int ulpi_data_wr:8;        /* ULPI PHY data write. The data to write to the ULPI PHY register is written here. */
        unsigned int ulpi_data_rd:8;        /* ULPI PHY data read. The data from the ULPI PHY register can be read from here after the read operation completes. */
        unsigned int ulpi_reg_addr:8;       /* ULPI PHY register address. When doing a read or write operation to the ULPI PHY,  the address of the ULPI PHY register being accessed is written to this field. */
        unsigned int ulpi_port:3;           /* ULPI PHY port no. This field should be always written as 0. */
        unsigned int ulpi_sync_state:1;     /* ULPI sync state. (1)  Normal Sync. State. (0) In another state (i.e. carkit, serial, low power) This bit represents the state of the ULPI interface.  */
        unsigned int undefined_bit_28:1;
        unsigned int ulpi_rd_wr:1;          /* ULPI read/write control. (0)  Read; (1)  Write. This bit selects between running a read or write operation. */
        unsigned int ulpi_run:1;            /* ULPI read/write Run. Writing the 1 to this bit will begin the read/write operation.  The bit will automatically transition to 0 after the read/write is complete.  Once this bit is set, the driver can not set it back to 0.  Note: The driver must never execute a wakeup and a read/write operation at the same time. */
        unsigned int ulpi_wakeup:1;         /* ULPI Wakeup. Writing the 1 to this bit will begin the wakeup operation.  The bit will automatically transition to 0 after the wakeup is complete.  Once this bit is set, the driver can not set it back to 0.  Note: The driver must never execute a wakeup and a read/write operation at the same time. */
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_ulpi_viewport_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTNAK_OFFSET 0x178
#define USB2_CONTROLLER_1_USB2D_ENDPTNAK_RESET  0x00000000
typedef union usb2_controller_1_usb2d_endptnak_u {
    struct {
        unsigned int eprn:16;               /* RX Endpoint NAK  R/WC. Each RX endpoint has 1 bit in this field. The bit is set when the device sends a NAK handshake on a received OUT or PING token for the corresponding endpoint. */
        unsigned int eptn:16;               /* TX Endpoint NAK  R/WC. Each TX endpoint has 1 bit in this field. The bit is set when the device sends a NAK handshake on a received IN token for the corresponding endpoint. */
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptnak_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTNAK_ENABLE_OFFSET 0x17C
#define USB2_CONTROLLER_1_USB2D_ENDPTNAK_ENABLE_RESET  0x00000000
typedef union usb2_controller_1_usb2d_endptnak_enable_u {
    struct {
        unsigned int eprne:16;              /* RX Endpoint NAK Enable  R/W. Each bit is an enable bit for the corresponding RX Endpoint NAK bit. If this bit is set and the corresponding RX Endpoint NAK bit is set,  the NAK Interrupt bit is set. */
        unsigned int eptne:16;              /* TX Endpoint NAK Enable  R/W. Each bit is an enable bit for the corresponding TX Endpoint NAK bit. If this bit is set and the corresponding TX Endpoint NAK bit is set,  the NAK Interrupt bit is set. */
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptnak_enable_t;

#define USB2_CONTROLLER_1_USB2D_PORTSC1_OFFSET 0x184
#define USB2_CONTROLLER_1_USB2D_PORTSC1_RESET  0x00001004
#define USB2_CONTROLLER_1_USB2D_PORTSC1_WRMASK 0xE3FF114E
typedef union usb2_controller_1_usb2d_portsc1_u {
    struct {
        unsigned int ccs:1;                 /* Current Connect Status:  In Host Mode: 1=Device is present on port.                0=No device is present (default)  This value reflects the current state of the port, and may not correspond directly to the event that caused the Connect Status Change bit (Bit 1) to be set. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode.  In Device Mode: 1=Attached                    0=Not Attached (default)  A one indicates that the device successfully attached and is operating in either high speed or full speed as indicated by the High Speed Port bit in this register. A zero indicates that the device did not attach successfully or was forcibly disconnected by the software writing a zero to the Run bit in the USBCMD register. It does not state the device being disconnected or suspended.  */
        unsigned int csc:1;                 /* Connect Status Change: 1 =Change in Current Connect Status. 0=No change (default)  In Host Mode:  Indicates a change has occurred in the port's Current Connect Status. The host/device controller sets this bit for all changes to the port device connect status, even if system software has not cleared an existing connect status change. For example, the insertion status changes twice before system software has cleared the changed condition, hub hardware will be 'setting' an already-set bit (i.e., the bit will remain set).  Software clears this bit by writing a one to it. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode.  This bit is undefined in device controller mode.  */
        unsigned int pe:1;                  /* Port Enabled/Disabled: 1=Enable. 0=Disable (default) In Host Mode:  Ports can only be enabled by the host controller as a part of the reset and enable. Software cannot enable a port by writing a one to this field. Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by the host software. Note that the bit status does not change until the port state actually changes. There may be a delay in disabling or enabling a port due to other host controller and bus events.  When the port is disabled, (0b) downstream propagation of data is blocked except for reset. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode.  In Device Mode:  The device port is always enabled. (This bit will  be one)  */
        unsigned int pec:1;                 /* Port Enable/Disable Change: 1=Port enabled/disabled status has changed. 0=No change. In Host Mode:  For the root hub, this bit gets set to a one only when a port is disabled due to disconnect on the port or due to the appropriate conditions existing at the EOF2 point (See Chapter 11 of the USB Specification). Software clears this by writing a one to it. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero.  In Device mode:   The device port is always enabled. (This bit will  be zero)  */
        unsigned int oca:1;                 /* Over-current Active: Not supported */
        unsigned int occ:1;                 /* Over-current Change: Not supported */
        unsigned int fpr:1;                 /* Force Port Resume. 1= Resume detected/driven on port. 0=No resume (K state) detected/driven on port.  In Host Mode:  Software sets this bit to one to drive resume signaling. The Host Controller sets this bit to one if a J-to-K transition is detected while the port is in the Suspend state. When this bit transitions to a one because a J-to-K transition is detected, the Port Change Detect bit in the USBSTS register is also set to one.  This bit will automatically change to zero after the resume sequence is complete. This behavior is different from EHCI where the host controller driver is required to set this bit to a zero after the resume duration is timed in the driver.  Note that when the Host controller owns the port, the resume sequence follows the defined sequence documented in the USB Specification Revision 2.0. The resume signaling (Full-speed 'K') is driven on the port as long as this bit remains a one.  This bit remains a one until the port has switched to the high-speed idle.  Writing a zero has no effect because the port controller will time the resume operation to clear the bit when the port control state switches to HS or FS idle. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode. This bit is not-EHCI compatible.  In Device mode:   After the device has been in Suspend State for 5ms or more, software must set this bit to one to drive resume signaling before clearing. The Device Controller will set this bit to one if a J-to-K transition is detected while the port is in the Suspend state. The bit will be cleared when the device returns to normal operation. Also, when this bit transitions to a one because a J-to-K transition is detected, the Port Change Detect bit in the USBSTS register is also set to one.  Software should ensure that the PHY clock is operational before writing a 1 to this bit to start the resume sequence. This is true for both Device and Host modes. */
        unsigned int susp:1;                /* Port suspend. 1=Port in suspend state. 0=Port not in suspend state.  In Host Mode: Read/Write.  Port Enabled Bit and Suspend bit of this register define the port states as follows:  Bits [Port Enabled, Suspend]    Port State         0x                        Disable    10                        Enable     11                        Suspend  When in suspend state, downstream propagation of data is blocked on this port, except for port reset. The blocking occurs at the end of the current transaction if a transaction was in progress when this bit was written to 1. In the suspend state, the port is sensitive to resume detection. Note that the bit status does not change until the port is suspended and that there may be a delay in suspending a port if there is a transaction currently in progress on the USB. The host controller will unconditionally set this bit to zero when software sets the Force Port Resume bit to zero. A write of zero to this bit is ignored by the host controller. If host software sets this bit to a one when the port is not enabled (i.e. Port enabled bit is a zero) the results are undefined. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode. In Device Mode: Read Only. This bit is a read only status bit.  */
        unsigned int pr:1;                  /* This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero.  In Host Mode: Read/Write. 1=Port is in Reset. 0=Port is not in Reset. When software writes a one to this bit the bus-reset sequence as defined in the USB Specification Revision 2.0 is started. This bit will automatically change to zero after the reset sequence is complete. This behavior is different from EHCI where the host controller driver is required to set this bit to a zero after the reset duration is timed in the driver.   In Device Mode: This bit is a read only status  bit. Device reset from the USB bus is also indicated in the USBSTS register.  */
        unsigned int hsp:1;                 /* When the bit is one, the host/device connected to the port is in high-speed mode and if set to zero, the host/device connected to the port is not in a high-speed mode.  Note: HSP is redundant with PSPD(27:26).  This bit is not defined in the EHCI specification. */
        unsigned int ls:2;                  /* Line state. These bits reflect the current logical levels of the D+ (bit 10) and D- (bit 11) signal lines. The encoding of the bits are: 00b = SE0  01b = J-state  10b = K-state  11b = Undefined  The value of this field is undefined if Port  Power(PP) and B-Host Enable(BHEN) is zero in host mode. In host mode, the use  of line-state by the host controller driver is not necessary (unlike EHCI),  because the port controller state machine and the port routing manage the  connection of LS and FS. In device mode, the use of line-state by the device  controller driver is not necessary.  */
        unsigned int pp:1;                  /* Port Power: The function of this bit depends on the value of the Port Power Switching (PPC) field in the HCSPARAMS register. The behavior is as follows:  PPC                       PP  Operation  0b                           0b Read Only. A device controller with no OTG capability does not have port power control switches.  1b                          1b/0b RW.  Host/OTG controller requires port power control switches.  This bit represents the current setting of the switch (0=off, 1=on).  When power is not available on a port (i.e. PP equals a 0), the port is non-functional and will not report attaches, detaches, etc.  When an over-current condition is detected on a  powered port and PPC is a one, the PP bit in each affected port may be  transitioned by the host controller driver from a one to a zero (removing  power from the port).  */
        unsigned int po:1;                  /* Port Owner. Port owner handoff is not implemented in this design, therefore this bit will  always be 0.  */
        unsigned int pic:2;                 /* Port Indicator Control: This field is not supported in the current  implementation. Please use a GPIO if you wish to use Port Indicators. */
        unsigned int ptc:4;                 /* Port Test Control: Any other value than zero indicates that the port is operating in test mode.    Value                  Specific Test   0000b                Not enabled   0001b                  J_ STATE   0010b             K_STATE   0011b              SEQ_NAK   0100b              Packet   0101b               FORCE_ENABLE   0110b to 1111b         Reserved  Refer to Chapter 7 of the USB Specification  Revision 2.0 for details on each test mode.  */
        unsigned int wkcn:1;                /* Wake on Connect Enable: Writing this bit to a one enables the port to be sensitive to device connects as wake-up events. This field is zero if Port Power(PP)  and B-Host Enable(BHEN) is zero or in device mode.  This bit should only be used when operating in Host mode. Writing this bit to 1 while the controller is working in device mode can result in undefined behaviour.  This bit should not be written to 1 while the  device is connected. After the device connection is detected, this bit should  be cleared to 0. */
        unsigned int wkds:1;                /* Wake on Disconnect Enable: Writing this bit to a one enables the port to be sensitive to device disconnects as wake-up events. This field is zero if Port Power(PP)  and B-Host Enable(BHEN) is zero or in device mode.  This bit should only be used when operating in Host mode. Writing this bit to 1 while the controller is working in device mode can result in undefined behaviour.  This bit should not be written to 1 if there is no  device connected. After the device disconnect is detected, this bit should be  cleared to 0. */
        unsigned int wkoc:1;                /* Default = 0b. Wake on Over-current Enable: Writing this bit to a one enables  the port to be sensitive to over-current conditions as wake-up events. This  field is zero if Port Power(PP) is zero. This bit should only be used when  operating in Host mode. Writing this bit to 1 while the controller is working  in device mode can result in undefined behavior. */
        unsigned int phcd:1;                /* PHY Low Power Suspend - Clock disable: Writing this bit to a 1 will disable the PHY clock. Write a 0 enables it. Reading this bit will indicate the status of the PHY clock. In device mode, the PHY can be put into Low Power Suspend - Clock disable when the device is not running (USBCMD Run/Stop = 0) or the host has signaled suspend (PORTSC SUSPEND = 1). Low power suspend will be cleared automatically when the host has signaled resume. Before forcing a resume from the device, the device controller driver must clear this bit. In host mode, the PHY can be put into Low Power Suspend - Clock disable when the downstream device has been put into suspend mode or when no downstream device is connected. This bit is not defined in the EHCI specification. */
        unsigned int pfsc:1;                /* Port Force Full Speed Connect: Writing this bit to a 1b forces the port to connect at Full Speed only. It disables the chirp sequence that allows the port to identify itself as High Speed. This is useful for testing FS configurations with a HS host, hub or device. This bit is not defined in the EHCI specification. */
        unsigned int srt:1;                 /* Shorten USB Reset Time. Software should never set this to 1. */
        unsigned int pspd:2;                /* This register field indicates the speed at which the port is operating.  00 = Full Speed 01 = Low Speed 10 = High Speed  This bit is not defined in the EHCI specification.   */
        unsigned int ptw:1;                 /* Parallel Transceiver Width. Fixed to 0. This bit is not defined in the EHCI specification.   */
        unsigned int sts:1;                 /* 0 = Serial transceiver not selected. This is the  only value supported. This bit is not defined in the EHCI specification.  */
        unsigned int pts:2;                 /* Parallel transceiver select. This bit is not defined in the EHCI specification.  */
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_portsc1_t;

#define USB2_CONTROLLER_1_USB2D_OTGSC_OFFSET 0x1A4
#define USB2_CONTROLLER_1_USB2D_OTGSC_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_OTGSC_WRMASK 0xFFFF80FF
typedef union usb2_controller_1_usb2d_otgsc_u {
    struct {
        unsigned int vd:1;                  /* VBUS_Discharge. Read/write. Setting this bit  causes Vbus to discharge through a resistor.  */
        unsigned int vc:1;                  /* VBUS Charge. Setting this bit causes the VBus line to be  charged. This is used for VBus pulsing during SRP.  */
        unsigned int undefined_bit_2:1;
        unsigned int ot:1;                  /* OTG Termination. This bit must be set when the OTG device is in device mode, this controls the pulldown on DM.  */
        unsigned int dp:1;                  /* Data Pulsing. Setting this bit causes the pull-up on DP to be  asserted for data pulsing during SRP.  */
        unsigned int idpu:1;                /* USB ID Pullup */
        unsigned int undefined_bits_6_7:2;
        unsigned int id:1;                  /* USB ID: 0 = A-device  1 = B-device */
        unsigned int avv:1;                 /* A VBus Valid. Indicates VBus is above the A VBus valid threshold */
        unsigned int asv:1;                 /* A Session Valid. Indicates VBus is above the A session valid  threshold */
        unsigned int bsv:1;                 /* B Session Valid. Indicates VBus is above the B session valid  threshold */
        unsigned int bse:1;                 /* B session End. Indicates VBus is below the B session end  threshold */
        unsigned int onemst:1;              /* 1 millisecond timer toggle. This bit toggles once per millisecond */
        unsigned int dps:1;                 /* Data Bus Pulsing Status. A 1 indicates data bus pulsing is being detected  on the port.  */
        unsigned int undefined_bit_15:1;
        unsigned int idis:1;                /* USB ID Interrupt Status. This bit is set when a change on the ID input has been detected. Software writes a 1 to clear this bit.  */
        unsigned int avvis:1;               /* A VBus Valid Interrupt Status. This bit is set when VBus has either risen above  or fallen below the VBus valid threshold (4.4 VDC) on an A device. Software  writes a 1 to clear this bit.  */
        unsigned int asvis:1;               /* A Session Valid Interrupt Status. This bit is set when VBus has either risen above  or fallen below the A session valid threshold (0.8 VDC). Software writes a  one to clear this bit.  */
        unsigned int bsvis:1;               /* B Session Valid Interrupt Status. This bit is set when VBus has either risen above  or fallen below the B session valid threshold (0.8 VDC). Software writes a 1  to clear this bit.  */
        unsigned int bseis:1;               /* B Session End Interrupt Status. This bit is set when VBus has fallen below the B  session end threshold. Software writes a 1 to clear this bit . */
        unsigned int onemss:1;              /* 1 millisecond timer Interrupt Status: This bit is set once every millisecond. Software  writes a 1 to clear it. */
        unsigned int dpis:1;                /* Data Pulse Interrupt Status. This bit is set when data bus pulsing occurs on DP or DM.  Data bus pulsing is only detected when USBMODE.CM = Host (11) and PORTSC(0).PortPower = Off (0). Software writes a 1 to clear this bit. */
        unsigned int undefined_bit_23:1;
        unsigned int idie:1;                /* USB ID Interrupt Enable. Setting this bit enables the USB ID interrupt */
        unsigned int avvie:1;               /* A VBus Valid Interrupt Enable. Setting this bit enables the A VBus valid  interrupt */
        unsigned int asvie:1;               /* A Session Valid Interrupt Enable. Setting this bit enables the A session valid  interrupt */
        unsigned int bsvie:1;               /* B Session Valid Interrupt Enable. Setting this bit enables the B session valid  interrupt */
        unsigned int bseie:1;               /* B Session End Interrupt Enable. Setting this bit enables the B session end  interrupt */
        unsigned int onemse:1;              /* 1 millisecond timer Interrupt enable. Setting this bit enables the 1 millisecond timer  interrupt. */
        unsigned int dpie:1;                /* Data Pulse Interrupt Enable. Setting this bit enables the Data pulse interrupt. */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_otgsc_t;

#define USB2_CONTROLLER_1_USB2D_USBMODE_OFFSET 0x1A8
#define USB2_CONTROLLER_1_USB2D_USBMODE_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_USBMODE_WRMASK 0xFFFFFFE0
typedef union usb2_controller_1_usb2d_usbmode_u {
    struct {
        unsigned int cm:2;                  /* Controller Mode: The controller mode will default to an idle state and will need to be initialized to the desired operating mode after reset. This register can only be written once after reset. If it is necessary to switch modes, software must reset the controller by writing to the RESET bit in the USBCMD register before reprogramming this register.  00 = Idle [Default]  01 = Reserved  10 = Device Controller   11 = Host Controller  */
        unsigned int es:1;                  /* Endian Select: Note: For this implementation, this should be  always set to 0 (little endian). */
        unsigned int slom:1;                /* Setup Lockout Mode: In device mode, this bit controls the behavior of the setup lockout mechanism. 0 - Setup lockout is ON (default) 1  Setup lockout is OFF. Firmware requires the  use of setup tripwire semaphore in USB2D_USBCMD register. */
        unsigned int sdis:1;                /* Stream disbable: 1 Streaming is disabled - helpful to avoid overrun/underruns when system load is too high. */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_usbmode_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTSETUPSTAT_OFFSET 0x1AC
#define USB2_CONTROLLER_1_USB2D_ENDPTSETUPSTAT_RESET  0x00000000
typedef union usb2_controller_1_usb2d_endptsetupstat_u {
    struct {
        unsigned int endptsetupstat0:1;     /* Endpoint 0 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat1:1;     /* Endpoint 1 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat2:1;     /* Endpoint 2 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat3:1;     /* Endpoint 3 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat4:1;     /* Endpoint 4 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat5:1;     /* Endpoint 5 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat6:1;     /* Endpoint 6 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat7:1;     /* Endpoint 7 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat8:1;     /* Endpoint 8 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat9:1;     /* Endpoint 9 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat10:1;    /* Endpoint 10 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat11:1;    /* Endpoint 11 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat12:1;    /* Endpoint 12 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat13:1;    /* Endpoint 13 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat14:1;    /* Endpoint 14 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat15:1;    /* Endpoint 15 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptsetupstat_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTPRIME_OFFSET 0x1B0
#define USB2_CONTROLLER_1_USB2D_ENDPTPRIME_RESET  0x00000000
typedef union usb2_controller_1_usb2d_endptprime_u {
    struct {
        unsigned int perb0:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb1:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb2:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb3:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb4:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb5:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb6:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb7:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb8:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb9:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb10:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb11:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb12:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb13:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb14:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb15:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int petb0:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb1:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb2:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb3:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb4:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb5:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb6:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb7:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb8:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb9:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb10:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb11:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb12:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb13:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb14:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb15:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptprime_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTFLUSH_OFFSET 0x1B4
#define USB2_CONTROLLER_1_USB2D_ENDPTFLUSH_RESET  0x00000000
typedef union usb2_controller_1_usb2d_endptflush_u {
    struct {
        unsigned int ferb0:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb1:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb2:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb3:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb4:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb5:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb6:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb7:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb8:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb9:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb10:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb11:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb12:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb13:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb14:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb15:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb0:1;               /* Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb1:1;               /*  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb2:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb3:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb4:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb5:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb6:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb7:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb8:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb9:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb10:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb11:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb12:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb13:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb14:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb15:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptflush_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTSTATUS_OFFSET 0x1B8
#define USB2_CONTROLLER_1_USB2D_ENDPTSTATUS_RESET  0x00000000
typedef union usb2_controller_1_usb2d_endptstatus_u {
    struct {
        unsigned int erbr0:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr1:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr2:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr3:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr4:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr5:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr6:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr7:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr8:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr9:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr10:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr11:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr12:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr13:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr14:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr15:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr0:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr1:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr2:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr3:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr4:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr5:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr6:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr7:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr8:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr9:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr10:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr11:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr12:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr13:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr14:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr15:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptstatus_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCOMPLETE_OFFSET 0x1BC
#define USB2_CONTROLLER_1_USB2D_ENDPTCOMPLETE_RESET  0x00000000
typedef union usb2_controller_1_usb2d_endptcomplete_u {
    struct {
        unsigned int erce0:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce1:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce2:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce3:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce4:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce5:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce6:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce7:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce8:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce9:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce10:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce11:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce12:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce13:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce14:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce15:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int etce0:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce1:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce2:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce3:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce4:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce5:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce6:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce7:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce8:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce9:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce10:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce11:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce12:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce13:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce14:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce15:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptcomplete_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL0_OFFSET 0x1C0
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL0_RESET  0x00800080
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL0_WRMASK 0xFF72FF72
typedef union usb2_controller_1_usb2d_endptctrl0_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: Software can write a one to this bit to force the  endpoint to return a STALL handshake to the Host. It will continue returning  STALL until the bit is cleared by software or it will automatically be  cleared upon receipt of a new SETUP request.  */
        unsigned int undefined_bit_1:1;
        unsigned int rxt:2;                 /* RX Endpoint Type. Endpoint 0 is fixed as a Control Endpoint.  */
        unsigned int undefined_bits_4_6:3;
        unsigned int rxe:1;                 /*  RX Endpoint Enable. Endpoint 0 is always  enabled.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: Software can write a one to this bit to force the  endpoint to return a STALL handshake to the Host. It will continue returning  STALL until the bit is cleared by software or it will automatically be  cleared upon receipt of a new SETUP request.  */
        unsigned int undefined_bit_17:1;
        unsigned int txt:2;                 /* TX Endpoint Type. Endpoint0 is fixed as a Control Endpoint.  */
        unsigned int undefined_bits_20_22:3;
        unsigned int txe:1;                 /* TX Endpoint Enable. Endpoint 0 is always  enabled.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl0_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL1_OFFSET 0x1C4
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL1_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL1_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl1_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above,  */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl1_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL2_OFFSET 0x1C8
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL2_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL2_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl2_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl2_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL3_OFFSET 0x1CC
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL3_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL3_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl3_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl3_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL4_OFFSET 0x1D0
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL4_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL4_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl4_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl4_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL5_OFFSET 0x1D4
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL5_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL5_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl5_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl5_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL6_OFFSET 0x1D8
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL6_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL6_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl6_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl6_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL7_OFFSET 0x1DC
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL7_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL7_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl7_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl7_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL8_OFFSET 0x1E0
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL8_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL8_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl8_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl8_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL9_OFFSET 0x1E4
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL9_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL9_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl9_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl9_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL10_OFFSET 0x1E8
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL10_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL10_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl10_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl10_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL11_OFFSET 0x1EC
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL11_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL11_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl11_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl11_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL12_OFFSET 0x1F0
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL12_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL12_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl12_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl12_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL13_OFFSET 0x1F4
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL13_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL13_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl13_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl13_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL14_OFFSET 0x1F8
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL14_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL14_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl14_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl14_t;

#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL15_OFFSET 0x1FC
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL15_RESET  0x00000000
#define USB2_CONTROLLER_1_USB2D_ENDPTCTRL15_WRMASK 0xFFFDFFFD
typedef union usb2_controller_1_usb2d_endptctrl15_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_1_usb2d_endptctrl15_t;

#define USB2_IF_USB_SUSP_CTRL_OFFSET 0x400
#define USB2_IF_USB_SUSP_CTRL_RESET  0x00000000
#define USB2_IF_USB_SUSP_CTRL_WRMASK 0xFFFFFE3E
typedef union usb2_if_usb_susp_ctrl_u {
    struct {
        unsigned int usb_wakeup_int_sts:1;  /* USB wakeup interrupt status This bit is set whenever USB wakes up from suspend (a wakeup event is generated). Software must write a 1 to clear this bit. Note that during the wakeup sequence, PHY clocks will be resumed from suspend. Software can check when the PHY clocks are resumed by reading the bit USB_PHY_CLK_VALID. There is also a separate interrupt generated when PHY clock is resumed if USB_PHY_CLK_VALID_INT_EN is set. During the wakeup sequence, first USB_WAKEUP_INT_STS will be set, and it will take some time for the PHY clock to resume, which can be detected by checking USB_PHY_CLK_VALID. */
        unsigned int usb_wakeup_int_enb:1;  /* USB wakeup interrupt enable If this bit is enabled, interrupt is generated whenever USB wakeup event is generated. */
        unsigned int usb_wake_on_resume_en:1; /* Wake on resume enable If this bit is enabled, USB will wakeup from suspend whenever a resume event is detected on USB. This is valid for both USB device and USB host modes. */
        unsigned int usb_wake_on_cnnt_en_dev:1; /* Wake on Connect Enable (device mode) When enabled (1), USB device will wakeup from suspend on a connect event. This is only valid when USB controller is in device mode, it is not applicable when USB controller is in host mode. */
        unsigned int usb_wake_on_discon_en_dev:1; /* Wake on Disconnect Enable (device mode) When enabled (1), USB device will wakeup from suspend on a disconnect event. This is only valid when USB controller is in device mode, it is not applicable when USB controller is in host mode. */
        unsigned int usb_susp_clr:1;        /* Suspend Clear Software must write a 1 to this bit to bring the PHY out of suspend mode. This is used when the software stops the PHY clock during suspend and then wants to initiate a resume. Software should also write 0 to clear it. NOTE: It is required that software generate a  positive pulse on this bit to guarantee proper operation. */
        unsigned int usb_clken:1;           /* USB AHB clock enable status. Indicates whether the AHB clock to the USB controller is enabled or not. If AHB clock to USB controller is enabled, this bit is set to 1, else it is set to 0. NOTE: even when this is set to 0, all essential blocks that are required to resume USB clocks from suspend will be active and their AHB clock will not be suspended. */
        unsigned int usb_phy_clk_valid:1;   /* USB PHY clock valid status This bit indicates whether the USB PHY is generating a valid clock to  the USB controller. If USB PHY clock is running, this bit is set to 1, else it is set to 0. */
        unsigned int usb_phy_clk_valid_int_sts:1; /* USB PHY clock valid interrupt status This bit is set whenever USB PHY clock is waked up from suspend. Software must write a 1 to clear this bit. */
        unsigned int usb_phy_clk_valid_int_enb:1; /* USB PHY clock valid interrupt enable If this bit is enabled, interrupt is generated whenever USB clocks are resumed from a suspend. */
        unsigned int uhsic_susp_pol:1;      /* Polarity of the suspend signal going to UHSIC PHY. 0 = Active low (default) 1 = Active high This should not be changed by software. */
        unsigned int uhsic_reset:1;         /* Reset going to UHSIC PHY (active high). This should be set to 1 whenever programming the UHSIC config registers. It should be cleared to 0 after the programming of UHSIC config registers is done. UHSIC config registers should be programmed only once before doing any transactions on UHSIC. The UHSIC PHY registers should be programmed while UHSIC is in reset. */
        unsigned int uhsic_phy_enb:1;       /* Enable UHSIC PHY mode. Set this to 1 if using UHSIC PHY. Otherwise set this to 0. */
        unsigned int ulpi_phy_enb:1;        /* Enable ULPI PHY mode. Set this to 1 if using null or link ULPI PHY. Otherwise set this to 0. */
        unsigned int undefined_bits_14_15:2;
        unsigned int usb_wakeup_debounce_count:3; /* USB PHY wakeup debounce counter USB will debounce any wakeup event by the number of clocks programmed  in this counter. A value of 0 results in no debounce. */
        unsigned int undefined_bits_19_31:13;
    };

    uint32_t reg32;
} usb2_if_usb_susp_ctrl_t;

#define USB2_IF_USB_ULPIS2S_CTRL_OFFSET 0x418
#define USB2_IF_USB_ULPIS2S_CTRL_RESET  0x00000000
typedef union usb2_if_usb_ulpis2s_ctrl_u {
    struct {
        unsigned int ulpis2s_ena:1;         /* When enabled, the ULPI link interface coming out of the usb2 controller enters a NULL phy with two slaves. As a result the external pins will have a slave ULPI interface. When disabled, the ULPI link interface coming out of the usb2 controller go straight to the pins.  */
        unsigned int ulpis2s_slv1_force_device:1; /* When disabled, the slave port that's connected to the pins can be programmed to be host or a device depending on the value of the DpPulldown and DmPulldown bits in the OTG_CTRL ULPI register. When enables, the values of those bits in the OTG_CTRL register is ignored and the port will always behave like a device. */
        unsigned int ulpis2s_support_disconnect:1; /* When disabled, the PHY will never detect a Disconnect. */
        unsigned int ulpis2s_pllu_master_blaster60:1; /* When enabled, the PLLU 60MHz clock will be forced on. */
        unsigned int undefined_bits_4_7:4;
        unsigned int ulpis2s_spare:4;       /* Reserved bits When enabled, it will when the other side goes to OPMODE1. */
        unsigned int ulpis2s_force_ulpi_clk_out:1; /* When enabled and ULPIS2S_ENA is ENABLED, the external ULPI_CLOCK pad will always carry the internal 60MHz clock, even if the interface is in shutdown mode. */
        unsigned int ulpis2s_discon_dont_check_se0:1; /* When enabled, the disconnect detection logic will only check that that the other side is 'driving' tri-state. It won't check whether or not the local side is driving SE0. */
        unsigned int ulpis2s_support_hs_keep_alive:1; /* When enabled, the PHY will support HS KeepAlive packets. In that case, this would be the only thing that's supported in Opmode3. All other Opmode3 generate packets are not supported under any circumstances. */
        unsigned int ulpis2s_disable_stp_pu:1; /* When set to 1 and in ULPIS2S mode, the pullup on the STP pin will NOT be active, even if the remote LINK asks to do so. In this case, an external pullup resistor would be required to ensure valid levels when the remote link is not powered. */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_if_usb_ulpis2s_ctrl_t;

#define USB2_IF_USB_ULPIS2S_SLV1_ID_OFFSET 0x41C
#define USB2_IF_USB_ULPIS2S_SLV1_ID_RESET  0x00000000
typedef union usb2_if_usb_ulpis2s_slv1_id_u {
    struct {
        unsigned int ulpis2s_slv1_product_id:16; /* PHY product_id as seen by external ULPI master */
        unsigned int ulpis2s_slv1_vendor_id:16; /* PHY vendor_id as seen by external ULPI master */
    };

    uint32_t reg32;
} usb2_if_usb_ulpis2s_slv1_id_t;

#define USB2_IF_USB_INTER_PKT_DELAY_CTRL_OFFSET 0x420
#define USB2_IF_USB_INTER_PKT_DELAY_CTRL_RESET  0x00000012
typedef union usb2_if_usb_inter_pkt_delay_ctrl_u {
    struct {
        unsigned int ip_delay_tx2tx_hs:6;   /* HS Tx to Tx inter-packet delay. This is valid only for UHSIC PHY. Software should not change this. */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} usb2_if_usb_inter_pkt_delay_ctrl_t;

#define USB2_IF_ULPI_TIMING_CTRL_0_OFFSET 0x424
#define USB2_IF_ULPI_TIMING_CTRL_0_RESET  0x04000000
typedef union usb2_if_ulpi_timing_ctrl_0_u {
    struct {
        unsigned int ulpi_clock_out_delay:5; /* Programmable delay on the ULPI Clock out */
        unsigned int undefined_bits_5_9:5;
        unsigned int ulpi_output_pinmux_byp:1; /* Bypass the pinmux on the ULPI output pins */
        unsigned int ulpi_clkout_pinmux_byp:1; /* Bypass the pinmux on the ULPI Clk */
        unsigned int ulpi_shadow_clk_loopback_en:1; /* Loopback the Shadow Clock at the PAD */
        unsigned int ulpi_shadow_clk_sel:1; /* Mux to select between the pre-pad   and post-pad Shadow clks  */
        unsigned int ulpi_core_clk_sel:1;   /* Mux to select between the ulpi clk out and Shadow clk */
        unsigned int ulpi_clk_pol:1;        /* ULPI Clock polarity control */
        unsigned int ulpi_shadow_clk_delay:5; /* Programmable delay on the Shadow ULPI Clock  */
        unsigned int undefined_bits_21_25:5;
        unsigned int ulpi_lbk_pad_en:1;     /* LOOPBACK PAD Output Enable */
        unsigned int ulpi_lbk_pad_e_input_or:1; /* LOOPBACK PAD E_input_or input */
        unsigned int ulpi_clk_out_ena:1;    /* Option to gate the ulpi_ck_out */
        unsigned int ulpi_clk_padout_ena:1; /* Option to disable clk to the ulpi_clk_out pad */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} usb2_if_ulpi_timing_ctrl_0_t;

#define USB2_IF_ULPI_TIMING_CTRL_1_OFFSET 0x428
#define USB2_IF_ULPI_TIMING_CTRL_1_RESET  0x00000000
typedef union usb2_if_ulpi_timing_ctrl_1_u {
    struct {
        unsigned int ulpi_data_trimmer_load:1; /* Load the trimmer value to the ulpi_data_trimmer on the ulpi_data_in signals */
        unsigned int ulpi_data_trimmer_sel:3; /* ULPI Data Trimmer Value */
        unsigned int undefined_bits_4_15:12;
        unsigned int ulpi_stpdirnxt_trimmer_load:1; /* Load the trimmer value to the ulpi_stp/dir/nxt_trimmer  */
        unsigned int ulpi_stpdirnxt_trimmer_sel:3; /* ULPI STP/DIR/NXT Trimmer Value */
        unsigned int undefined_bits_20_23:4;
        unsigned int ulpi_dir_trimmer_load:1; /* Load the trimmer value to the ulpi_dir that shut's off the oen's in ULPI mode */
        unsigned int ulpi_dir_trimmer_sel:3; /* ULPI DIR Trimmer Value (that shut's off the oen's in ULPI mode) */
        unsigned int undefined_bits_28_31:4;
    };

    uint32_t reg32;
} usb2_if_ulpi_timing_ctrl_1_t;

#define USB2_IF_USB_DEBUG_OFFSET 0x480
#define USB2_IF_USB_DEBUG_RESET  0x00000000
typedef union usb2_if_usb_debug_u {
    struct {
        unsigned int undefined_bits_0_4:5;
        unsigned int usb_buf_ahb_if_sel:1;  /* Route USB buffers to AHB interface for debug. When this is set to 1, normal USB operations cannot be done. */
        unsigned int usb_buf_low32bits_sel:1; /* Lower 32-bits select. Only valid for Tx and Rx memories that have 36-bit interface. When 0, selects upper 4-bits. When 1, selects lower 32-bits. */
        unsigned int undefined_bits_7_31:25;
    };

    uint32_t reg32;
} usb2_if_usb_debug_t;

#define USB2_UHSIC_PLL_CFG0_OFFSET 0x800
#define USB2_UHSIC_PLL_CFG0_RESET  0x00000000
typedef union usb2_uhsic_pll_cfg0_u {
    struct {
        unsigned int uhsic_pll_spare:1;     /* Reserved */
        unsigned int undefined_bits_1_31:31;
    };

    uint32_t reg32;
} usb2_uhsic_pll_cfg0_t;

#define USB2_UHSIC_PLL_CFG1_OFFSET 0x804
#define USB2_UHSIC_PLL_CFG1_RESET  0x0000C0C0
typedef union usb2_uhsic_pll_cfg1_u {
    struct {
        unsigned int uhsic_xtal_freq_count:12; /* 2.5ms / (1/19.2MHz) = 48000 / 256 = 187 = 0xBB */
        unsigned int uhsic_force_pllu_powerdown:1;
        unsigned int uhsic_force_pllu_powerup:1;
        unsigned int uhsic_pllu_enable_dly_count:5; /* 1 us / (1/19.2MHz) = 19 / 8 = 2.36 = 3 */
        unsigned int undefined_bits_19_31:13;
    };

    uint32_t reg32;
} usb2_uhsic_pll_cfg1_t;

#define USB2_UHSIC_HSRX_CFG0_OFFSET 0x808
#define USB2_UHSIC_HSRX_CFG0_RESET  0x00014E38
typedef union usb2_uhsic_hsrx_cfg0_u {
    struct {
        unsigned int uhsic_pass_feedback:1; /* Pass through the feedback, do not block it. */
        unsigned int uhsic_elastic_underrun_disable:1; /* Do not declare underrun errors */
        unsigned int uhsic_elastic_underrun_limit:5;
        unsigned int uhsic_elastic_overrun_disable:1; /* Do not declare overrun errors until overflow of FIFO */
        unsigned int uhsic_elastic_overrun_limit:5;
        unsigned int uhsic_idle_wait:5;     /* Number of cycles of idle to declare IDLE.  */
        unsigned int uhsic_no_stripping:1;  /* Do not strip incoming data */
        unsigned int undefined_bits_19_31:13;
    };

    uint32_t reg32;
} usb2_uhsic_hsrx_cfg0_t;

#define USB2_UHSIC_HSRX_CFG1_OFFSET 0x80C
#define USB2_UHSIC_HSRX_CFG1_RESET  0x00882913
typedef union usb2_uhsic_hsrx_cfg1_u {
    struct {
        unsigned int uhsic_hs_allow_keep_alive:1; /* Allow Keep Alive packets  */
        unsigned int uhsic_hs_sync_start_dly:5; /* How long to wait before start of sync launches RxActive */
        unsigned int uhsic_early_line_state_filter:1; /* Assumes line state filtering table is inclusive, not exclusive */
        unsigned int uhsic_line_state_bypass:1; /* Bypass LineState reclocking logic */
        unsigned int uhsic_line_state_resume_fake_se0:1; /* When enabled, send an SE0 for 2 LS symbols at the end of ResumeK */
        unsigned int uhsic_input_fifo_depth:5; /* Depth of the 2-bit wide input FIFO. Maximum depth is 20. Can be tuned */
        unsigned int uhsic_rx_strobe_dly_trimmer:6; /* Nr of delays cells between UH_RX_STROBE and RxStrobeClk in zero cycle path */
        unsigned int uhsic_tx_block_cnt:4;  /* Controls how long after the end of transmission the receive path is blocked */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_uhsic_hsrx_cfg1_t;

#define USB2_UHSIC_TX_CFG0_OFFSET 0x810
#define USB2_UHSIC_TX_CFG0_RESET  0x00000200
typedef union usb2_uhsic_tx_cfg0_u {
    struct {
        unsigned int uhsic_no_sync_no_eop:1; /* Do not sent SYNC or EOP */
        unsigned int uhsic_no_encoding:1;   /* No encoding, static programming */
        unsigned int uhsic_no_stuffing:1;   /* No bit stuffing, static programming */
        unsigned int uhsic_sof_on_no_encode:1; /* Sof when OpMode 2 -- not likely, for Chirp */
        unsigned int uhsic_sof_on_no_stuff:1; /* Sof when OpMode 3 -- perhaps, when sending controller made packets */
        unsigned int uhsic_sie_resume_on_linestate:1; /* SIE, not macrocell, detects LineState change to resume */
        unsigned int uhsic_hs_postamble_output_enable:1; /* output enable turns off 1 cycle after */
        unsigned int uhsic_packet_force_strobe_low:1; /* Force STROBE low during a regular instead of toggling it */
        unsigned int uhsic_packet_invert_data:1; /* Invert data during a regular packet */
        unsigned int uhsic_hs_ready_wait_for_valid:1;
        unsigned int undefined_bits_10_31:22;
    };

    uint32_t reg32;
} usb2_uhsic_tx_cfg0_t;

#define USB2_UHSIC_MISC_CFG0_OFFSET 0x814
#define USB2_UHSIC_MISC_CFG0_RESET  0x00044E8E
typedef union usb2_uhsic_misc_cfg0_u {
    struct {
        unsigned int uhsic_comb_terms:1;    /* Use combinational terminations or synced through CLKXTAL            */
        unsigned int uhsic_stable_all:1;    /* Determines if all signal need to be stable to not change a config. */
        unsigned int uhsic_stable_count:3;  /* Number of cycles of crystal clock of signal not changing to consider stable. */
        unsigned int uhsic_inject_error_type:2; /* Force error insertion into RX path. (Used for IOBIST.)        */
        unsigned int uhsic_suspend_exit_on_edge:1; /* Suspend exit requires edge or simply a value... */
        unsigned int uhsic_detect_short_connect:1; /* 0: use 3 edges (negative and positive) to detect a connect state on the line. 1: use 4 edges. */
        unsigned int uhsic_detect_short_idle:1; /* 0: use 3 edges (negative and positive) to detect a idle state on the line. 1: use 4 edges. */
        unsigned int uhsic_active_bk_drive_tx:1; /* 1: Use TX state to determine starting time to drive bus keeper instead of waiting for IDLE detection. */
        unsigned int uhsic_active_bk_drive_rx:1; /* 1: Use RX state (EOP etc) to determine starting time to drive bus keeper instead of waiting for IDLE detection. */
        unsigned int uhsic_long_connect_strobe:1; /* 0: STROBE is 2 periods long during connect. 1: STROBE is 3 periods long during connect */
        unsigned int uhsic_async_connect_data:1; /* 0: DATA keeps setup and hold requirements during CONNECT. 1: DATA moves together with STROBE */
        unsigned int uhsic_symmetric_connect_data:1; /* 0: DATA goes high before STROBE goes low and low before STROBE goes high. 1: DATA goes high before STROBE goes low and goes low *after* STROBE goes high. */
        unsigned int uhsic_force_xcvr_mode:1; /* 1: Force the values of XcvrSelect via config bits instead of via the controller */
        unsigned int uhsic_force_xcvrsel:2; /* Value to be forced on XcvrSelect when FORCE_XCVR_MODE is set. */
        unsigned int uhsic_extend_bk_active:1; /* Drive buskeeper one cycle longer when going out of IDLE */
        unsigned int undefined_bits_19_31:13;
    };

    uint32_t reg32;
} usb2_uhsic_misc_cfg0_t;

#define USB2_UHSIC_MISC_CFG1_OFFSET 0x818
#define USB2_UHSIC_MISC_CFG1_RESET  0x00021802
typedef union usb2_uhsic_misc_cfg1_u {
    struct {
        unsigned int uhsic_rx_error_cnt_en:1; /* Enable IOBIST RxError counter when not in IOBIST mode. Allows one to read out the number of errors via JTAG during normal operation */
        unsigned int uhsic_rx_error_cnt_clr:1; /* Clear IOBST RxError counter */
        unsigned int uhsic_pllu_stable_count:12; /* WRONG! This should be 1ms -> 0x50 */
        unsigned int uhsic_force_iobist_clk_on:1; /* Always enable IoBist CLK60. This would be required when you want to use RX_ERROR_CNT_EN. */
        unsigned int uhsic_obs_sel:2;       /* Select which one of 4 observation vectors is presented on the observation bus */
        unsigned int uhsic_phy_xtal_clocken:1; /* Selects whether to enable the crystal clock in the module. */
        unsigned int undefined_bits_18_31:14;
    };

    uint32_t reg32;
} usb2_uhsic_misc_cfg1_t;

#define USB2_UHSIC_PADS_CFG0_OFFSET 0x81C
#define USB2_UHSIC_PADS_CFG0_RESET  0x00888888
typedef union usb2_uhsic_pads_cfg0_u {
    struct {
        unsigned int uhsic_tx_rtermp:4;     /* Output impedance adjustment for PMOS driver */
        unsigned int uhsic_tx_rtermn:4;     /* Output impedance adjustment for NMOS driver */
        unsigned int uhsic_tx_rtunep:4;     /* Fine tuned 50 Ohm termination resistor for PMOS driver */
        unsigned int uhsic_tx_rtunen:4;     /* Fine tuned 50 Ohm termination resistor for NMOS driver */
        unsigned int uhsic_tx_slewp:4;      /* Output slew rate (rise time) adjustment */
        unsigned int uhsic_tx_slewn:4;      /* Output slew rate (fall time) adjustment */
        unsigned int uhsic_hsic_opt:8;      /* Spare config bits */
    };

    uint32_t reg32;
} usb2_uhsic_pads_cfg0_t;

#define USB2_UHSIC_PADS_CFG1_OFFSET 0x820
#define USB2_UHSIC_PADS_CFG1_RESET  0x0000067D
typedef union usb2_uhsic_pads_cfg1_u {
    struct {
        unsigned int uhsic_auto_rterm_en:1; /* Enable auto-termination */
        unsigned int uhsic_iddq:1;          /* Shut down analog blocks for IDDQ testing */
        unsigned int uhsic_pd_bg:1;         /* Power down band-gap and bias generator */
        unsigned int uhsic_pd_tx:1;         /* Power down transmitter */
        unsigned int uhsic_pd_trk:1;        /* Power down tracking circuit */
        unsigned int uhsic_pd_rx:1;         /* Power down receiver */
        unsigned int uhsic_pd_zi:1;         /* Power down single ended receiver */
        unsigned int uhsic_rx_sel:1;        /* 0: differential read buffers, 1: single-ended buffers */
        unsigned int uhsic_lpbk:1;          /* Internal digital loopback */
        unsigned int uhsic_rpd_data:1;      /* Enable pull down on IO_DATA */
        unsigned int uhsic_rpd_strobe:1;    /* Enable pull down on IO_STROBE */
        unsigned int uhsic_rpu_data:1;      /* Enable pull up on IO_DATA */
        unsigned int uhsic_rpu_strobe:1;    /* Enable pull up on IO_STROBE */
        unsigned int undefined_bits_13_31:19;
    };

    uint32_t reg32;
} usb2_uhsic_pads_cfg1_t;

#define USB2_UHSIC_CMD_CFG0_OFFSET 0x824
#define USB2_UHSIC_CMD_CFG0_RESET  0x00000005
typedef union usb2_uhsic_cmd_cfg0_u {
    struct {
        unsigned int uhsic_auto_activate:1; /* Upon power up, automatically move to activation mode and  start going through connect procedure. */
        unsigned int uhsic_force_activate:1; /* Upon rising value of this bit, instruct state machine to go into activation mode.  Only useful when AUTO_ACTIVATE is disabled. */
        unsigned int uhsic_auto_connect:1;  /* As device, automatically send Connect during activation.  */
        unsigned int uhsic_force_connect:1; /* Upon rising value of this bit, force device to send connect. Only useful when AUTO_CONNECT is disabled. */
        unsigned int uhsic_force_reset:1;
        unsigned int uhsic_pretend_connect_detect:1;
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} usb2_uhsic_cmd_cfg0_t;

#define USB2_UHSIC_STAT_CFG0_OFFSET 0x828
#define USB2_UHSIC_STAT_CFG0_RESET  0x00000000
#define USB2_UHSIC_STAT_CFG0_WRMASK 0x000000F9
typedef union usb2_uhsic_stat_cfg0_u {
    struct {
        unsigned int uhsic_connect_detect:1;
        unsigned int uhsic_bus_state:2;
        unsigned int undefined_bits_3_7:5;
        unsigned int uhsic_spare_status:8;
        unsigned int uhsic_caliout:16;
    };

    uint32_t reg32;
} usb2_uhsic_stat_cfg0_t;

#define USB2_UHSIC_SPARE_CFG0_OFFSET 0x82C
#define USB2_UHSIC_SPARE_CFG0_RESET  0xFFFF0000
typedef union usb2_uhsic_spare_cfg0_u {
    struct {
        unsigned int uhsic_spare:32;        /* Bit 0    : HS_RX_IPG_ERROR_ENABLE Bit 1    : HS_RX_FLUSH_ALAP Bit 2    : FORCE_TRIM_ZERO            Bit 7 :4 : RX_DATA_TRIM[3:0]          Bit 11:8 : RX_STROBE_TRIM[3:0] Bit 12   : FORCE_BK_ON Bit 13   : BYPASS_INIT_BLOCK bit 14   : FORCE_SM_IDLE */
    };

    uint32_t reg32;
} usb2_uhsic_spare_cfg0_t;

#define USB2_CONTROLLER_2_USB2D_ID_OFFSET 0x0
#define USB2_CONTROLLER_2_USB2D_ID_RESET  0x0033FA05
#define USB2_CONTROLLER_2_USB2D_ID_WRMASK 0xFF000000
typedef union usb2_controller_2_usb2d_id_u {
    struct {
        unsigned int id:8;                  /* Configuration number. This field is set to 0x05 */
        unsigned int nid:8;                 /* Ones complement version of ID. This field is set  to 0xFA. */
        unsigned int revision:8;            /* Revision number of the USB controller. This is set  to 0x33. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_id_t;

#define USB2_CONTROLLER_2_USB2D_HW_GENERAL_OFFSET 0x4
#define USB2_CONTROLLER_2_USB2D_HW_GENERAL_RESET  0x00000035
#define USB2_CONTROLLER_2_USB2D_HW_GENERAL_WRMASK 0xFFFFFE08
typedef union usb2_controller_2_usb2d_hw_general_u {
    struct {
        unsigned int rt:1;                  /* VUSB_HS_RESET_TYPE : set to 1 = asynchronous reset */
        unsigned int clkc:2;                /* VUSB_HS_CLOCK_CONFIGURATION : Clock configuration  2 selected */
        unsigned int undefined_bit_3:1;
        unsigned int phyw:2;                /* VUSB_HS_PHY16_8 : Width of the UTMI parallel  interface. Set to 3 : 16-bit UTMI parallel interface software programmable to  8-bit */
        unsigned int phym:3;                /* VUSB_HS_PHY_MODE : set to 0 for UTMI PHY */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_hw_general_t;

#define USB2_CONTROLLER_2_USB2D_HW_HOST_OFFSET 0x8
#define USB2_CONTROLLER_2_USB2D_HW_HOST_RESET  0x00000001
#define USB2_CONTROLLER_2_USB2D_HW_HOST_WRMASK 0xFFFFFFF0
typedef union usb2_controller_2_usb2d_hw_host_u {
    struct {
        unsigned int hc:1;                  /* VUSB_HS_HOST: Indicates support for host mode. Set  to 1. */
        unsigned int nport:3;               /* VUSB_HS_NUM_PORT-1: This host controller has only  1 port. So this field will always be 0. */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_hw_host_t;

#define USB2_CONTROLLER_2_USB2D_HW_DEVICE_OFFSET 0xC
#define USB2_CONTROLLER_2_USB2D_HW_DEVICE_RESET  0x00000021
#define USB2_CONTROLLER_2_USB2D_HW_DEVICE_WRMASK 0xFFFFFFC0
typedef union usb2_controller_2_usb2d_hw_device_u {
    struct {
        unsigned int dc:1;                  /* Device capable: Set to 1 indicating support for device mode. */
        unsigned int devep:5;               /* VUSB_HS_DV_EP: No. of endpoints supported by this device controller. Set to 16. This includes control endpoint 0. */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_hw_device_t;

#define USB2_CONTROLLER_2_USB2D_HW_TXBUF_OFFSET 0x10
#define USB2_CONTROLLER_2_USB2D_HW_TXBUF_RESET  0x00070B08
#define USB2_CONTROLLER_2_USB2D_HW_TXBUF_WRMASK 0xFF000000
typedef union usb2_controller_2_usb2d_hw_txbuf_u {
    struct {
        unsigned int tcburst:8;             /* VUSB_HS_TX_BURST: Maximum burst size supported by the transmit endpoints for data transfers. Set to 8. */
        unsigned int txadd:8;               /* VUSB_HS_TX_ADD: Total no. of address bits for the transmit buffer. Set to 11. The total depth of the transmit buffer is 2048 words. */
        unsigned int txchanadd:8;           /* VUSB_HS_TX_CHAN_ADD: Total no. of address bits for the transmit buffer of each transmit endpoint. Set to 7. Each transmit buffer is 128 words deep. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_hw_txbuf_t;

#define USB2_CONTROLLER_2_USB2D_HW_RXBUF_OFFSET 0x14
#define USB2_CONTROLLER_2_USB2D_HW_RXBUF_RESET  0x00000708
#define USB2_CONTROLLER_2_USB2D_HW_RXBUF_WRMASK 0xFFFF0000
typedef union usb2_controller_2_usb2d_hw_rxbuf_u {
    struct {
        unsigned int rxburst:8;             /* VUSB_HS_RX_BURST: Maximum burst size supported by the receive endpoints for data transfers. Set to 8. */
        unsigned int rxadd:8;               /* VUSB_HS_RX_ADD: Total no. of address bits for the receive buffer. Set to 7. The total depth of the receive buffer is 128 words */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_hw_rxbuf_t;

#define USB2_CONTROLLER_2_USB2D_CAPLENGTH_OFFSET 0x100
#define USB2_CONTROLLER_2_USB2D_CAPLENGTH_RESET  0x00000040
#define USB2_CONTROLLER_2_USB2D_CAPLENGTH_WRMASK 0xFFFFFF00
typedef union usb2_controller_2_usb2d_caplength_u {
    struct {
        unsigned int caplength:8;           /* Indicates which offset to add to the register base address at the beginning of the Operational Register. Set to 0x40. */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_caplength_t;

#define USB2_CONTROLLER_2_USB2D_HCIVERSON_OFFSET 0x102
#define USB2_CONTROLLER_2_USB2D_HCIVERSON_RESET  0x00000100
#define USB2_CONTROLLER_2_USB2D_HCIVERSON_WRMASK 0xFFFF0000
typedef union usb2_controller_2_usb2d_hciverson_u {
    struct {
        unsigned int hciversion:16;         /* Contains a BCD encoding of the EHCI revision number supported by this host controller. The most significant byte of this register represents a major revision and the least significant byte is the minor revision. This host controller supports EHCI revision 1.00. */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_hciverson_t;

#define USB2_CONTROLLER_2_USB2D_HCSPARAMS_OFFSET 0x104
#define USB2_CONTROLLER_2_USB2D_HCSPARAMS_RESET  0x01100011
#define USB2_CONTROLLER_2_USB2D_HCSPARAMS_WRMASK 0xF00F00E0
typedef union usb2_controller_2_usb2d_hcsparams_u {
    struct {
        unsigned int n_ports:4;             /* Number of downstream ports. This field specifies the number of physical downstream ports implemented on this host controller. This field is fixed to 1, since this host controller only supports 1 port. */
        unsigned int ppc:1;                 /* Port Power Control: indicates whether the host controller implementation includes port power control.  1 = Ports have port power switches         0= Ports do not have port power switches. This field affects the functionality of the port Power field in each port status and control register. This field is set to 1. */
        unsigned int undefined_bits_5_7:3;
        unsigned int n_pcc:4;               /* Number of Ports per Companion Controller: indicates the number of ports supported per internal companion controller. This field is set to 0. */
        unsigned int n_cc:4;                /* Number of Companion Controller: indicates the number of companion controllers. This field is set to 0. */
        unsigned int undefined_bits_16_19:4;
        unsigned int n_ptt:4;               /* Number of Ports per Transaction Translator: indicates the number of ports assigned to each transaction translator within the USB2.0 host controller. Field always equals N_PORTS. This is a non-EHCI field to support embedded TT. */
        unsigned int n_tt:4;                /* Number of Transaction Translators: indicates the number of embedded transaction translators associated with the USB2.0 host controller. This field is always set to 1 indicating only 1 embedded TT is implemented in this implementation. This is a non-EHCI field to support embedded TT. */
        unsigned int undefined_bits_28_31:4;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_hcsparams_t;

#define USB2_CONTROLLER_2_USB2D_HCCPARAMS_OFFSET 0x108
#define USB2_CONTROLLER_2_USB2D_HCCPARAMS_RESET  0x00000006
#define USB2_CONTROLLER_2_USB2D_HCCPARAMS_WRMASK 0xFFFF0009
typedef union usb2_controller_2_usb2d_hccparams_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int pfl:1;                 /* Programmable Frame List Flag.  0 = System software must use a frame list length of 1024 elements with this host controller. The USBCMD register Frame List Size field is a read-only register and must be set to zero.  1 = System software can specify and use a smaller frame list and configure the host controller via the USBCMD register Frame List Size field.  The frame list must always be aligned on a 4K-page boundary.  This requirement ensures that the frame list is always physically contiguous.  This field will always be "1".  */
        unsigned int asp:1;                 /* Asynchronous Schedule Park Capability.  1 = (Default) the host controller supports the park feature for high-speed queue heads in the Asynchronous Schedule. The feature can be disabled or enabled and set to a specific level by using the Asynchronous Schedule Park Mode Enable and Asynchronous Schedule Park Mode Count fields in the USBCMD register.  This field is always 1. */
        unsigned int undefined_bit_3:1;
        unsigned int ist:4;                 /* Isochronous Scheduling Threshold. This field indicates, relative to the current position of the executing host controller, where software can reliably update the isochronous schedule. When bit [7] is zero, the value of the least significant 3 bits indicates the number of micro-frames a host controller can hold a set of isochronous data structures  (one or more) before flushing the state. When bit [7] is a one, then host software assumes the host controller may cache an isochronous data structure for an entire frame. This field will always be "0".  */
        unsigned int eecp:8;                /* EHCI Extended Capabilities Pointer: indicates a capabilities list exists. A value of 00h indicates no extended capabilities are implemented. For this implementation this field is always "0".  */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_hccparams_t;

#define USB2_CONTROLLER_2_USB2D_DCIVERSION_OFFSET 0x120
#define USB2_CONTROLLER_2_USB2D_DCIVERSION_RESET  0x00000001
#define USB2_CONTROLLER_2_USB2D_DCIVERSION_WRMASK 0xFFFF0000
typedef union usb2_controller_2_usb2d_dciversion_u {
    struct {
        unsigned int dciversion:16;         /* The device controller interface conforms to the two-byte BCD encoding of the interface version number contained in this  register.  */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_dciversion_t;

#define USB2_CONTROLLER_2_USB2D_DCCPARAMS_OFFSET 0x124
#define USB2_CONTROLLER_2_USB2D_DCCPARAMS_RESET  0x00000190
#define USB2_CONTROLLER_2_USB2D_DCCPARAMS_WRMASK 0xFFFFFE60
typedef union usb2_controller_2_usb2d_dccparams_u {
    struct {
        unsigned int den:5;                 /* Device Endpoint Number: Number of endpoints built into the device controller. This is set to 16. */
        unsigned int undefined_bits_5_6:2;
        unsigned int dc:1;                  /* Device Capable: 1 = Controller is capable of operating as USB 2.0 device. This field is set to 1. */
        unsigned int hc:1;                  /* Host Capable: 1 = This controller is capable of operating as an EHCI compatible USB 2 0 host controller operating as an EHCI  compatible USB 2.0 host controller. This field is set to 1. */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_dccparams_t;

#define USB2_CONTROLLER_2_USB2D_USBCMD_OFFSET 0x140
#define USB2_CONTROLLER_2_USB2D_USBCMD_RESET  0x00080B00
#define USB2_CONTROLLER_2_USB2D_USBCMD_WRMASK 0xFFFFFF7F
typedef union usb2_controller_2_usb2d_usbcmd_u {
    struct {
        unsigned int rs:1;                  /* Run/Stop:  Host Controller:  When set to a 1, the Host Controller proceeds with the execution of the schedule.   The Host Controller continues execution as long as this bit is set to a one.  When this bit is set to 0, the Host Controller completes the current transaction on the USB and then halts.  The HCHalted bit in the status register indicates when the Host Controller has finished the transaction and has entered the stopped state.  Software should not write a one to this field unless the host controller is in the Halted state (i.e. HCHalted in the USBSTS register is a one).  Device Controller:  Writing a one to this bit will cause the device  controller to enable a pull-up on D+ and initiate an attach event. This  control bit is not directly connected to the pull-up enable, as the pull-up  will become disabled upon transitioning into high-speed mode. Software should  use this bit to prevent an attach event before the device controller has been  properly initialized. Writing a 0 to this will cause a detach event.  */
        unsigned int rst:1;                 /* Controller Reset. Software uses this bit to reset the controller. This bit is set to zero by the Host/Device Controller when the reset process is complete. Software cannot terminate the reset process early by writing a zero to this register.  Host Controller:  When software writes a one to this bit, the Host Controller resets its internal pipelines, timers, counters, state machines etc. to their initial value. Any transaction currently in progress on USB is immediately terminated. A USB reset is not driven on downstream ports. Software should not set this bit to a one when the HCHalted bit in the USBSTS register is a zero.  Attempting to reset an actively running host controller results in undefined behavior.    Device Controller:  When software writes a one to this bit, the Device  Controller resets its internal pipelines, timers, counters, state machines  etc. to their initial value. Any transaction currently in progress on USB is  immediately terminated. Writing a one to this bit in device mode is not  recommended.  */
        unsigned int fs1_fs0:2;             /* Frame List Size . (Read/Write).  000 = Default This field is Read/Write only if Programmable Frame List Flag in the HCCPARAMS registers is set to one.  Hence this field is Read/Write for this implementation. This field specifies the size of the frame list that controls which bits in the Frame Index Register should be used for the Frame List Current index.  Note that this field is made up from USBCMD bits 15, 3 and 2.  000 = 1024 elements (4096 bytes) Default value  001 = 512 elements (2048 bytes)  010 = 256 elements (1024 bytes)   011 = 128 elements (512 bytes)  100 = 64 elements (256 bytes)  101 = 32 elements (128 bytes)  110 = 16 elements (64 bytes)  111 = 8 elements (32 bytes)        Only the host controller uses this field.  */
        unsigned int pse:1;                 /* Periodic Schedule Enable.This bit controls whether the host controller skips processing the Periodic Schedule.  0 = Do not process the Periodic Schedule  1 = Use the PERIODICLISTBASE register to access the Periodic  Schedule.  Only the host controller uses this bit.  */
        unsigned int ase:1;                 /* Asynchronous Schedule Enable. This bit controls whether the host controller skips processing the Asynchronous Schedule.  0 = Do not process the Asynchronous Schedule.  1 = Use the ASYNCLISTADDR register to access the  Asynchronous Schedule.  Only the host controller uses this bit.  */
        unsigned int iaa:1;                 /* Interrupt on Async Advance Doorbell. When the host controller has evicted all  appropriate cached schedule states, it sets the Interrupt on Async Advance  status bit in the USBSTS register. If the Interrupt on Sync Advance Enable  bit in the USBINTR register is one, then the host controller will assert an  interrupt at the next interrupt threshold. The host controller sets this bit  to zero after it has set the Interrupt on Sync Advance status bit in the  USBSTS register to one. Software should not write a one to this bit when the  asynchronous schedule is inactive. Doing so will yield undefined results. This  bit is only used in host mode. Writing a one to this bit when device mode is  selected will have undefined results.  */
        unsigned int lr:1;                  /* Light Host/Device Controller Reset (OPTIONAL) .  Read Only. Not Implemented. This field will always be "0".  */
        unsigned int asp1_asp0:2;           /* Asynchronous Schedule Park Mode Count (OPTIONAL) Read/Write.  If the Asynchronous Park Capability bit in the HCCPARAMS register is a one,  then this field defaults to 3h and is R/W. Otherwise it defaults to zero and  is RO. It contains a count of the number of successive transactions the host  controller is allowed to execute from a high-speed queue head on the  Asynchronous schedule before continuing traversal of the Asynchronous  schedule. Valid values are 1h to 3h. Software must not write a zero to this  bit when Park Mode Enable is a one as this will result in undefined behavior.  This field is set to 3h in this implementation and is Read/Write capable.  */
        unsigned int undefined_bit_10:1;
        unsigned int aspe:1;                /* Asynchronous Schedule Park mode Enable. Software uses this bit to enable or disable Park mode. When this bit is one, Park mode is enabled. When this bit is a zero, Park mode is disabled.  This field is set to "1" in this  implementation.  */
        unsigned int undefined_bit_12:1;
        unsigned int sutw:1;                /* Setup Tripwire. This bit is used as a semaphore when the 8 bytes  of setup data read extracted by the firmware. If the setup lockout mode is  off, then there exists a hazard when new setup data arrives and firmware is  copying setup data from the QH for a previous setup packet. This bit is set  and cleared by software and will be cleared by hardware when a hazard exists. */
        unsigned int atdtw:1;               /* Add DTD Tripwire. This bit is used as a semaphore when a dTD is  added to an active (primed) endpoint. This bit is set and cleared by software  and will be cleared by hardware when a hazard exists such that adding a dTD  to a primed endpoint may go unnoticed. */
        unsigned int fs2:1;                 /* Bit 2 of Frame List Size. */
        unsigned int itc:8;                 /* Interrupt Threshold Control .Read/Write. Default 08h. The system software uses this field to set the maximum rate at which the host/device controller will issue interrupts. ITC contains the maximum interrupt interval measured in micro-frames. Valid values are shown below.   Value          Maximum Interrupt Interval  00h              Immediate (no threshold)  01h                1 micro-frame  02h           2 micro-frames  04h          4 micro-frames  08h          8 micro-frames  10h          16 micro-frames  20h         32 micro-frames  40h         64 micro-frames */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_usbcmd_t;

#define USB2_CONTROLLER_2_USB2D_USBSTS_OFFSET 0x144
#define USB2_CONTROLLER_2_USB2D_USBSTS_RESET  0x00001000
#define USB2_CONTROLLER_2_USB2D_USBSTS_WRMASK 0xFFFEDFEF
typedef union usb2_controller_2_usb2d_usbsts_u {
    struct {
        unsigned int ui:1;                  /* USB Interrupt. This bit is set by the Host/Device Controller when  the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) as an interrupt on complete (IOC) bit set. This bit  is also set by the Host/Device Controller when a short packet is detected. A  short packet is when the actual number of bytes received was less than the  expected number of bytes.  */
        unsigned int uei:1;                 /* USB Error Interrupt.  This bit gets set by the Host/Device controller  when completion of a USB transaction results in an error condition. This bit  is set along with the USBINT bit, if the TD on which the error interrupt occurred also ad its interrupt on complete (IOC) bit set.  */
        unsigned int pci:1;                 /* Port Change Detect.  The Host Controller sets this bit to a 1 when on any port a Connect Status occurs, a Port Enable/Disable Change occurs, or the  Force Port Resume bit is set as the result of a J-K transition on the suspended port. The Device Controller sets this bit to a one when the port  controller enters the full or high-speed operational state. When the port  controller exits the full or high-speed operational states due to Reset or  Suspend events, the notification mechanisms are the USB Reset Received bit  and the DCSuspend bits respectively.  This bit is not EHCI compatible.  */
        unsigned int fri:1;                 /* Frame List Rollover.  The Host Controller sets this bit to a 1 when the Frame List Index rolls over from its maximum value to 0. The exact  value at which the rollover occurs depends on the frame list size. For  example. If the frame list size (as programmed in the Frame List Size field  of the USBCMD register) is 1024, the Frame Index Register rolls over every  time FRINDEX [1 3] toggles. Similarly, if the size is 512, the Host  Controller sets this bit to a 1 every time FHINDEX [12] toggles.  Only used  by the host controller.  */
        unsigned int sei:1;                 /* System Error.  This bit is not used in this  implementation and will always be set to "0".  */
        unsigned int aai:1;                 /* Interrupt and Asynchronous Advance.  System software can force the host controller to  issue an interrupt the next time the host controller advances the  asynchronous schedule by writing a one to the Interrupt on Async Advance  Doorbell bit in the USBCMD register. This status bit indicates the assertion  of that interrupt source. Only used by the host controller */
        unsigned int uri:1;                 /* USB Reset Received.  When the device controller detects a USB Reset  and  enters the default state, this bit is set to a 1. Software can write a 1 to  this bit to clear the USB Reset Received status bit.  Only used by the device  controller.  */
        unsigned int sri:1;                 /* SOF Received. When the device controller detects a Start Of (micro) Frame, this bit will be set to a one.  When a SOF is extremely late, the device controller will automatically  set this bit to indicate that an SOF was expected.   Therefore, this bit will be set roughly every 1ms in device FS mode and every 125us in HS mode and will be synchronized to the actual SOF that  is received. Since device controller is initialized to FS before connect,  this bit Will be set at an interval of 1ms during the prelude to the connect and chirp.  In host mode, this bit will be set every 125us and can be used by host controller driver as a time base.  Software writes a 1 to this bit to clear it. This  is a non-EHCI status bit.  */
        unsigned int sli:1;                 /* DCSuspend. When a device controller enters a suspend state from an active state, this bit will be set to a 1.  The device controller  clears the bit upon exiting from a suspend state. Only used by the device  controller.  */
        unsigned int undefined_bit_9:1;
        unsigned int ulpi_int:1;            /* ULPI Interrupt. This bit is set whenever an interrupt is received from ULPI PHY. Software writes 1 to clear it. */
        unsigned int undefined_bit_11:1;
        unsigned int hch:1;                 /* HCHalted. 1 = Default.  This bit is a zero  whenever the Run/Stop bit is a one.  The Host Controller sets this bit to one  after it has stopped  executing because of the Run/Stop bit being set to 0,  either by software or by the Host Controller hardware (e.g. internal error).  Only  used by the host controller.  */
        unsigned int rcl:1;                 /* Reclamation.  This is a read-only status bit used to detect an empty asynchronous schedule. Only used by the host controller.  */
        unsigned int ps:1;                  /* Periodic Schedule Status. This bit reports the current real status of the Periodic Schedule.  When set to zero the periodic schedule is disabled, and if set to one the status is enabled. The Host Controller is not required to immediately disable or enable the Periodic Schedule when software transitions the Periodic Schedule Enable bit in the USBCMD register.   If PS = PSE then: 1 = Periodic Schedule is enabled or 0 = Periodic Schedule is disabled Only used by the host controller.  */
        unsigned int as:1;                  /* Asynchronous Schedule Status.  This bit reports the current real status of the Asynchronous Schedule.   When set to zero the asynchronous schedule status is disabled and  if set to one the status is enabled.  The Host Controller is not required to  immediately disable or enable the Asynchronous Schedule when software transitions the Asynchronous Schedule Enable bit in the USBCMD register.   If AS = ASE:  1= Enable Asynchronous Schedule 0= Disable Asynchronous Schedule Only used by the host controller.  */
        unsigned int naki:1;                /* NAK Interrupt Bit  Read Only. This bit is readonly. It is set by hardware when for a particular endpoint both the TX/RX Endpoint NAK bit and the corresponding TX/RX Endpoint NAK Enable bit are set. This bit is automatically cleared by hardware when the all the enabled TX/RX Endpoint NAK bits are cleared. */
        unsigned int undefined_bit_17:1;
        unsigned int uai:1;                 /* USB Host Asynchronous Interrupt (USBHSTASYNCINT)  R/WC. This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set AND the TD was from the asynchronous schedule. This bit is also set by the Host when a short packet is detected AND the packet is on the asynchronous schedule. A short packet is when the actual number of bytes received was less than the expected number of bytes. This bit is not used by the device controller and will always be zero. */
        unsigned int upa:1;                 /* USB Host Periodic Interrupt (USBHSTPERINT)  R/WC. This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set and the TD was from the periodic schedule. This bit is also set by the Host Controller when a short packet is detected AND the packet is on the periodic schedule. A short packet is when the actual number of bytes received was less than the expected number of bytes. This bit is not used by the device controller and will always be zero. */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_usbsts_t;

#define USB2_CONTROLLER_2_USB2D_USBINTR_OFFSET 0x148
#define USB2_CONTROLLER_2_USB2D_USBINTR_RESET  0x00000000
typedef union usb2_controller_2_usb2d_usbintr_u {
    struct {
        unsigned int ue:1;                  /* USB Interrupt Enable. 1 = Host/device issues an interrupt at the next  interrupt threshold if the USBINT bit in USBSTS = 1.  The interrupt is  acknowledged by software clearing the USBINT bit. */
        unsigned int uee:1;                 /* USB Error Interrupt Enable. 1 = Host controller issues an interrupt at the  next interrupt threshold if the USBERRINT bit in USBSTS = 1.  The interrupt is  acknowledged by software clearing the USBERRINT bit in the USBSTS register.  */
        unsigned int pce:1;                 /* Port Change Detect Enable. 1 = Host/device controller issues an interrupt if  Port Change Detect bit in USBSTS register = 1.  The interrupt is acknowledged  by software clearing the Port Change Detect bit. */
        unsigned int fre:1;                 /* Frame List Rollover Enable. 1 = Host controller issues an interrupt if Frame  List Rollover bit in the USBSTS register = 1. The interrupt is acknowledged  by software clearing the Frame List Rollover bit. Only used by the host  controller.  */
        unsigned int see:1;                 /* System Error Enable. 1 = Host/device controller issues an interrupt if  the System Error bit in USBSTS register = 1. The interrupt is acknowledged by  software clearing the System Error bit.  */
        unsigned int aae:1;                 /* Interrupt on Asynchronous Advance Enable. 1 = the host controller issues an interrupt at the  next interrupt threshold if Interrupt on Async Advance bit in USBSTS register  = 1.  The interrupt is acknowledged by software clearing the Interrupt on  Async Advance bit. Only used by the host controller.  */
        unsigned int ure:1;                 /* USB Reset Enable.1 = Device controller issues an interrupt if USB Reset Received bit in USBSTS register  = 1  The interrupt is acknowledged by software clearing  the USB Reset Received bit. Only used by the device controller.  */
        unsigned int sre:1;                 /* SOF Received Enable. 1 = Device controller issues an interrupt if SOF Received bit in USBSTS register = 1. The interrupt is acknowledged by software clearing  the SOF Received bit.  */
        unsigned int sle:1;                 /* Sleep Enable. 1 = Device controller issues an interrupt if  DCSuspend bit in USBSTS register transitions.  The interrupt is acknowledged by SW by writing a 1 to the DCSuspend bit. Only used by the device controller.  */
        unsigned int undefined_bit_9:1;
        unsigned int ulpie:1;               /* ULPI Interrupt Enable. 1 = USB controller issues an interrupt if ULPI_INT bit in USBSTS register transitions. The interrupt is acknowledged by SW by writing a 1 to the ULPI_INT bit. */
        unsigned int undefined_bits_11_15:5;
        unsigned int nake:1;                /* NAK Interrupt Enable. 1 = USB controller issues an interrupt if NAKI bit in USBSTS register transitions. */
        unsigned int undefined_bit_17:1;
        unsigned int uaie:1;                /* UAIE Interrupt Enable. 1 = USB controller issues an interrupt if UAI bit in USBSTS register transitions. */
        unsigned int upie:1;                /* UPIE Interrupt Enable. 1 = USB controller issues an interrupt if UPA bit in USBSTS register transitions. */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_usbintr_t;

#define USB2_CONTROLLER_2_USB2D_FRINDEX_OFFSET 0x14C
#define USB2_CONTROLLER_2_USB2D_FRINDEX_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_FRINDEX_WRMASK 0xFFFFC000
typedef union usb2_controller_2_usb2d_frindex_u {
    struct {
        unsigned int frindex:14;            /* Frame Index.   The value in this register increments at the end of each time frame (micro-frame).  Bits [N: 3] are used for the Frame List current index. Each location of the frame list is accessed 8 times (frames or micro-frames) before moving to the next index.   The following illustrates values of N based on the value of the Frame List Size field in the USBCMD register, when used in host mode.  USBCMD          [Frame List Size] Number        Elements N    000b                   (1024)                  12    001b                   (512)                   11    010b                   (256)                   10    011b                   (128)                   9    100b            (64)                    8    101b            (32)                    7    110b            (16)                    6    111b            (8)                     5  In device mode the value is the current frame  number of the last frame transmitted. It is not used as an index. In either  mode bits 2:0 indicate the current micro-frame.  */
        unsigned int undefined_bits_14_31:18;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_frindex_t;

#define USB2_CONTROLLER_2_USB2D_PERIODICLISTBASE_OFFSET 0x154
#define USB2_CONTROLLER_2_USB2D_PERIODICLISTBASE_RESET  0x00000000
typedef union usb2_controller_2_usb2d_periodiclistbase_u {
    struct {
        unsigned int undefined_bits_0_11:12;
        unsigned int usbadra:1;             /* Device Address Advance. Default=0.  When this bit is 0, any writes to USBADR are instantaneous.  When this bit is written to a 1 at the same time or before USBADR is written,  the write to the USBADR field is staged and held in a hidden register.  After an IN occurs on endpoint 0 and is ACKed, USBADR will be loaded from the holding register. Hardware will automatically clear this bit on the following conditions: 1) IN is ACKed to endpoint 0. (USBADR is updated from staging register). 2) OUT/SETUP occur to endpoint 0. (USBADR is not updated). 3) Device Reset occurs (USBADR is reset to 0).  Note: After the status phase of the SET_ADDRESS descriptor, the DCD has 2 ms to program the USBADR field. This mechanism will ensure this specification is met when  the DCD can not write of the device address within 2ms from the SET_ADDRESS status phase.  If the DCD writes the USBADR with USBADRA=1 after the SET_ADDRESS data phase  (before the prime of the status phase), the USBADR will be programmed instantly  at the correct time and meet the 2ms USB requirement. */
        unsigned int usbadr:7;              /* Device mode. The upper seven bits of this register represent the device address.  After any controller reset or a USB reset, the device address is set to the default address (0). The default address will match all incoming addresses.  Software shall reprogram the address after receiving a SET_ADDRESS request.  */
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_periodiclistbase_t;

#define USB2_CONTROLLER_2_USB2D_ASYNCLISTADDR_OFFSET 0x158
#define USB2_CONTROLLER_2_USB2D_ASYNCLISTADDR_RESET  0x00000000
typedef union usb2_controller_2_usb2d_asynclistaddr_u {
    struct {
        unsigned int undefined_bits_0_4:5;
        unsigned int epbase:21;             /* Device mode. This register contains the address of the top of the endpoint list in system memory. These bits correspond to memory address signals [31:11], respectively. This field will reference a list of up to 32 Queue Heads (QH). Only used by the device controller. */
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_asynclistaddr_t;

#define USB2_CONTROLLER_2_USB2D_ASYNCTTSTS_OFFSET 0x15C
#define USB2_CONTROLLER_2_USB2D_ASYNCTTSTS_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ASYNCTTSTS_WRMASK 0xFFFFFFFE
typedef union usb2_controller_2_usb2d_asyncttsts_u {
    struct {
        unsigned int ttas:1;                /* Embedded TT Async Buffers Status. (Read Only) This  read only bit will be 1 if one or more transactions are being held in the  embedded TT Async. Buffers. When this bit is a zero, then all outstanding  transactions in the embedded TT have been flushed.  */
        unsigned int ttac:1;                /* Embedded TT Async Buffers Clear. (Read/Write to  set) This field will clear all pending transactions in the embedded TT Async  Buffer(s). The clear will take as much time as necessary to clear buffer  without interfering with a transaction in progress. TTAC will return to zero  after being set by software only after the actual clear occurs.  */
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_asyncttsts_t;

#define USB2_CONTROLLER_2_USB2D_BURSTSIZE_OFFSET 0x160
#define USB2_CONTROLLER_2_USB2D_BURSTSIZE_RESET  0x00000808
typedef union usb2_controller_2_usb2d_burstsize_u {
    struct {
        unsigned int rxpburst:8;            /* Programmable RX Burst Length.  (Read/Write) This register represents the maximum length of a burst in 32-bit words while moving data from the USB bus to system memory. */
        unsigned int txpburst:8;            /* Programmable TX Burst Length.  (Read/Write) This register represents the maximum length of a burst in 32-bit words while moving data from system memory to the USB bus. */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_burstsize_t;

#define USB2_CONTROLLER_2_USB2D_TXFILLTUNING_OFFSET 0x164
#define USB2_CONTROLLER_2_USB2D_TXFILLTUNING_RESET  0x00020000
typedef union usb2_controller_2_usb2d_txfilltuning_u {
    struct {
        unsigned int txschoh:8;             /* Scheduler Overhead.  (Read/Write)  [Default = 0] This register adds an additional fixed offset to the schedule time estimator described above as Tff.  As an approximation, the value chosen for this register should limit the number of back-off events captured in the TXSCHHEALTH to less than 10 per second in a highly utilized bus.  Choosing a value that is too high for this register is not desired as it can needlessly reduce USB utilization. The time unit represented in this register is 1.267us when a device is connected in High-Speed Mode. The time unit represented in this register is 6.333us when a device is connected in Low/Full Speed Mode */
        unsigned int txschhealth:5;         /* Scheduler Health Counter.  (Read/Write To Clear)  [Default = 0] This register increments when the host controller fails to fill the TX latency FIFO to the level programmed by TXFIFOTHRES before running out of time to send the packet before the next Start-Of-Frame. This health counter measures the number of times this occurs to provide feedback to selecting a proper TXSCHOH.  Writing to this register will clear the counter and this counter will max. at 31. */
        unsigned int undefined_bits_13_15:3;
        unsigned int txfifothres:6;         /* FIFO Burst Threshold.  (Read/Write) This register controls the number of data bursts that are posted to the TX latency FIFO in host mode before the packet begins on to the bus.  The minimum value is 2 and this value should be a low as possible to maximize USB performance.  A higher value can be used in systems with unpredicable latency and/or insufficient bandwidth where the FIFO may underrun because the data transferred from the latency FIFO to USB occurs before it can be replenished from system memory.  This value is ignored if the Stream Disable bit in USBMODE register is set. */
        unsigned int undefined_bits_22_31:10;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_txfilltuning_t;

#define USB2_CONTROLLER_2_USB2D_ICUSB_CTRL_OFFSET 0x16C
#define USB2_CONTROLLER_2_USB2D_ICUSB_CTRL_RESET  0x00000000
typedef union usb2_controller_2_usb2d_icusb_ctrl_u {
    struct {
        unsigned int ic_vdd1:3;             /* ICUSB voltage select. It selects which voltage is being supplied to the ICUSB peripheral. 000 -> No voltage 001 -> 1.0V - reserved 010 -> 1.2V - reserved 011 -> 1.5V - reserved 100 -> 1.8V 101 -> 3.0V 110 -> reserved 111 -> reserved The Voltage negotiation should happen between enabling port power (PP) and asserting the run/stop bit in register. */
        unsigned int ic_enb1:1;             /* ICUSB transceiver enable.  This bit enables the ICUSB transceiver .  To enable the interface, the bits PTS must be set to 11 in the PORTSCx. Writing a '1' to this bit selects the IC_USB interface. */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_icusb_ctrl_t;

#define USB2_CONTROLLER_2_USB2D_ULPI_VIEWPORT_OFFSET 0x170
#define USB2_CONTROLLER_2_USB2D_ULPI_VIEWPORT_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ULPI_VIEWPORT_WRMASK 0xF7FF00FF
typedef union usb2_controller_2_usb2d_ulpi_viewport_u {
    struct {
        unsigned int ulpi_data_wr:8;        /* ULPI PHY data write. The data to write to the ULPI PHY register is written here. */
        unsigned int ulpi_data_rd:8;        /* ULPI PHY data read. The data from the ULPI PHY register can be read from here after the read operation completes. */
        unsigned int ulpi_reg_addr:8;       /* ULPI PHY register address. When doing a read or write operation to the ULPI PHY,  the address of the ULPI PHY register being accessed is written to this field. */
        unsigned int ulpi_port:3;           /* ULPI PHY port no. This field should be always written as 0. */
        unsigned int ulpi_sync_state:1;     /* ULPI sync state. (1)  Normal Sync. State. (0) In another state (i.e. carkit, serial, low power) This bit represents the state of the ULPI interface.  */
        unsigned int undefined_bit_28:1;
        unsigned int ulpi_rd_wr:1;          /* ULPI read/write control. (0)  Read; (1)  Write. This bit selects between running a read or write operation. */
        unsigned int ulpi_run:1;            /* ULPI read/write Run. Writing the 1 to this bit will begin the read/write operation.  The bit will automatically transition to 0 after the read/write is complete.  Once this bit is set, the driver can not set it back to 0.  Note: The driver must never execute a wakeup and a read/write operation at the same time. */
        unsigned int ulpi_wakeup:1;         /* ULPI Wakeup. Writing the 1 to this bit will begin the wakeup operation.  The bit will automatically transition to 0 after the wakeup is complete.  Once this bit is set, the driver can not set it back to 0.  Note: The driver must never execute a wakeup and a read/write operation at the same time. */
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_ulpi_viewport_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTNAK_OFFSET 0x178
#define USB2_CONTROLLER_2_USB2D_ENDPTNAK_RESET  0x00000000
typedef union usb2_controller_2_usb2d_endptnak_u {
    struct {
        unsigned int eprn:16;               /* RX Endpoint NAK  R/WC. Each RX endpoint has 1 bit in this field. The bit is set when the device sends a NAK handshake on a received OUT or PING token for the corresponding endpoint. */
        unsigned int eptn:16;               /* TX Endpoint NAK  R/WC. Each TX endpoint has 1 bit in this field. The bit is set when the device sends a NAK handshake on a received IN token for the corresponding endpoint. */
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptnak_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTNAK_ENABLE_OFFSET 0x17C
#define USB2_CONTROLLER_2_USB2D_ENDPTNAK_ENABLE_RESET  0x00000000
typedef union usb2_controller_2_usb2d_endptnak_enable_u {
    struct {
        unsigned int eprne:16;              /* RX Endpoint NAK Enable  R/W. Each bit is an enable bit for the corresponding RX Endpoint NAK bit. If this bit is set and the corresponding RX Endpoint NAK bit is set,  the NAK Interrupt bit is set. */
        unsigned int eptne:16;              /* TX Endpoint NAK Enable  R/W. Each bit is an enable bit for the corresponding TX Endpoint NAK bit. If this bit is set and the corresponding TX Endpoint NAK bit is set,  the NAK Interrupt bit is set. */
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptnak_enable_t;

#define USB2_CONTROLLER_2_USB2D_PORTSC1_OFFSET 0x184
#define USB2_CONTROLLER_2_USB2D_PORTSC1_RESET  0x00001004
#define USB2_CONTROLLER_2_USB2D_PORTSC1_WRMASK 0xE3FF114E
typedef union usb2_controller_2_usb2d_portsc1_u {
    struct {
        unsigned int ccs:1;                 /* Current Connect Status:  In Host Mode: 1=Device is present on port.                0=No device is present (default)  This value reflects the current state of the port, and may not correspond directly to the event that caused the Connect Status Change bit (Bit 1) to be set. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode.  In Device Mode: 1=Attached                    0=Not Attached (default)  A one indicates that the device successfully attached and is operating in either high speed or full speed as indicated by the High Speed Port bit in this register. A zero indicates that the device did not attach successfully or was forcibly disconnected by the software writing a zero to the Run bit in the USBCMD register. It does not state the device being disconnected or suspended.  */
        unsigned int csc:1;                 /* Connect Status Change: 1 =Change in Current Connect Status. 0=No change (default)  In Host Mode:  Indicates a change has occurred in the port's Current Connect Status. The host/device controller sets this bit for all changes to the port device connect status, even if system software has not cleared an existing connect status change. For example, the insertion status changes twice before system software has cleared the changed condition, hub hardware will be 'setting' an already-set bit (i.e., the bit will remain set).  Software clears this bit by writing a one to it. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode.  This bit is undefined in device controller mode.  */
        unsigned int pe:1;                  /* Port Enabled/Disabled: 1=Enable. 0=Disable (default) In Host Mode:  Ports can only be enabled by the host controller as a part of the reset and enable. Software cannot enable a port by writing a one to this field. Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by the host software. Note that the bit status does not change until the port state actually changes. There may be a delay in disabling or enabling a port due to other host controller and bus events.  When the port is disabled, (0b) downstream propagation of data is blocked except for reset. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode.  In Device Mode:  The device port is always enabled. (This bit will  be one)  */
        unsigned int pec:1;                 /* Port Enable/Disable Change: 1=Port enabled/disabled status has changed. 0=No change. In Host Mode:  For the root hub, this bit gets set to a one only when a port is disabled due to disconnect on the port or due to the appropriate conditions existing at the EOF2 point (See Chapter 11 of the USB Specification). Software clears this by writing a one to it. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero.  In Device mode:   The device port is always enabled. (This bit will  be zero)  */
        unsigned int oca:1;                 /* Over-current Active: Not supported */
        unsigned int occ:1;                 /* Over-current Change: Not supported */
        unsigned int fpr:1;                 /* Force Port Resume. 1= Resume detected/driven on port. 0=No resume (K state) detected/driven on port.  In Host Mode:  Software sets this bit to one to drive resume signaling. The Host Controller sets this bit to one if a J-to-K transition is detected while the port is in the Suspend state. When this bit transitions to a one because a J-to-K transition is detected, the Port Change Detect bit in the USBSTS register is also set to one.  This bit will automatically change to zero after the resume sequence is complete. This behavior is different from EHCI where the host controller driver is required to set this bit to a zero after the resume duration is timed in the driver.  Note that when the Host controller owns the port, the resume sequence follows the defined sequence documented in the USB Specification Revision 2.0. The resume signaling (Full-speed 'K') is driven on the port as long as this bit remains a one.  This bit remains a one until the port has switched to the high-speed idle.  Writing a zero has no effect because the port controller will time the resume operation to clear the bit when the port control state switches to HS or FS idle. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode. This bit is not-EHCI compatible.  In Device mode:   After the device has been in Suspend State for 5ms or more, software must set this bit to one to drive resume signaling before clearing. The Device Controller will set this bit to one if a J-to-K transition is detected while the port is in the Suspend state. The bit will be cleared when the device returns to normal operation. Also, when this bit transitions to a one because a J-to-K transition is detected, the Port Change Detect bit in the USBSTS register is also set to one.  Software should ensure that the PHY clock is operational before writing a 1 to this bit to start the resume sequence. This is true for both Device and Host modes. */
        unsigned int susp:1;                /* Port suspend. 1=Port in suspend state. 0=Port not in suspend state.  In Host Mode: Read/Write.  Port Enabled Bit and Suspend bit of this register define the port states as follows:  Bits [Port Enabled, Suspend]    Port State         0x                        Disable    10                        Enable     11                        Suspend  When in suspend state, downstream propagation of data is blocked on this port, except for port reset. The blocking occurs at the end of the current transaction if a transaction was in progress when this bit was written to 1. In the suspend state, the port is sensitive to resume detection. Note that the bit status does not change until the port is suspended and that there may be a delay in suspending a port if there is a transaction currently in progress on the USB. The host controller will unconditionally set this bit to zero when software sets the Force Port Resume bit to zero. A write of zero to this bit is ignored by the host controller. If host software sets this bit to a one when the port is not enabled (i.e. Port enabled bit is a zero) the results are undefined. This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero in host mode. In Device Mode: Read Only. This bit is a read only status bit.  */
        unsigned int pr:1;                  /* This field is zero if Port Power(PP) and B-Host Enable(BHEN) is zero.  In Host Mode: Read/Write. 1=Port is in Reset. 0=Port is not in Reset. When software writes a one to this bit the bus-reset sequence as defined in the USB Specification Revision 2.0 is started. This bit will automatically change to zero after the reset sequence is complete. This behavior is different from EHCI where the host controller driver is required to set this bit to a zero after the reset duration is timed in the driver.   In Device Mode: This bit is a read only status  bit. Device reset from the USB bus is also indicated in the USBSTS register.  */
        unsigned int hsp:1;                 /* When the bit is one, the host/device connected to the port is in high-speed mode and if set to zero, the host/device connected to the port is not in a high-speed mode.  Note: HSP is redundant with PSPD(27:26).  This bit is not defined in the EHCI specification. */
        unsigned int ls:2;                  /* Line state. These bits reflect the current logical levels of the D+ (bit 10) and D- (bit 11) signal lines. The encoding of the bits are: 00b = SE0  01b = J-state  10b = K-state  11b = Undefined  The value of this field is undefined if Port  Power(PP) and B-Host Enable(BHEN) is zero in host mode. In host mode, the use  of line-state by the host controller driver is not necessary (unlike EHCI),  because the port controller state machine and the port routing manage the  connection of LS and FS. In device mode, the use of line-state by the device  controller driver is not necessary.  */
        unsigned int pp:1;                  /* Port Power: The function of this bit depends on the value of the Port Power Switching (PPC) field in the HCSPARAMS register. The behavior is as follows:  PPC                       PP  Operation  0b                           0b Read Only. A device controller with no OTG capability does not have port power control switches.  1b                          1b/0b RW.  Host/OTG controller requires port power control switches.  This bit represents the current setting of the switch (0=off, 1=on).  When power is not available on a port (i.e. PP equals a 0), the port is non-functional and will not report attaches, detaches, etc.  When an over-current condition is detected on a  powered port and PPC is a one, the PP bit in each affected port may be  transitioned by the host controller driver from a one to a zero (removing  power from the port).  */
        unsigned int po:1;                  /* Port Owner. Port owner handoff is not implemented in this design, therefore this bit will  always be 0.  */
        unsigned int pic:2;                 /* Port Indicator Control: This field is not supported in the current  implementation. Please use a GPIO if you wish to use Port Indicators. */
        unsigned int ptc:4;                 /* Port Test Control: Any other value than zero indicates that the port is operating in test mode.    Value                  Specific Test   0000b                Not enabled   0001b                  J_ STATE   0010b             K_STATE   0011b              SEQ_NAK   0100b              Packet   0101b               FORCE_ENABLE   0110b to 1111b         Reserved  Refer to Chapter 7 of the USB Specification  Revision 2.0 for details on each test mode.  */
        unsigned int wkcn:1;                /* Wake on Connect Enable: Writing this bit to a one enables the port to be sensitive to device connects as wake-up events. This field is zero if Port Power(PP)  and B-Host Enable(BHEN) is zero or in device mode.  This bit should only be used when operating in Host mode. Writing this bit to 1 while the controller is working in device mode can result in undefined behaviour.  This bit should not be written to 1 while the  device is connected. After the device connection is detected, this bit should  be cleared to 0. */
        unsigned int wkds:1;                /* Wake on Disconnect Enable: Writing this bit to a one enables the port to be sensitive to device disconnects as wake-up events. This field is zero if Port Power(PP)  and B-Host Enable(BHEN) is zero or in device mode.  This bit should only be used when operating in Host mode. Writing this bit to 1 while the controller is working in device mode can result in undefined behaviour.  This bit should not be written to 1 if there is no  device connected. After the device disconnect is detected, this bit should be  cleared to 0. */
        unsigned int wkoc:1;                /* Default = 0b. Wake on Over-current Enable: Writing this bit to a one enables  the port to be sensitive to over-current conditions as wake-up events. This  field is zero if Port Power(PP) is zero. This bit should only be used when  operating in Host mode. Writing this bit to 1 while the controller is working  in device mode can result in undefined behavior. */
        unsigned int phcd:1;                /* PHY Low Power Suspend - Clock disable: Writing this bit to a 1 will disable the PHY clock. Write a 0 enables it. Reading this bit will indicate the status of the PHY clock. In device mode, the PHY can be put into Low Power Suspend - Clock disable when the device is not running (USBCMD Run/Stop = 0) or the host has signaled suspend (PORTSC SUSPEND = 1). Low power suspend will be cleared automatically when the host has signaled resume. Before forcing a resume from the device, the device controller driver must clear this bit. In host mode, the PHY can be put into Low Power Suspend - Clock disable when the downstream device has been put into suspend mode or when no downstream device is connected. This bit is not defined in the EHCI specification. */
        unsigned int pfsc:1;                /* Port Force Full Speed Connect: Writing this bit to a 1b forces the port to connect at Full Speed only. It disables the chirp sequence that allows the port to identify itself as High Speed. This is useful for testing FS configurations with a HS host, hub or device. This bit is not defined in the EHCI specification. */
        unsigned int srt:1;                 /* Shorten USB Reset Time. Software should never set this to 1. */
        unsigned int pspd:2;                /* This register field indicates the speed at which the port is operating.  00 = Full Speed 01 = Low Speed 10 = High Speed  This bit is not defined in the EHCI specification.   */
        unsigned int ptw:1;                 /* Parallel Transceiver Width. Fixed to 0. This bit is not defined in the EHCI specification.   */
        unsigned int sts:1;                 /* 0 = Serial transceiver not selected. This is the  only value supported. This bit is not defined in the EHCI specification.  */
        unsigned int pts:2;                 /* Parallel transceiver select. This bit is not defined in the EHCI specification.  */
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_portsc1_t;

#define USB2_CONTROLLER_2_USB2D_OTGSC_OFFSET 0x1A4
#define USB2_CONTROLLER_2_USB2D_OTGSC_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_OTGSC_WRMASK 0xFFFF80FF
typedef union usb2_controller_2_usb2d_otgsc_u {
    struct {
        unsigned int vd:1;                  /* VBUS_Discharge. Read/write. Setting this bit  causes Vbus to discharge through a resistor.  */
        unsigned int vc:1;                  /* VBUS Charge. Setting this bit causes the VBus line to be  charged. This is used for VBus pulsing during SRP.  */
        unsigned int undefined_bit_2:1;
        unsigned int ot:1;                  /* OTG Termination. This bit must be set when the OTG device is in device mode, this controls the pulldown on DM.  */
        unsigned int dp:1;                  /* Data Pulsing. Setting this bit causes the pull-up on DP to be  asserted for data pulsing during SRP.  */
        unsigned int idpu:1;                /* USB ID Pullup */
        unsigned int undefined_bits_6_7:2;
        unsigned int id:1;                  /* USB ID: 0 = A-device  1 = B-device */
        unsigned int avv:1;                 /* A VBus Valid. Indicates VBus is above the A VBus valid threshold */
        unsigned int asv:1;                 /* A Session Valid. Indicates VBus is above the A session valid  threshold */
        unsigned int bsv:1;                 /* B Session Valid. Indicates VBus is above the B session valid  threshold */
        unsigned int bse:1;                 /* B session End. Indicates VBus is below the B session end  threshold */
        unsigned int onemst:1;              /* 1 millisecond timer toggle. This bit toggles once per millisecond */
        unsigned int dps:1;                 /* Data Bus Pulsing Status. A 1 indicates data bus pulsing is being detected  on the port.  */
        unsigned int undefined_bit_15:1;
        unsigned int idis:1;                /* USB ID Interrupt Status. This bit is set when a change on the ID input has been detected. Software writes a 1 to clear this bit.  */
        unsigned int avvis:1;               /* A VBus Valid Interrupt Status. This bit is set when VBus has either risen above  or fallen below the VBus valid threshold (4.4 VDC) on an A device. Software  writes a 1 to clear this bit.  */
        unsigned int asvis:1;               /* A Session Valid Interrupt Status. This bit is set when VBus has either risen above  or fallen below the A session valid threshold (0.8 VDC). Software writes a  one to clear this bit.  */
        unsigned int bsvis:1;               /* B Session Valid Interrupt Status. This bit is set when VBus has either risen above  or fallen below the B session valid threshold (0.8 VDC). Software writes a 1  to clear this bit.  */
        unsigned int bseis:1;               /* B Session End Interrupt Status. This bit is set when VBus has fallen below the B  session end threshold. Software writes a 1 to clear this bit . */
        unsigned int onemss:1;              /* 1 millisecond timer Interrupt Status: This bit is set once every millisecond. Software  writes a 1 to clear it. */
        unsigned int dpis:1;                /* Data Pulse Interrupt Status. This bit is set when data bus pulsing occurs on DP or DM.  Data bus pulsing is only detected when USBMODE.CM = Host (11) and PORTSC(0).PortPower = Off (0). Software writes a 1 to clear this bit. */
        unsigned int undefined_bit_23:1;
        unsigned int idie:1;                /* USB ID Interrupt Enable. Setting this bit enables the USB ID interrupt */
        unsigned int avvie:1;               /* A VBus Valid Interrupt Enable. Setting this bit enables the A VBus valid  interrupt */
        unsigned int asvie:1;               /* A Session Valid Interrupt Enable. Setting this bit enables the A session valid  interrupt */
        unsigned int bsvie:1;               /* B Session Valid Interrupt Enable. Setting this bit enables the B session valid  interrupt */
        unsigned int bseie:1;               /* B Session End Interrupt Enable. Setting this bit enables the B session end  interrupt */
        unsigned int onemse:1;              /* 1 millisecond timer Interrupt enable. Setting this bit enables the 1 millisecond timer  interrupt. */
        unsigned int dpie:1;                /* Data Pulse Interrupt Enable. Setting this bit enables the Data pulse interrupt. */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_otgsc_t;

#define USB2_CONTROLLER_2_USB2D_USBMODE_OFFSET 0x1A8
#define USB2_CONTROLLER_2_USB2D_USBMODE_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_USBMODE_WRMASK 0xFFFFFFE0
typedef union usb2_controller_2_usb2d_usbmode_u {
    struct {
        unsigned int cm:2;                  /* Controller Mode: The controller mode will default to an idle state and will need to be initialized to the desired operating mode after reset. This register can only be written once after reset. If it is necessary to switch modes, software must reset the controller by writing to the RESET bit in the USBCMD register before reprogramming this register.  00 = Idle [Default]  01 = Reserved  10 = Device Controller   11 = Host Controller  */
        unsigned int es:1;                  /* Endian Select: Note: For this implementation, this should be  always set to 0 (little endian). */
        unsigned int slom:1;                /* Setup Lockout Mode: In device mode, this bit controls the behavior of the setup lockout mechanism. 0 - Setup lockout is ON (default) 1  Setup lockout is OFF. Firmware requires the  use of setup tripwire semaphore in USB2D_USBCMD register. */
        unsigned int sdis:1;                /* Stream disbable: 1 Streaming is disabled - helpful to avoid overrun/underruns when system load is too high. */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_usbmode_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTSETUPSTAT_OFFSET 0x1AC
#define USB2_CONTROLLER_2_USB2D_ENDPTSETUPSTAT_RESET  0x00000000
typedef union usb2_controller_2_usb2d_endptsetupstat_u {
    struct {
        unsigned int endptsetupstat0:1;     /* Endpoint 0 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat1:1;     /* Endpoint 1 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat2:1;     /* Endpoint 2 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat3:1;     /* Endpoint 3 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat4:1;     /* Endpoint 4 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat5:1;     /* Endpoint 5 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat6:1;     /* Endpoint 6 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat7:1;     /* Endpoint 7 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat8:1;     /* Endpoint 8 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat9:1;     /* Endpoint 9 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat10:1;    /* Endpoint 10 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat11:1;    /* Endpoint 11 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat12:1;    /* Endpoint 12 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat13:1;    /* Endpoint 13 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat14:1;    /* Endpoint 14 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int endptsetupstat15:1;    /* Endpoint 15 Setup Status: For every setup transaction that is received, this bit is set to 1. Software must clear or acknowledge the setup transfer by writing a 1 to it after it has read the setup data from Queue head. The response to a setup packet (as in the order of operations and total response time) is crucial to limit bus time-outs while the setup lock-out mechanism is engaged.   This register is only used in device mode. */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptsetupstat_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTPRIME_OFFSET 0x1B0
#define USB2_CONTROLLER_2_USB2D_ENDPTPRIME_RESET  0x00000000
typedef union usb2_controller_2_usb2d_endptprime_u {
    struct {
        unsigned int perb0:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb1:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb2:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb3:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb4:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb5:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb6:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb7:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb8:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb9:1;               /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb10:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb11:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb12:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb13:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb14:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int perb15:1;              /* Prime Endpoint Receive Buffer: This bit is used to request that a buffer prepared for a receive operation when a USB host initiates a USB OUT transaction to this endpoint. Software should write a one to this bit whenever posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. Hardware will clear this bit when this endpoint is successfully primed.  This is only used in device mode. */
        unsigned int petb0:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb1:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb2:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb3:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb4:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb5:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb6:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb7:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb8:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb9:1;               /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb10:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb11:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb12:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb13:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb14:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
        unsigned int petb15:1;              /* Prime Endpoint Transmit Buffer: This bit is used to request that a buffer prepared for a transmit operation in order to respond to a USB IN/INTERRUPT transaction on this endpiont. Software should write a "1" to this bit when posting a new transfer descriptor to this endpoint. Hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. Hardware will clear this bit when this endpoint is successfully primed. This is only used in device mode. */
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptprime_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTFLUSH_OFFSET 0x1B4
#define USB2_CONTROLLER_2_USB2D_ENDPTFLUSH_RESET  0x00000000
typedef union usb2_controller_2_usb2d_endptflush_u {
    struct {
        unsigned int ferb0:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb1:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb2:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb3:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb4:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb5:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb6:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb7:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb8:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb9:1;               /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb10:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb11:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb12:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb13:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb14:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int ferb15:1;              /* Flush Endpoint Receive Buffer: Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb0:1;               /* Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb1:1;               /*  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb2:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb3:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb4:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb5:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb6:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb7:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb8:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb9:1;               /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb10:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb11:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb12:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb13:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb14:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
        unsigned int fetb15:1;              /* Flush Endpoint Transmit Buffer:  Writing a one to this bit causes the associated endpoint to clear any primed buffers. If a packet is in progress for the associated endpoint that transfer will continue until completion. Hardware clears this register after the endpoint flush operation is successful.  This is only used in device mode. */
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptflush_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTSTATUS_OFFSET 0x1B8
#define USB2_CONTROLLER_2_USB2D_ENDPTSTATUS_RESET  0x00000000
typedef union usb2_controller_2_usb2d_endptstatus_u {
    struct {
        unsigned int erbr0:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr1:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr2:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr3:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr4:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr5:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr6:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr7:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr8:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr9:1;               /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr10:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr11:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr12:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr13:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr14:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int erbr15:1;              /* Endpoint Receive Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr0:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr1:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr2:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr3:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr4:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr5:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr6:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr7:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr8:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr9:1;               /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr10:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr11:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr12:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr13:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr14:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
        unsigned int etbr15:1;              /* Endpoint Transmit Buffer Ready: One bit for each endpoint indicates status of the respective endpoint buffer. This bit is set to a one by the hardware as a response to receiving a command from a corresponding bit in the ENDPTPRIME register. There will always be a delay between setting a bit in the ENDPTPRIME register and endpoint indicating ready. This delay ime varies based upon the current USB traffic and the number of bits set in the ENDPTPRIME register. Buffer ready is cleared by USB reset, by the USB DMA system, or through the ENDPTFLUSH register.  This is only used in device mode. */
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptstatus_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCOMPLETE_OFFSET 0x1BC
#define USB2_CONTROLLER_2_USB2D_ENDPTCOMPLETE_RESET  0x00000000
typedef union usb2_controller_2_usb2d_endptcomplete_u {
    struct {
        unsigned int erce0:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce1:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce2:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce3:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce4:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce5:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce6:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce7:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce8:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce9:1;               /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce10:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce11:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce12:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce13:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce14:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int erce15:1;              /* Endpoint Receive Complete Event: Each bit indicates a received event (OUT/SETUP) occurred and software should read the corresponding endpoint queue to determine the transfer status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register. This is only used in device mode. */
        unsigned int etce0:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce1:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce2:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce3:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce4:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce5:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce6:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce7:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce8:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce9:1;               /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce10:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce11:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce12:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce13:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce14:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
        unsigned int etce15:1;              /* Endpoint Transmit Complete Event: Each bit indicates a transmit event (IN/INTERRUPT) occurred and software should read the corresponding endpoint queue to determine the endpoint status. If the corresponding IOC bit is set in the Transfer Descriptor, then this bit will be set simultaneously with the USBINT. Writing a one clears the corresponding bit in this register.  This is only used in device mode. */
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptcomplete_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL0_OFFSET 0x1C0
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL0_RESET  0x00800080
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL0_WRMASK 0xFF72FF72
typedef union usb2_controller_2_usb2d_endptctrl0_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: Software can write a one to this bit to force the  endpoint to return a STALL handshake to the Host. It will continue returning  STALL until the bit is cleared by software or it will automatically be  cleared upon receipt of a new SETUP request.  */
        unsigned int undefined_bit_1:1;
        unsigned int rxt:2;                 /* RX Endpoint Type. Endpoint 0 is fixed as a Control Endpoint.  */
        unsigned int undefined_bits_4_6:3;
        unsigned int rxe:1;                 /*  RX Endpoint Enable. Endpoint 0 is always  enabled.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: Software can write a one to this bit to force the  endpoint to return a STALL handshake to the Host. It will continue returning  STALL until the bit is cleared by software or it will automatically be  cleared upon receipt of a new SETUP request.  */
        unsigned int undefined_bit_17:1;
        unsigned int txt:2;                 /* TX Endpoint Type. Endpoint0 is fixed as a Control Endpoint.  */
        unsigned int undefined_bits_20_22:3;
        unsigned int txe:1;                 /* TX Endpoint Enable. Endpoint 0 is always  enabled.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl0_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL1_OFFSET 0x1C4
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL1_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL1_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl1_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above,  */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl1_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL2_OFFSET 0x1C8
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL2_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL2_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl2_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl2_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL3_OFFSET 0x1CC
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL3_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL3_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl3_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl3_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL4_OFFSET 0x1D0
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL4_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL4_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl4_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl4_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL5_OFFSET 0x1D4
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL5_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL5_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl5_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl5_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL6_OFFSET 0x1D8
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL6_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL6_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl6_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl6_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL7_OFFSET 0x1DC
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL7_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL7_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl7_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl7_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL8_OFFSET 0x1E0
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL8_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL8_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl8_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl8_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL9_OFFSET 0x1E4
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL9_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL9_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl9_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl9_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL10_OFFSET 0x1E8
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL10_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL10_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl10_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl10_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL11_OFFSET 0x1EC
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL11_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL11_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl11_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl11_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL12_OFFSET 0x1F0
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL12_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL12_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl12_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl12_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL13_OFFSET 0x1F4
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL13_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL13_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl13_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl13_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL14_OFFSET 0x1F8
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL14_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL14_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl14_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl14_t;

#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL15_OFFSET 0x1FC
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL15_RESET  0x00000000
#define USB2_CONTROLLER_2_USB2D_ENDPTCTRL15_WRMASK 0xFFFDFFFD
typedef union usb2_controller_2_usb2d_endptctrl15_u {
    struct {
        unsigned int rxs:1;                 /* RX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt a SETUP request if this Endpoint  is configured as a Control Endpoint, Software can write a one to this bit to  force the endpoint to return a STALL handshake to the Host. It will continue  to returning STALL until this bit is either cleared by software or  automatically cleared as above. */
        unsigned int rxd:1;                 /* This is fixed to 0. */
        unsigned int rxt:2;                 /* RX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_4:1;
        unsigned int rxi:1;                 /* RX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always accept data packet regardless of  their data PID.  */
        unsigned int rxr:1;                 /* RX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint, software must write a one to this bit in order to synchronize  the data PIDs between the host and device.  */
        unsigned int rxe:1;                 /* RX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_8_15:8;
        unsigned int txs:1;                 /* TX Endpoint Stall: This bit will be set automatically upon receipt of  a SETUP request if this Endpoint is not configured as a Control Endpoint. It  will be cleared automatically upon receipt of a SETUP request if this  Endpoint is configured as a Control Endpoint. Software can write a one to  this bit to force the endpoint to return a STALL handshake to the Host. It  will continue to returning STALL until this bit is either cleared by software  or automatically cleared as above.  */
        unsigned int txd:1;                 /* This is fixed to 0. */
        unsigned int txt:2;                 /* TX Endpoint Type: 00 = Control    01 = Isochronous                10 = Bulk               11 = Interrupt */
        unsigned int undefined_bit_20:1;
        unsigned int txi:1;                 /* TX Data Toggle Inhibit: This bit is only used for test and should always  be written as zero. Writing a one to this bit will cause this endpoint to  ignore the data toggle sequence and always transmit DATA0 for a data packet.  */
        unsigned int txr:1;                 /* TX Data Toggle Reset: Whenever a configuration event is received for  this Endpoint software must write a one to this bit in order to synchronize  the data PIDs between the Host and device.  */
        unsigned int txe:1;                 /* TX Endpoint Enable. An Endpoint should be enabled only after it has  been configured.  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb2_controller_2_usb2d_endptctrl15_t;

#define USB3_IF_USB_SUSP_CTRL_OFFSET 0x400
#define USB3_IF_USB_SUSP_CTRL_RESET  0x00000000
#define USB3_IF_USB_SUSP_CTRL_WRMASK 0xFFFFFE3E
typedef union usb3_if_usb_susp_ctrl_u {
    struct {
        unsigned int usb_wakeup_int_sts:1;  /* USB wakeup interrupt status This bit is set whenever USB wakes up from suspend (a wakeup event is generated). Software must write a 1 to clear this bit. Note that during the wakeup sequence, PHY clocks will be resumed from suspend. Software can check when the PHY clocks are resumed by reading the bit USB_PHY_CLK_VALID. There is also a separate interrupt generated when PHY clock is resumed if USB_PHY_CLK_VALID_INT_EN is set. During the wakeup sequence, first USB_WAKEUP_INT_STS will be set, and it will take some time for the PHY clock to resume, which can be detected by checking USB_PHY_CLK_VALID. */
        unsigned int usb_wakeup_int_enb:1;  /* USB wakeup interrupt enable If this bit is enabled, interrupt is generated whenever USB wakeup event is generated. */
        unsigned int usb_wake_on_resume_en:1; /* Wake on resume enable If this bit is enabled, USB will wakeup from suspend whenever a resume event is detected on USB. This is valid for both USB device and USB host modes. */
        unsigned int usb_wake_on_cnnt_en_dev:1; /* Wake on Connect Enable (device mode) When enabled (1), USB device will wakeup from suspend on a connect event. This is only valid when USB controller is in device mode, it is not applicable when USB controller is in host mode. */
        unsigned int usb_wake_on_discon_en_dev:1; /* Wake on Disconnect Enable (device mode) When enabled (1), USB device will wakeup from suspend on a disconnect event. This is only valid when USB controller is in device mode, it is not applicable when USB controller is in host mode. */
        unsigned int usb_susp_clr:1;        /* Suspend Clear Software must write a 1 to this bit to bring the PHY out of suspend mode. This is used when the software stops the PHY clock during suspend and then wants to initiate a resume. Software should also write 0 to clear it. NOTE: It is required that software generate a  positive pulse on this bit to guarantee proper operation. */
        unsigned int usb_clken:1;           /* USB AHB clock enable status. Indicates whether the AHB clock to the USB controller is enabled or not. If AHB clock to USB controller is enabled, this bit is set to 1, else it is set to 0. NOTE: even when this is set to 0, all essential blocks that are required to resume USB clocks from suspend will be active and their AHB clock will not be suspended. */
        unsigned int usb_phy_clk_valid:1;   /* USB PHY clock valid status This bit indicates whether the USB PHY is generating a valid clock to  the USB controller. If USB PHY clock is running, this bit is set to 1, else it is set to 0. */
        unsigned int usb_phy_clk_valid_int_sts:1; /* USB PHY clock valid interrupt status This bit is set whenever USB PHY clock is waked up from suspend. Software must write a 1 to clear this bit. */
        unsigned int usb_phy_clk_valid_int_enb:1; /* USB PHY clock valid interrupt enable If this bit is enabled, interrupt is generated whenever USB clocks are resumed from a suspend. */
        unsigned int usb_susp_pol:1;        /* Polarity of the suspend signal going to USB PHY. 0 = Active low (default) 1 = Active high This should not be changed by software. */
        unsigned int utmip_reset:1;         /* Reset going to UTMIP PHY (active high). This should be set to 1 whenever programming the UTMIP config registers. It should be cleared to 0 after the programming of UTMIP config registers is done. UTMIP config registers should be programmed only once before doing any transactions on USB. The UTMIP PHY registers should be programmed while UTMIP is in reset. */
        unsigned int utmip_phy_enb:1;       /* Enable UTMIP PHY mode Set this to 1 if using UTMIP PHY. Otherwise set this to 0. */
        unsigned int icusb_phy_enb:1;       /* Enable ICUSB PHY mode Setting this will enable the PLLU output clock when ICUSB is not in suspend */
        unsigned int undefined_bit_14:1;
        unsigned int icusb_mod_clk_enb:1;   /* ICUSB module clock enable. Enables transceiver clock to USB controller when in ICUSB mode. After setting ICUSB_PHY_ENB, software needs to wait until PLLU output is  stable before setting ICUSB_MOD_CLK_ENB to ENABLE. This will be reset to DISABLE whenever ICUSB is in suspend. Software needs to enable it after ICUSB comes out of suspend after waiting for PLLU output to be stable again. */
        unsigned int usb_wakeup_debounce_count:3; /* USB PHY wakeup debounce counter USB will debounce any wakeup event by the number of clocks programmed  in this counter. A value of 0 results in no debounce. */
        unsigned int undefined_bits_19_31:13;
    };

    uint32_t reg32;
} usb3_if_usb_susp_ctrl_t;

#define USB3_IF_USB_PHY_VBUS_SENSORS_OFFSET 0x404
#define USB3_IF_USB_PHY_VBUS_SENSORS_RESET  0x00000000
#define USB3_IF_USB_PHY_VBUS_SENSORS_WRMASK 0xF9F9F9F9
typedef union usb3_if_usb_phy_vbus_sensors_u {
    struct {
        unsigned int b_sess_end_int_en:1;   /* B_SESS_END interrupt enable If this field is set to 1, an interrupt is generated whenever B_SESS_END_CHG_DET is set to 1. */
        unsigned int b_sess_end_chg_det:1;  /* B_SESS_END change detect. This field is set by hardware whenever a change is detected in the value of B_SESS_END. software writes a 1 to clear it */
        unsigned int b_sess_end_sts:1;      /* B_SESS_END status This is set to 1 whenever B_SESS_END sensor output is 1. */
        unsigned int b_sess_end_sw_en:1;    /* B_SESS_END software enable Enable Software Controlled B_SESS_END Software sets this bit to drive the value in B_SESS_END_SW_VALUE to the USB controller. */
        unsigned int b_sess_end_sw_value:1; /* B_SESS_END software value Software should write the appropriate value (1/0) to set/unset the B_SESS_END status. This is only valid when B_SESS_END_SW_EN is set. */
        unsigned int b_sess_end_deb_sel_b:1; /* B_SESS_END debounce A/B select Selects between the two debounce values  UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. */
        unsigned int b_sess_end_wakeup_en:1; /* B_SESS_END wakeup enable If this bit is enabled, USB will wakeup from suspend whenever a change is detected on B_SESS_END. */
        unsigned int undefined_bit_7:1;
        unsigned int b_sess_vld_int_en:1;   /* B_SESS_VLD interrupt enable If this field is set to 1, an interrupt is generated whenever B_SESS_VLD_CHG_DET is set to 1. */
        unsigned int b_sess_vld_chg_det:1;  /* B_SESS_VLD change detect. This field is set by hardware whenever a change is detected in the value of B_SESS_VLD. software writes a 1 to clear it */
        unsigned int b_sess_vld_sts:1;      /* B_SESS_VLD status This is set to 1 whenever B_SESS_VLD sensor output is 1. */
        unsigned int b_sess_vld_sw_en:1;    /* B_SESS_VLD software enable Enable Software Controlled B_SESS_VLD. Software sets this bit to drive the value in B_SESS_VLD_SW_VALUE to the USB controller. */
        unsigned int b_sess_vld_sw_value:1; /* B_SESS_VLD software value Software should write the appropriate value (1/0) to set/unset the B_SESS_VLD status. This is only valid when B_SESS_VLD_SW_EN is set. */
        unsigned int b_sess_vld_deb_sel_b:1; /* B_SESS_VLD debounce A/B select Selects between the two debounce values  UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. */
        unsigned int b_sess_vld_wakeup_en:1; /* B_SESS_VLD wakeup enable If this bit is enabled, USB will wakeup from suspend whenever a change is detected on B_SESS_VLD. */
        unsigned int undefined_bit_15:1;
        unsigned int a_sess_vld_int_en:1;   /* A_SESS_VLD interrupt enable If this field is set to 1, an interrupt is generated whenever A_SESS_VLD_CHG_DET is set to 1. */
        unsigned int a_sess_vld_chg_det:1;  /* A_SESS_VLD change detect. This field is set by hardware whenever a change is detected in the value of A_SESS_VLD. software writes a 1 to clear it */
        unsigned int a_sess_vld_sts:1;      /* A_SESS_VLD status This is set to 1 whenever A_SESS_VLD sensor output is 1. */
        unsigned int a_sess_vld_sw_en:1;    /* A_SESS_VLD software enable Enable Software Controlled A_SESS_VLD. Software sets this bit to drive the value in A_SESS_VLD_SW_VALUE to the USB controller. */
        unsigned int a_sess_vld_sw_value:1; /* A_SESS_VLD software value Software should write the appropriate value (1/0) to set/unset the A_SESS_VLD status. This is only valid when A_SESS_VLD_SW_EN is set. */
        unsigned int a_sess_vld_deb_sel_b:1; /* A_SESS_VLD debounce A/B select Selects between the two debounce values  UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. */
        unsigned int a_sess_vld_wakeup_en:1; /* A_SESS_VLD wakeup enable If this bit is enabled, USB will wakeup from suspend whenever a change is detected on A_SESS_VLD. */
        unsigned int undefined_bit_23:1;
        unsigned int a_vbus_vld_int_en:1;   /* A_VBUS_VLD interrupt enable If this field is set to 1, an interrupt is generated whenever A_VBUS_VLD_CHG_DET is set to 1. */
        unsigned int a_vbus_vld_chg_det:1;  /* A_VBUS_VLD change detect. This field is set by hardware whenever a change is detected in the value of A_VBUS_VLD. software writes a 1 to clear it */
        unsigned int a_vbus_vld_sts:1;      /* A_VBUS_VLD status This is set to 1 whenever A_VBUS_VLD sensor output is 1. */
        unsigned int a_vbus_vld_sw_en:1;    /* A_VBUS_VLD software enable Enable Software Controlled A_VBUS_VLD. Software sets this bit to drive the value in A_VBUS_VLD_SW_VALUE to the USB controller. */
        unsigned int a_vbus_vld_sw_value:1; /* A_VBUS_VLD software value Software should write the appropriate value (1/0) to set/unset the A_VBUS_VLD status. This is only valid when A_VBUS_VLD_SW_EN is set. */
        unsigned int a_vbus_vld_deb_sel_b:1; /* A_VBUS_VLD debounce A/B select Selects between the two debounce values  UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. */
        unsigned int a_vbus_vld_wakeup_en:1; /* A_VBUS_VLD wakeup enable If this bit is enabled, USB will wakeup from suspend whenever a change is detected on A_VBUS_VLD. */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} usb3_if_usb_phy_vbus_sensors_t;

#define USB3_IF_USB_PHY_VBUS_WAKEUP_ID_OFFSET 0x408
#define USB3_IF_USB_PHY_VBUS_WAKEUP_ID_RESET  0x00000040
#define USB3_IF_USB_PHY_VBUS_WAKEUP_ID_WRMASK 0xFFF9F979
typedef union usb3_if_usb_phy_vbus_wakeup_id_u {
    struct {
        unsigned int id_int_en:1;           /* ID interrupt enable If this field is set to 1, an interrupt is generated whenever ID_CHG_DET is set to 1. */
        unsigned int id_chg_det:1;          /* ID change detect. This field is set by hardware whenever a change is detected in the value of ID. software writes a 1 to clear it */
        unsigned int id_sts:1;              /* ID status This is set to 1 whenever ID sensor output is 1. */
        unsigned int id_sw_en:1;            /* ID software enable Enable Software Controlled ID. Software sets this bit to drive the value in ID_SW_VALUE to the USB controller */
        unsigned int id_sw_value:1;         /* ID software value Software should write the appropriate value (1/0) to set/unset the ID status. This is only valid when ID_SW_EN is set. */
        unsigned int id_deb_sel_b:1;        /* ID debounce A/B select Selects between the two debounce values  UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. */
        unsigned int id_pu:1;               /* ID pullup enable. Set to 1. */
        unsigned int static_gpi:1;          /* Static GPI status */
        unsigned int vbus_wakeup_int_en:1;  /* VBUS wakeup interrupt enable If this field is set to 1, an interrupt is generated whenever VBUS_WAKEUP_CHG_DET is set to 1. */
        unsigned int vbus_wakeup_chg_det:1; /* VBUS wakeup change detect. This field is set by hardware whenever a change is detected in the value of VBUS_WAKEUP. software writes a 1 to clear it */
        unsigned int vbus_wakeup_sts:1;     /* VBUS wakeup status This is set to 1 whenever VBUS_WAKEUP sensor output is 1. */
        unsigned int vbus_wakeup_sw_en:1;   /* VBUS wakeup software enable Enable Software Controlled VBUS_WAKEUP. Software sets this bit to drive the value in VBUS_WAKEUP_SW_VALUE to the USB controller. */
        unsigned int vbus_wakeup_sw_value:1; /* VBUS wakeup software value Software should write the appropriate value (1/0) to set/unset the VBUS_WAKEUP status. This is only valid when VBUS_WAKEUP_SW_EN is set. */
        unsigned int vbus_wakeup_deb_sel_b:1; /* VBUS_WAKEUP debounce A/B select Selects between the two debounce values  UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. */
        unsigned int undefined_bits_14_15:2;
        unsigned int vdat_det_int_en:1;     /* VDAT_DET interrupt enable If this field is set to 1, an interrupt is generated whenever VDAT_DET_CHG_DET is set to 1. */
        unsigned int vdat_det_chg_det:1;    /* VDAT_DET change detect. This field is set by hardware whenever a change is detected in the value of VDAT_DET. software writes a 1 to clear it */
        unsigned int vdat_det_sts:1;        /* VDAT_DET status This is set to 1 whenever VDAT_DET sensor output is 1. */
        unsigned int vdat_det_sw_en:1;      /* VDAT_DET software enable Enable Software Controlled VDAT_DET. Software sets this bit to drive the value in VDAT_DET_SW_VALUE to the USB controller */
        unsigned int vdat_det_sw_value:1;   /* VDAT_DET software value Software should write the appropriate value (1/0) to set/unset the VDAT_DET status. This is only valid when VDAT_DET_SW_EN is set. */
        unsigned int vdat_det_deb_sel_b:1;  /* VDAT_DET debounce A/B select Selects between the two debounce values  UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. */
        unsigned int undefined_bits_22_29:8;
        unsigned int vbus_wakeup_wakeup_en:1; /* VBUS_WAKEUP wakeup enable If this bit is enabled, USB will wakeup from suspend whenever a change is detected on VBUS_WAKEUP. */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} usb3_if_usb_phy_vbus_wakeup_id_t;

#define USB3_IF_USB_PHY_ALT_VBUS_STS_OFFSET 0x40C
#define USB3_IF_USB_PHY_ALT_VBUS_STS_RESET  0x00000000
#define USB3_IF_USB_PHY_ALT_VBUS_STS_WRMASK 0xFFFFFF80
typedef union usb3_if_usb_phy_alt_vbus_sts_u {
    struct {
        unsigned int vbus_wakeup_alt:1;     /* Vbus wakeup alternate status */
        unsigned int a_vbus_vld_alt:1;      /* A_VBUS_VLD alternate status */
        unsigned int static_gpi_alt:1;      /* Static GPI alternate status */
        unsigned int b_sess_end_alt:1;      /* B_SESS_END alternate status */
        unsigned int id_dig_alt:1;          /* ID alternate status */
        unsigned int b_sess_vld_alt:1;      /* B_SESS_VLD alternate status */
        unsigned int a_sess_vld_alt:1;      /* A_SESS_VLD alternate status */
        unsigned int undefined_bits_7_31:25;
    };

    uint32_t reg32;
} usb3_if_usb_phy_alt_vbus_sts_t;

#define USB3_IF_ICUSB_XCVR_CFG_OFFSET 0x414
#define USB3_IF_ICUSB_XCVR_CFG_RESET  0x00100007
#define USB3_IF_ICUSB_XCVR_CFG_WRMASK 0x00FFFFFF
typedef union usb3_if_icusb_xcvr_cfg_u {
    struct {
        unsigned int icusb_pd_tx:1;         /* ICUSB PHY Low/full-speed driver power down */
        unsigned int icusb_pd_dr:1;         /* ICUSB PHY Differential receiver power down */
        unsigned int icusb_pd_zi:1;         /* ICUSB PHY Single-ended receiver power down */
        unsigned int icusb_iddq:1;          /* ICUSB PHY IDDQ shutdown mode */
        unsigned int undefined_bits_4_6:3;
        unsigned int icusb_sel_diff_rcvr:1; /* ICUSB differential receiver select */
        unsigned int icusb_slew:6;          /* ICUSB PHY FS/LS slew rate control */
        unsigned int undefined_bits_14_15:2;
        unsigned int icusb_drv:4;           /* ICUSB PHY Drive strength offset */
        unsigned int icusb_calout_en:1;     /* ICUSB PHY auto-calibration enable */
        unsigned int undefined_bits_21_23:3;
        unsigned int icusb_calout:8;        /* ICUSB PHY calibration code */
    };

    uint32_t reg32;
} usb3_if_icusb_xcvr_cfg_t;

#define USB3_IF_USB_INTER_PKT_DELAY_CTRL_OFFSET 0x420
#define USB3_IF_USB_INTER_PKT_DELAY_CTRL_RESET  0x00000012
typedef union usb3_if_usb_inter_pkt_delay_ctrl_u {
    struct {
        unsigned int ip_delay_tx2tx_hs:6;   /* HS Tx to Tx inter-packet delay. This is valid only for UTMIP PHY Software should not change this. */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} usb3_if_usb_inter_pkt_delay_ctrl_t;

#define USB3_IF_USB_DEBUG_OFFSET 0x480
#define USB3_IF_USB_DEBUG_RESET  0x00000000
typedef union usb3_if_usb_debug_u {
    struct {
        unsigned int undefined_bits_0_4:5;
        unsigned int usb_buf_ahb_if_sel:1;  /* Route USB buffers to AHB interface for debug. When this is set to 1, normal USB operations cannot be done. */
        unsigned int usb_buf_low32bits_sel:1; /* Lower 32-bits select. Only valid for Tx and Rx memories that have 36-bit interface. When 0, selects upper 4-bits. When 1, selects lower 32-bits. */
        unsigned int undefined_bits_7_31:25;
    };

    uint32_t reg32;
} usb3_if_usb_debug_t;

#define USB3_IF_USB_PHY_SELF_TEST_OFFSET 0x484
#define USB3_IF_USB_PHY_SELF_TEST_RESET  0x10150008
#define USB3_IF_USB_PHY_SELF_TEST_WRMASK 0xFFFF7FF3
typedef union usb3_if_usb_phy_self_test_u {
    struct {
        unsigned int tstenb:1;              /* Place UTMIP in test mode. This does not start the test. */
        unsigned int tston:1;               /* Sw writes a 1 to start the test. It writes a 0 to  end the test */
        unsigned int tstend:1;              /* Goes to 1 when the test finishes. At that time,  TSTPASS is valid and indicates the tests pass/fail status */
        unsigned int tstps:1;               /* When test is started, this status signal starts as  1 and is set to 0 if an error is detected. Can be sampled when TSTEND is  asserted. */
        unsigned int xcvr:2;                /* XCVR_select: */
        unsigned int term:1;                /* Term_select */
        unsigned int undefined_bit_7:1;
        unsigned int opmode:2;              /* Operational Mode */
        unsigned int undefined_bits_10_11:2;
        unsigned int dmpd:1;                /* Enable pulldown on DM */
        unsigned int dppd:1;                /* Enable pulldown on DP */
        unsigned int sof_en:1;              /* Enable transmission of SOF */
        unsigned int discon:1;              /* Status of Disconnect signal from PHY */
        unsigned int ipkt_dly:8;            /* Interpacket delay between two consecutive packets in no of 60 Mhz cycles */
        unsigned int test_pkt_cnt:8;        /* No of test packets to be sent. 0 = infinite, continue sending packets until test mode is disabled. */
    };

    uint32_t reg32;
} usb3_if_usb_phy_self_test_t;

#define USB3_IF_USB_PHY_SELF_TEST2_OFFSET 0x488
#define USB3_IF_USB_PHY_SELF_TEST2_RESET  0x00000000
typedef union usb3_if_usb_phy_self_test2_u {
    struct {
        unsigned int test_sof_j:1;          /* If enabled, send SOF with EOP of J, else send SOF with EOP of K */
        unsigned int send_test_j:1;         /* Enable TEST_K transmission */
        unsigned int send_test_k:1;         /* Enable TEST_J transmission */
        unsigned int send_test_pkt:1;       /* Enable transmission of test packets */
        unsigned int rcv_test_pkt:1;        /* Enable reception of test packets */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} usb3_if_usb_phy_self_test2_t;

#define USB3_IF_USB_PHY_SELF_TEST_DEBUG_OFFSET 0x48C
#define USB3_IF_USB_PHY_SELF_TEST_DEBUG_RESET  0x00000000
#define USB3_IF_USB_PHY_SELF_TEST_DEBUG_WRMASK 0xFFFC00C0
typedef union usb3_if_usb_phy_self_test_debug_u {
    struct {
        unsigned int fail_rx_byte:6;        /* Failed RX byte index: Points to the Rx byte no. in  the current packet which fails */
        unsigned int undefined_bits_6_7:2;
        unsigned int fail_pkt_no:8;         /* Failed packet no: Points to the failed packet no */
        unsigned int rxvhf:1;               /* Rx valid/Rx validh fail: Indicates that the  Rxvalid/Rxvalidh werent generated according to protocol */
        unsigned int rxcmf:1;               /* RX compare fail. Comparison on RX data failed. */
        unsigned int undefined_bits_18_31:14;
    };

    uint32_t reg32;
} usb3_if_usb_phy_self_test_debug_t;

#define USB3_UTMIP_PLL_CFG0_OFFSET 0x800
#define USB3_UTMIP_PLL_CFG0_RESET  0x00280180
typedef union usb3_utmip_pll_cfg0_u {
    struct {
        unsigned int utmip_pll_lockenable:1; /* LOCK_ENABLE input of USB_PHY PLL. Normally only used during test. See cell specification. */
        unsigned int utmip_pll_locksel:6;   /* LOCKSEL[5:0] input of USB_PHY PLL. Used in test modes only. See cell specification. */
        unsigned int utmip_pll_vcomultby2:1; /* VCOMULTBY2 control of the UTMIP PHY PLL. Recommended setting is on. Additional divide by 2 on the  VCO feedback. Which is setting the bit to 1. See cell spec. */
        unsigned int utmip_pll_mdiv:8;      /* MDIV[7:0] input of the USB_PHY PLL. This is the predivide on the PLL.  0x0 is not allowed. See cell specification. */
        unsigned int utmip_pll_ndiv:8;      /* NDIV[7:0] input of USB_PHY PLL.  This is the feedback divider on the VCO feedback.  0x0 is not allowed. See cell specification. */
        unsigned int utmip_pll_pdiv:3;      /* PDIV[2:0] input of the USB_PHY PLL. Reserved. Keep at 0x0. Currently there is no post divider on this PLL.  See cell specification. */
        unsigned int utmip_pll_pdivrst:1;   /* PDIVRST of the UTMIP PHY PLL. Reserved. Keep at 0x0. Currently there is no post divider on this PLL.  See cell specification. */
        unsigned int utmip_pll_select:3;    /* Selects which of the eight 60MHz clock phases to produce at the output  of the USB PHY PLL. This is for a test mode. See cell specification. */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} usb3_utmip_pll_cfg0_t;

#define USB3_UTMIP_PLL_CFG1_OFFSET 0x804
#define USB3_UTMIP_PLL_CFG1_RESET  0x182000C0
typedef union usb3_utmip_pll_cfg1_u {
    struct {
        unsigned int utmip_xtal_freq_count:12; /* Determines the time to wait until the output of USB_PHY PLL is considered stable.  */
        unsigned int utmip_force_pll_active_powerdown:1; /* Force USB_PHY PLL pll_active input off. (Overrides FORCE_PLL_ACTIVE_POWERUP.) */
        unsigned int utmip_force_pll_active_powerup:1; /* Force USB_PHY PLL pll_active input on.  */
        unsigned int utmip_force_pll_enable_powerdown:1; /* Force USB_PHY PLL pll_enable input off. (Overrides FORCE_PLL_ENABLE_POWERUP.) */
        unsigned int utmip_force_pll_enable_powerup:1; /* Force USB_PHY PLL pll_enable input on.  */
        unsigned int utmip_force_pllu_powerdown:1; /* Force PLL_U into power down. (Overrides FORCE_PLLU_POWERUP.)   */
        unsigned int utmip_force_pllu_powerup:1; /* Force PLL_U into power up. */
        unsigned int utmip_pll_setup:9;     /* SETUP[8:0] input of USB_PHY PLL. */
        unsigned int utmip_pllu_enable_dly_count:5; /* Controls the wait time to enable PLL_U when coming out of suspend or reset. */
    };

    uint32_t reg32;
} usb3_utmip_pll_cfg1_t;

#define USB3_UTMIP_XCVR_CFG0_OFFSET 0x808
#define USB3_UTMIP_XCVR_CFG0_RESET  0x20256500
typedef union usb3_utmip_xcvr_cfg0_u {
    struct {
        unsigned int utmip_xcvr_setup:4;    /* SETUP[3:0] input of XCVR cell. HS driver output control. 4 LSBs. */
        unsigned int utmip_xcvr_hsslew:2;   /* HS slew rate control. The two LSBs. */
        unsigned int utmip_xcvr_fsslew:2;   /* FS slew rate control. */
        unsigned int utmip_xcvr_lsrslew:2;  /* LS rising slew rate control. */
        unsigned int utmip_xcvr_lsfslew:2;  /* LS falling slew rate control. */
        unsigned int utmip_xcvr_hsloopback:1; /* Internal loopback inside XCVR cell. Used for IOBIST. */
        unsigned int utmip_xcvr_termen:1;   /* Enable HS termination. */
        unsigned int utmip_force_pd_powerdown:1; /* Force PD input into power down. (Overrides FORCE_PD_POWERUP.) */
        unsigned int utmip_force_pd_powerup:1; /* Force PD input into power up.  */
        unsigned int utmip_force_pd2_powerdown:1; /* Force PD2 input into power down. (Overrides FORCE_PD2_POWERUP.) */
        unsigned int utmip_force_pd2_powerup:1; /* Force PD2 input into power up. */
        unsigned int utmip_force_pdzi_powerdown:1; /* Force PDZI input into power down. (Overrides FORCE_PDZI_POWERUP.) */
        unsigned int utmip_force_pdzi_powerup:1; /* Force PDZI input into power up. */
        unsigned int utmip_xcvr_discon_method:1; /* Disconnect method on the usb transceiver pad */
        unsigned int utmip_xcvr_lsbias_sel:1; /* Low speed bias selection method for usb transceiver pad */
        unsigned int utmip_xcvr_setup_msb:3; /* Most significant bits of SETUP. */
        unsigned int utmip_xcvr_hsslew_msb:7; /* Most significant bits of HS_SLEW. */
    };

    uint32_t reg32;
} usb3_utmip_xcvr_cfg0_t;

#define USB3_UTMIP_BIAS_CFG0_OFFSET 0x80C
#define USB3_UTMIP_BIAS_CFG0_RESET  0x00000800
typedef union usb3_utmip_bias_cfg0_u {
    struct {
        unsigned int utmip_hssquelch_level:2; /* HS squelch detector level. */
        unsigned int utmip_hsdiscon_level:2; /* HS disconnect detector level. */
        unsigned int utmip_hschirp_level:2; /* HS chirp detector level. */
        unsigned int utmip_sess_level_level:2; /* SessionEnd detector level. */
        unsigned int utmip_vbus_level_level:2; /* Vbus detector level. */
        unsigned int utmip_biaspd:1;        /* Power down bias circuit. */
        unsigned int utmip_otgpd:1;         /* Power down OTG circuit. */
        unsigned int utmip_active_pullup_offset:3; /* Active 1.5K pullup control offset. */
        unsigned int utmip_active_term_offset:3; /* Active termination control offset. */
        unsigned int utmip_gpi_sel:1;       /* 0: StaticGpi = IdDig. 1: StaticGpi = GPI_VAL. */
        unsigned int utmip_gpi_val:1;       /* See GPI_SEL. */
        unsigned int utmip_iddig_sel:1;     /* 0: IdDig = IdDig. 1: IdDig = IDDIG_VAL. */
        unsigned int utmip_iddig_val:1;     /* See IDDIG_SEL. */
        unsigned int utmip_idpd_sel:1;      /* 0: IDPD = ~IdPullup. 1: IDPD = IDPD_VAL. */
        unsigned int utmip_idpd_val:1;      /* See IDPD_SEL. */
        unsigned int utmip_hsdiscon_level_msb:1; /* Most significant bit of UTMIP_HSDISCON_LEVEL, bit 2 */
        unsigned int undefined_bits_25_31:7;
    };

    uint32_t reg32;
} usb3_utmip_bias_cfg0_t;

#define USB3_UTMIP_HSRX_CFG0_OFFSET 0x810
#define USB3_UTMIP_HSRX_CFG0_RESET  0x91653400
typedef union usb3_utmip_hsrx_cfg0_u {
    struct {
        unsigned int utmip_use4sync_tran:1; /* Require 4 sync pattern transitions (01) instead of 3 */
        unsigned int utmip_three_syncbits:1; /* Sync pattern detection needs 3 consecutive samples instead of 4 */
        unsigned int utmip_phase_adjust:2;  /* Based on incoming edges and current sampling position, adjust phase */
        unsigned int utmip_pcount_inertia:2; /* Retime the path.  */
        unsigned int utmip_pass_feedback:1; /* Pass through the feedback, do not block it. */
        unsigned int utmip_pass_chirp:1;    /* When in Chirp Mode, allow chirp rx data through */
        unsigned int utmip_elastic_underrun_disable:1; /* Do not declare underrun errors */
        unsigned int utmip_elastic_overrun_disable:1; /* Do not declare overrun errors until overflow of FIFO */
        unsigned int utmip_elastic_limit:5; /* Depth of elastic input store */
        unsigned int utmip_idle_wait:5;     /* Number of cycles of idle to declare IDLE.  */
        unsigned int utmip_no_stripping:1;  /* Do not strip incoming data */
        unsigned int utmip_squelch_eop_dly:3; /* Limit the delay of the squelch at EOP time */
        unsigned int utmip_pcount_updn_div:4; /* The number of (edges-1) needed to move the sampling point */
        unsigned int utmip_realign_on_new_pkt:1; /* Realign the inertia counters on a new packet */
        unsigned int utmip_allow_consec_updn:1; /* Allow consecutive ups and downs on the bits, debug only, set to 0. */
        unsigned int utmip_keep_patt_on_active:2; /* Keep the stay alive pattern on active */
    };

    uint32_t reg32;
} usb3_utmip_hsrx_cfg0_t;

#define USB3_UTMIP_HSRX_CFG1_OFFSET 0x814
#define USB3_UTMIP_HSRX_CFG1_RESET  0x00000013
typedef union usb3_utmip_hsrx_cfg1_u {
    struct {
        unsigned int utmip_hs_allow_keep_alive:1; /* Allow Keep Alive packets  */
        unsigned int utmip_hs_sync_start_dly:5; /* How long to wait before start of sync launches RxActive */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} usb3_utmip_hsrx_cfg1_t;

#define USB3_UTMIP_FSLSRX_CFG0_OFFSET 0x818
#define USB3_UTMIP_FSLSRX_CFG0_RESET  0xFD548429
typedef union usb3_utmip_fslsrx_cfg0_u {
    struct {
        unsigned int utmip_fsls_idle_count_limit:1; /* Give up on packet if a long sequence of J  */
        unsigned int utmip_fsls_idle_count_max:6; /* 20 bits of idle should end the packet if FsLsIdleCountLimitCfg=1. */
        unsigned int utmip_fsls_idle_wait_limit:1; /* Enable the reset of the state machine on extended SE0 */
        unsigned int utmip_fsls_idle_wait_max:6; /* 4 bits of of SEO should exceed the time limit */
        unsigned int utmip_fsls_active_on_full_sync:1; /* Require a full sync pattern to declare the data received */
        unsigned int utmip_fsls_kcount_limit:1; /* Limit the number of bit times a K can last */
        unsigned int utmip_fsls_kcount_max:6; /* Number of K bits in question */
        unsigned int utmip_fsls_eop_ends_at_se0:1; /* Only look for transitioning out of EOP */
        unsigned int utmip_fsls_lwr_dribble_size:3; /* Do not allow >= dribble bits  */
        unsigned int utmip_fsls_upr_dribble_size:3; /* Do not allow <= dribble bits */
        unsigned int utmip_fsls_serial_se0_rcv:1;
        unsigned int utmip_fsls_se1_filter:1; /* Filter SE1 */
        unsigned int utmip_fsls_se1_dribble_filter:1; /* One SE1, don't allow dribble */
    };

    uint32_t reg32;
} usb3_utmip_fslsrx_cfg0_t;

#define USB3_UTMIP_FSLSRX_CFG1_OFFSET 0x81C
#define USB3_UTMIP_FSLSRX_CFG1_RESET  0x02267400
typedef union usb3_utmip_fslsrx_cfg1_u {
    struct {
        unsigned int utmip_fs_eop_length:1; /* Whether full speed EOP  is determined within 3(0) or 4(1) 60MHz cycles */
        unsigned int utmip_fs_debounce:1;   /* Whether full speed uses debouncing */
        unsigned int utmip_fs_weak_sync:1;  /* Only look for a KK pattern, instead of KJKK */
        unsigned int utmip_fs_lenient_dribble:1; /* Allow for large dribble in full speed mode */
        unsigned int utmip_ls_lenient_dribble:1; /* Allow for large dribble in low  speed mode */
        unsigned int utmip_ls_se0_count:6;  /* Only for this number of 60MHz of SEO and Idle to end packet */
        unsigned int utmip_ls_eop_start_count:6; /* Number of SEO clock cycles to block bit extraction */
        unsigned int utmip_ls_extraction_count:6; /* Phase count on which LS bits are extracted */
        unsigned int utmip_ls_bounce_length:3; /* Number of clock cycle of LS stable */
        unsigned int utmip_early_line_state_filter:1; /* Assumes line state filtering table is inclusive, not exclusive */
        unsigned int undefined_bits_27_31:5;
    };

    uint32_t reg32;
} usb3_utmip_fslsrx_cfg1_t;

#define USB3_UTMIP_TX_CFG0_OFFSET 0x820
#define USB3_UTMIP_TX_CFG0_RESET  0x00010200
typedef union usb3_utmip_tx_cfg0_u {
    struct {
        unsigned int utmip_no_sync_no_eop:1; /* Do not sent SYNC or EOP */
        unsigned int utmip_no_encoding:1;   /* No encoding, static programming */
        unsigned int utmip_no_stuffing:1;   /* No bit stuffing, static programming */
        unsigned int utmip_sof_on_no_encode:1; /* Sof when OpMode 2 -- not likely, for Chirp */
        unsigned int utmip_sof_on_no_stuff:1; /* Sof when OpMode 3 -- perhaps, when sending controller made packets */
        unsigned int utmip_sie_resume_on_linestate:1; /* SIE, not macrocell, detects LineState change to resume */
        unsigned int utmip_hs_preamble_output_enable:1; /* output enable turns on  1 cycle before */
        unsigned int utmip_hs_postamble_output_enable:1; /* output enable turns off 1 cycle after */
        unsigned int utmip_hs_discon_disable:1; /* Disable high speed disconnect */
        unsigned int utmip_hs_discon_eop_only:1; /* Only check during EOP */
        unsigned int utmip_hs_tx_ipg_dly:5;
        unsigned int utmip_hs_ready_wait_for_valid:1;
        unsigned int utmip_fsls_allow_sop_tx_stuff_err:1; /* Allow SOP to be source of transmit error stuffing */
        unsigned int utmip_fs_preamble_output_enable:1; /* output enable turns on  1/2 cycle before */
        unsigned int utmip_fs_postamble_output_enable:1; /* output enable turns off 1/2 cycle after  */
        unsigned int utmip_fs_preamble_j:1; /* output enable sends an initial J before sync pattern */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} usb3_utmip_tx_cfg0_t;

#define USB3_UTMIP_MISC_CFG0_OFFSET 0x824
#define USB3_UTMIP_MISC_CFG0_RESET  0x03E00078
typedef union usb3_utmip_misc_cfg0_u {
    struct {
        unsigned int utmip_comb_terms:1;    /* Use combinational terminations or synced through CLKXTAL */
        unsigned int utmip_always_free_running_terms:1; /* Use free running terminations at all time */
        unsigned int utmip_never_free_running_terms:1; /* Ignore free running terminations, even when no clock */
        unsigned int utmip_no_free_on_suspend:1; /* Don't use free running terminations during suspend. */
        unsigned int utmip_stable_all:1;    /* Determines if all signal need to be stable to not change a config. */
        unsigned int utmip_stable_count:3;  /* Number of cycles of crystal clock of signal not changing to consider stable. */
        unsigned int utmip_force_pulldn_dm:1; /* Force DM pulldown active. */
        unsigned int utmip_force_pulldn_dp:1; /* Force DP pulldown active. */
        unsigned int utmip_force_pullup_dm:1; /* Force DM pullup active.       */
        unsigned int utmip_force_pullup_dp:1; /* Force DP pullup active. */
        unsigned int utmip_disable_pulldn_dm:1; /* Force DM pulldown inactive. (Overrides FORCE_PULLDN_DM.) */
        unsigned int utmip_disable_pulldn_dp:1; /* Force DP pulldown inactive. (Overrides FORCE_PULLDN_DP.) */
        unsigned int utmip_disable_pullup_dm:1; /* Force DM pullup inactive. (Overrides FORCE_PULLUP_DM.) */
        unsigned int utmip_disable_pullup_dp:1; /* Force DP pullup inactive. (Overrides FORCE_PULLUP_DP.) */
        unsigned int utmip_force_hs_term:1; /* Force HS termination active. */
        unsigned int utmip_disable_hs_term:1; /* Force HS termination inactive. */
        unsigned int utmip_force_hs_clock_on:1; /* Force HS clock always on. */
        unsigned int utmip_inject_error_type:2; /* Force error insertion into RX path. (Used for IOBIST.) */
        unsigned int utmip_ls_to_fs_skip_4ms:1; /* Don't block changes for 4ms when going from LS to FS (should not happen) */
        unsigned int utmip_suspend_exit_on_edge:1; /* Suspend exit requires edge or simply a value... */
        unsigned int utmip_force_fs_disable_on_dev_chirp:1;
        unsigned int utmip_allow_ls_on_soft_discon:1;
        unsigned int utmip_keep_xcvr_pd_on_soft_discon:1;
        unsigned int utmip_dpdm_observe:1;  /* Use DP/DM as obs bus */
        unsigned int utmip_dpdm_observe_sel:4; /* Select DP/DM obs signals */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} usb3_utmip_misc_cfg0_t;

#define USB3_UTMIP_MISC_CFG1_OFFSET 0x828
#define USB3_UTMIP_MISC_CFG1_RESET  0x40198024
typedef union usb3_utmip_misc_cfg1_u {
    struct {
        unsigned int utmip_xcvrsel3:2;      /* Bit 0: 0: 0xa5 -> treat as KeepAlive         1: treat as regular packet  Bit 1: 0: Turn on FS EOP detection        1: Turn off FS EOP detection */
        unsigned int utmip_suspend_termsel:1;
        unsigned int utmip_flip_fsls_polarity:1;
        unsigned int utmip_rx_error_cnt_en:1;
        unsigned int utmip_rx_error_cnt_clr:1;
        unsigned int utmip_pllu_stable_count:12; /* WRONG! This should be 1ms -> 0x50 */
        unsigned int utmip_pll_active_dly_count:5; /* 5 us / (1/19.2MHz) = 96 / 16 = 6 */
        unsigned int utmip_force_iobist_clk_on:1;
        unsigned int utmip_fsls_tdm:1;
        unsigned int utmip_obs_sel:2;
        unsigned int utmip_linestate_xcvrsel3:1; /* 0: Use FS filtering on line state when XcvrSel=3 1: Use LS filtering on line state when XcvrSel=3 */
        unsigned int utmip_linestate_neg:1; /* Use neg edge sync for linestate */
        unsigned int utmip_linestate_bypass:1; /* Bypass LineState reclocking logic */
        unsigned int utmip_phy_xtal_clocken:1; /* Selects whether to enable the crystal clock in the module. */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} usb3_utmip_misc_cfg1_t;

#define USB3_UTMIP_DEBOUNCE_CFG0_OFFSET 0x82C
#define USB3_UTMIP_DEBOUNCE_CFG0_RESET  0xFFFFFFFF
typedef union usb3_utmip_debounce_cfg0_u {
    struct {
        unsigned int utmip_bias_debounce_a:16; /* simulation value -- Used for interrupts */
        unsigned int utmip_bias_debounce_b:16; /* simulation value -- Used for interrupts */
    };

    uint32_t reg32;
} usb3_utmip_debounce_cfg0_t;

#define USB3_UTMIP_BAT_CHRG_CFG0_OFFSET 0x830
#define USB3_UTMIP_BAT_CHRG_CFG0_RESET  0x00000001
typedef union usb3_utmip_bat_chrg_cfg0_u {
    struct {
        unsigned int utmip_pd_chrg:1;       /* Power down charger circuit */
        unsigned int utmip_op_sink_en:1;
        unsigned int utmip_on_sink_en:1;
        unsigned int utmip_op_src_en:1;
        unsigned int utmip_on_src_en:1;
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} usb3_utmip_bat_chrg_cfg0_t;

#define USB3_UTMIP_SPARE_CFG0_OFFSET 0x834
#define USB3_UTMIP_SPARE_CFG0_RESET  0xFFFF0000
typedef union usb3_utmip_spare_cfg0_u {
    struct {
        unsigned int utmip_spare:32;        /* Spare register bits 0: HS_RX_IPG_ERROR_ENABLE 1: HS_RX_FLUSH_ALAP. Flush as late as possible 2: HS_RX_LATE_SQUELCH. Delay Squelch by 1 CLK480 cycle. 31 to 3: Reserved */
    };

    uint32_t reg32;
} usb3_utmip_spare_cfg0_t;

#define USB3_UTMIP_XCVR_CFG1_OFFSET 0x838
#define USB3_UTMIP_XCVR_CFG1_RESET  0x0000823F
typedef union usb3_utmip_xcvr_cfg1_u {
    struct {
        unsigned int utmip_force_pddisc_powerdown:1; /* Force PDDISC input into power down. (Overrides FORCE_PDDISC_POWERUP.) */
        unsigned int utmip_force_pddisc_powerup:1; /* Force PDDISC input into power up. */
        unsigned int utmip_force_pdchrp_powerdown:1; /* Force PDCHRP input input into power down. (Overrides FORCE_PDCHRP_POWERUP.) */
        unsigned int utmip_force_pdchrp_powerup:1; /* Force PDCHRP input into power up. */
        unsigned int utmip_force_pddr_powerdown:1; /* Force PDDR input input into power down. (Overrides FORCE_PDDR_POWERUP.) */
        unsigned int utmip_force_pddr_powerup:1; /* Force PDDR input into power up. */
        unsigned int utmip_tctrl_sw_val:5;  /* Encoded value to use on TCTRL when software override is enabled, 0 to 16 only */
        unsigned int utmip_tctrl_sw_set:1;  /* Use a software override on TCTRL instead of automatic bias control */
        unsigned int utmip_rctrl_sw_val:5;  /* Encoded value to use on RCTRL when software override is enabled, 0 to 16 only */
        unsigned int utmip_rctrl_sw_set:1;  /* Use a software override on RCTRL instead of automatic bias control */
        unsigned int utmip_xcvr_term_range_adj:4; /* Range adjusment on terminations. */
        unsigned int utmip_xcvr_spare:2;    /* Spare bits for usb transceiver pad ECO. */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} usb3_utmip_xcvr_cfg1_t;

#define USB3_UTMIP_BIAS_CFG1_OFFSET 0x83C
#define USB3_UTMIP_BIAS_CFG1_RESET  0x0000002A
typedef union usb3_utmip_bias_cfg1_u {
    struct {
        unsigned int utmip_force_pdtrk_powerdown:1; /* Force PDTRK input into power down. (Overrides FORCE_PDTRK_POWERUP.) */
        unsigned int utmip_force_pdtrk_powerup:1; /* Force PDTRK input into power up. */
        unsigned int utmip_vbus_wakeup_powerdown:1; /* Force VBUS_WAKEUP input into power down. */
        unsigned int utmip_bias_pdtrk_count:5; /* Control the BIAS cell power down lag. The lag should be 20us. For a Xtal clock of 13MHz it should be set a 5.  */
        unsigned int utmip_bias_debounce_timescale:6; /* Debouncer time scaling, factor-1 to slow down debouncing by. So 0 is 1, 1 is 2, etc. */
        unsigned int undefined_bits_14_31:18;
    };

    uint32_t reg32;
} usb3_utmip_bias_cfg1_t;

#define USB3_UTMIP_BIAS_STS0_OFFSET 0x840
#define USB3_UTMIP_BIAS_STS0_RESET  0x00000000
typedef union usb3_utmip_bias_sts0_u {
    struct {
        unsigned int utmip_rctrl:16;        /* Thermal encoding output from USB bias pad.  */
        unsigned int utmip_tctrl:16;        /* Thermal encoding output from USB bias pad.  */
    };

    uint32_t reg32;
} usb3_utmip_bias_sts0_t;

#endif // TEGRA_USB_H
