/*
 * ARM NVIDIA Tegra2 emulation.
 *
 * Copyright (c) 2016 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* Autogenerated from TRM v02p */

#ifndef TEGRA_AHB_DMA_H
#define TEGRA_AHB_DMA_H

#define CMD_OFFSET 0x0
#define CMD_RESET  0x00000000
typedef union cmd_u {
    struct {
        unsigned int undefined_bits_0_30:31;
        unsigned int gen:1;                 /* 0 = Disable AHB-DMA; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} cmd_t;

#define STA_OFFSET 0x4
#define STA_RESET  0x00000000
typedef union sta_u {
    struct {
        unsigned int undefined_bits_0_23:24;
        unsigned int ch0:1;                 /* AHB DMA channel busy status flags set/cleared by HW; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int ch1:1;                 /* AHB DMA channel busy status flags set/cleared by HW; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int ch2:1;                 /* AHB DMA channel busy status flags set/cleared by HW; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int ch3:1;                 /* AHB DMA channel busy status flags set/cleared by HW; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int undefined_bits_28_31:4;
    };

    uint32_t reg32;
} sta_t;

#define TX_REQ_OFFSET 0x8
#define TX_REQ_RESET  0x00000000
typedef union tx_req_u {
    struct {
        unsigned int cntr_req:1;            /* Enable Counter requestor; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_17:1;              /* Enable software requestor SMP17 from the SHRD_SMP.STA register; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_18:1;              /* Enable software requestor SMP18 from the SHRD_SMP.STA register; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_19:1;              /* Enable software requestor SMP19 from the SHRD_SMP.STA register; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_20:1;              /* Enable software requestor SMP20 from the SHRD_SMP.STA register; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_21:1;              /* Enable software requestor SMP21 from the SHRD_SMP.STA register; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_22:1;              /* Enable software requestor SMP22 from the SHRD_SMP.STA register; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_23:1;              /* Enable software requestor SMP23 from the SHRD_SMP.STA register; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_24:1;              /* Enable software requestor SMP24 from the SHRD_SMP.STA register; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_25:1;              /* Enable software requestor SMP25 from the SHRD_SMP.STA register; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_26:1;              /* Enable software requestor SMP26 from the SHRD_SMP.STA register; 0 = DISABLE; 1 = ENABLE */
        unsigned int host1x:1;              /* 0 = NOP; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_12_13:2;
        unsigned int srq0_xrq_a:1;          /* 0 = NOP; 0 = DISABLE; 1 = ENABLE */
        unsigned int srq1_xrq_b:1;          /* 0 = NOP; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_30_same_as_30_bit:1; /* Software requestor SMP30 from the SHRD_SMP.STA register.(same as bit[30]); 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_31_same_as_31_bit:1; /* Software requestor SMP31 from the SHRD_SMP.STA register (same as bit[31]); 0 = DISABLE; 1 = ENABLE */
        unsigned int hrq2_xrq_c:1;          /* 0 = NOP; 0 = DISABLE; 1 = ENABLE */
        unsigned int hrq3_xrq_d:1;          /* 0 = NOP; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_20_21:2;
        unsigned int hrq6_tmr1:1;           /* Timer 1 Interrupt; 0 = DISABLE; 1 = ENABLE */
        unsigned int hrq7_tmr2:1;           /* Timer 2 Interrupt; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_0:1;               /* End of AHB-DMA Transfer on Channel 0; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_1:1;               /* End of AHB-DMA Transfer on Channel 1; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_2:1;               /* End of AHB-DMA Transfer on Channel 2; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_3:1;               /* End of AHB-DMA Transfer on Channel 3; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_28:1;              /* Software requestor SMP28 from the SHRD_SMP.STA register; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_29:1;              /* Software requestor SMP29 from the SHRD_SMP.STA register; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_30:1;              /* Software requestor SMP30 from the SHRD_SMP.STA register; 0 = DISABLE; 1 = ENABLE */
        unsigned int smp_31:1;              /* Software requestor SMP31 from the SHRD_SMP.STA register; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} tx_req_t;

#define COUNTER_OFFSET 0x10
#define COUNTER_RESET  0x00000000
typedef union counter_u {
    struct {
        unsigned int count_value:16;        /* DMA COUNT Init/Reload Value */
        unsigned int prd_en:1;              /* Normally, AHB DMA current count value is reloaded to the programmed init/reload value whenever the current count reaches 0. If this bit is set, the reload is additionally qualified with the condition that the last word of the burst is being sent. This will delay the reload of the counter by only a few cycles from when the counter value reaches 0; 0 = DISABLE; 1 = ENABLE */
        unsigned int cntr_en:1;             /* When this bit is set Counter is enabled; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch0_fl_cnt:1;          /* Controls AHB DMA channel0 self-throttle based on the AHB DMA Counter Value. If this bit field is active, then AHB DMA counter value will be enabled for decrement and reload (just as if CNTR.EN is set); 0 = DISABLE; 1 = ENABLE */
        unsigned int ch1_fl_cnt:1;          /* Controls AHB DMA channel1 self-throttle based on the AHB DMA Counter Value. If this bit field is active, then AHB DMA counter value will be enabled for decrement and reload (just as if CNTR.EN is set); 0 = DISABLE; 1 = ENABLE */
        unsigned int ch2_fl_cnt:1;          /* Controls AHB DMA channel2 self-throttle based on the AHB DMA Counter Value. If this bit field is active, then AHB DMA counter value will be enabled for decrement and reload (just as if CNTR.EN is set); 0 = DISABLE; 1 = ENABLE */
        unsigned int ch3_fl_cnt:1;          /* Controls AHB DMA channel3 self-throttle based on the AHB DMA Counter Value. If this bit field is active, then AHB DMA counter value will be enabled for decrement and reload (just as if CNTR.EN is set); 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_22_31:10;
    };

    uint32_t reg32;
} counter_t;

#define IRQ_STA_CPU_OFFSET 0x14
#define IRQ_STA_CPU_RESET  0x00000000
typedef union irq_sta_cpu_u {
    struct {
        unsigned int ch0:1;                 /* Gathers all the after-masking CPU directed IRQ status bits from channel0; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch1:1;                 /* Gathers all the after-masking CPU directed IRQ status bits from channel1; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch2:1;                 /* Gathers all the after-masking CPU directed IRQ status bits from channel2; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch3:1;                 /* Gathers all the after-masking CPU directed IRQ status bits from channel3; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} irq_sta_cpu_t;

#define IRQ_STA_COP_OFFSET 0x18
#define IRQ_STA_COP_RESET  0x00000000
typedef union irq_sta_cop_u {
    struct {
        unsigned int ch0:1;                 /* Gathers all the after-masking COP directed IRQ status bits from channel0; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch1:1;                 /* Gathers all the after-masking COP directed IRQ status bits from channel1; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch2:1;                 /* Gathers all the after-masking COP directed IRQ status bits from channel2; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch3:1;                 /* Gathers all the after-masking COP directed IRQ status bits from channel3; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} irq_sta_cop_t;

#define IRQ_MASK_OFFSET 0x1C
#define IRQ_MASK_RESET  0x00000000
typedef union irq_mask_u {
    struct {
        unsigned int ch0:1;                 /* Each bit allows the associated channel0 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch1:1;                 /* Each bit allows the associated channel1 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch2:1;                 /* Each bit allows the associated channel2 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch3:1;                 /* Each bit allows the associated channel3 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} irq_mask_t;

#define IRQ_MASK_SET_OFFSET 0x20
#define IRQ_MASK_SET_RESET  0x00000000
typedef union irq_mask_set_u {
    struct {
        unsigned int ch0:1;                 /* Writing  1 Sets the Mask Register for CH0; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch1:1;                 /* Writing  1 Sets the Mask Register for CH1; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch2:1;                 /* Writing  1 Sets the Mask Register for CH2; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch3:1;                 /* Writing  1 Sets the Mask Register for CH3; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} irq_mask_set_t;

#define IRQ_MASK_CLR_OFFSET 0x24
#define IRQ_MASK_CLR_RESET  0x00000000
typedef union irq_mask_clr_u {
    struct {
        unsigned int ch0:1;                 /* Writing  1 Clears the Mask Register for CH0; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch1:1;                 /* Writing  1 Clears the Mask Register for CH1; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch2:1;                 /* Writing  1 Clears the Mask Register for CH2; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch3:1;                 /* Writing  1 Clears the Mask Register for CH3; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} irq_mask_clr_t;

#define RDWR_COHERENCY_OFFSET 0x28
#define RDWR_COHERENCY_RESET  0x00000000
typedef union rdwr_coherency_u {
    struct {
        unsigned int ch0_wrs_active:1;
        unsigned int ch1_wrs_active:1;
        unsigned int ch2_wrs_active:1;
        unsigned int ch3_wrs_active:1;      /* 1=ahbdma channel 3 has write transaction(s) outstanding */
        unsigned int undefined_bits_4_15:12;
        unsigned int ch0_rds_active:1;
        unsigned int ch1_rds_active:1;
        unsigned int ch2_rds_active:1;
        unsigned int ch3_rds_active:1;      /* 1=ahbdma channel 3 has read transaction(s) outstanding */
        unsigned int undefined_bits_20_30:11;
        unsigned int mst_gizmo_wrque_empty:1;
    };

    uint32_t reg32;
} rdwr_coherency_t;

#define TEST_BUS_OFFSET 0x2C
#define TEST_BUS_RESET  0x00000000
typedef union test_bus_u {
    struct {
        unsigned int mstgizmo_wrque_ch0_ping_status:1;
        unsigned int mstgizmo_wrque_ch0_pong_status:1;
        unsigned int mstgizmo_wrque_ch1_ping_status:1;
        unsigned int mstgizmo_wrque_ch1_pong_status:1;
        unsigned int mstgizmo_wrque_ch2_ping_status:1;
        unsigned int mstgizmo_wrque_ch2_pong_status:1;
        unsigned int mstgizmo_wrque_ch3_ping_status:1;
        unsigned int mstgizmo_wrque_ch3_pong_status:1;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} test_bus_t;

#define PPCS_MCCIF_FIFOCTRL_OFFSET 0x40
#define PPCS_MCCIF_FIFOCTRL_RESET  0x00000000
typedef union ppcs_mccif_fifoctrl_u {
    struct {
        unsigned int ppcs_mccif_wrcl_mcle2x:1; /* 0 = DISABLE; 1 = ENABLE */
        unsigned int ppcs_mccif_rdmc_rdfast:1; /* 0 = DISABLE; 1 = ENABLE */
        unsigned int ppcs_mccif_wrmc_clle2x:1; /* 0 = DISABLE; 1 = ENABLE */
        unsigned int ppcs_mccif_rdcl_rdfast:1; /* 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} ppcs_mccif_fifoctrl_t;

#define TIMEOUT_WCOAL_PPCS_OFFSET 0x44
#define TIMEOUT_WCOAL_PPCS_RESET  0x00003232
typedef union timeout_wcoal_ppcs_u {
    struct {
        unsigned int ppcsahbslvw_wcoal_tmval:8;
        unsigned int ppcsahbdmaw_wcoal_tmval:8;
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} timeout_wcoal_ppcs_t;

#define AHBDMACHAN_CHANNEL_0_CSR_OFFSET 0x0 + 0x1000
#define AHBDMACHAN_CHANNEL_0_CSR_RESET  0x00000000
typedef union ahbdmachan_channel_0_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32 bit word cycles. This is encoded as N+1, so that if a value of 0 is programmed here, 1 32-bit word will be transferred */
        unsigned int req_sel:4;             /* 0 = CNTR_REQ; 1 = SMP_17; 2 = SMP_18; 3 = SMP_19; 4 = SMP_20; 5 = SMP_21; 6 = SMP_22; 7 = SMP_23; 8 = SMP_24; 9 = SMP_25; 10 = SMP_26; 11 = Host1x; 12 = SRQ0_N_A; 13 = SRQ1_N_A; 14 = SRQ0_XRQ_A; 15 = SRQ1_XRQ_B */
        unsigned int trig_sel:4;            /* 0 = SMP_30_same_as_bit_14; 1 = SMP_31_same_as_bit_15; 2 = HRQ2_XRQ_C; 3 = HRQ3_XRQ_D; 4 = HRQ4_N_A; 5 = HRQ5_N_A; 6 = HRQ6_TMR1; 7 = HRQ7_TMR2; 8 = AHB_0; 9 = AHB_1; 10 = AHB_2; 11 = AHB_3; 12 = SMP_28; 13 = SMP_29; 14 = SMP_30; 15 = SMP_31 */
        unsigned int flow:1;                /* 0 = Independent of DRQ request (no flow set); 0 = DISABLE; 1 = ENABLE */
        unsigned int trig:1;                /* 0 = Independent of Trigger (no trigger set); 0 = DISABLE; 1 = ENABLE */
        unsigned int once:1;                /* 0 = Run for Multiple Block Transfer; 0 = DISABLE; 1 = ENABLE */
        unsigned int dir:1;                 /* 0 = XMB read to AHB write; 0 = DISABLE; 1 = ENABLE */
        unsigned int hold:1;                /* 0 = Disable; 0 = DISABLE; 1 = ENABLE */
        unsigned int fl_btwn:1;             /* 0 = do not flush; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* 0 = NOP or waiting; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* 0 = Disable the DMA Channel; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} ahbdmachan_channel_0_csr_t;

#define AHBDMACHAN_CHANNEL_0_STA_OFFSET 0x4 + 0x1000
#define AHBDMACHAN_CHANNEL_0_STA_RESET  0x00000000
typedef union ahbdmachan_channel_0_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Remaining transfer count in 32bit word cycles Flags set / cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int halt:1;                /* 0 = NOP (holding status) Read-only 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_29:1;
        unsigned int is_eoc:1;              /* Write '1' to clear the flag 0 = NO_INTR 1 = INTR */
        unsigned int bsy:1;                 /* 0 = NOP Read-only 0 = DISABLE 1 = ENABLE */
    };

    uint32_t reg32;
} ahbdmachan_channel_0_sta_t;

#define AHBDMACHAN_CHANNEL_0_AHB_PTR_OFFSET 0x10 + 0x1000
#define AHBDMACHAN_CHANNEL_0_AHB_PTR_RESET  0x00000000
typedef union ahbdmachan_channel_0_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* AHB-DMA starting address for internal AHB Bus */
    };

    uint32_t reg32;
} ahbdmachan_channel_0_ahb_ptr_t;

#define AHBDMACHAN_CHANNEL_0_AHB_SEQ_OFFSET 0x14 + 0x1000
#define AHBDMACHAN_CHANNEL_0_AHB_SEQ_RESET  0x00800000
typedef union ahbdmachan_channel_0_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_stride:16;         /* This field tells us number of words that are supposed to be skipped on AHB side */
        unsigned int ahb_addr_wrap:1;       /* 0 = disable  0 = DISABLE 1 = ENABLE */
        unsigned int dbl_buf:1;             /* 0 = Reload Base Address for 1X blocks (default), reload each time 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_20:1;
        unsigned int ahb_stride_size:3;     /* 0 = disabled, otherwise stride is enabled 0 = DISABLE 1 = WORDS_4 2 = WORDS_8 3 = WORDS_16 4 = WORDS_32 5 = WORDS_64 6 = WORDS_128 7 = WORDS_256 */
        unsigned int ahb_burst:3;           /* 0,1,5-7 = rsvd 2 = WORD 3 = FOUR_WORD 4 = EIGHT_WORD */
        unsigned int ahb_data_swap:1;       /* 0 = no data conversion, when 1 and writeAhb: [31:0]->{[7:0],[15:8],[23:16],[31:24]}  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_28_30:3;
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP 1 = CPU 0 = COP */
    };

    uint32_t reg32;
} ahbdmachan_channel_0_ahb_seq_t;

#define AHBDMACHAN_CHANNEL_0_XMB_PTR_OFFSET 0x18 + 0x1000
#define AHBDMACHAN_CHANNEL_0_XMB_PTR_RESET  0x00000000
typedef union ahbdmachan_channel_0_xmb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int xmb_base:30;           /* AHB-DMA Starting address for internal AHB Bus */
    };

    uint32_t reg32;
} ahbdmachan_channel_0_xmb_ptr_t;

#define AHBDMACHAN_CHANNEL_0_XMB_SEQ_OFFSET 0x1C + 0x1000
#define AHBDMACHAN_CHANNEL_0_XMB_SEQ_RESET  0x00000000
typedef union ahbdmachan_channel_0_xmb_seq_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int xmb_stride:16;         /* This field tells us number of words that are supposed to be skipped on XMB side */
        unsigned int xmb_addr_wrap:1;       /* 0 disable 0 = DISABLE 1 = ENABLE */
        unsigned int dbl_buf:1;             /* 0 = Reload Base Address for 1X blocks (default) (reload each time) 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_20_26:7;
        unsigned int xmb_data_swap:1;       /* 0 = no data conversion, when 1 and writeXmb: [31:0]->{[7:0],[15:8],[23:16],[31:24]} 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_28_31:4;
    };

    uint32_t reg32;
} ahbdmachan_channel_0_xmb_seq_t;

#define AHBDMACHAN_CHANNEL_1_CSR_OFFSET 0x20 + 0x1000
#define AHBDMACHAN_CHANNEL_1_CSR_RESET  0x00000000
typedef union ahbdmachan_channel_1_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32 bit word cycles. This is encoded as N+1, so that if a value of 0 is programmed here, 1 32-bit word will be transferred */
        unsigned int req_sel:4;             /* 0 = CNTR_REQ 1 = SMP_17 2 = SMP_18 3 = SMP_19 4 = SMP_20 5 = SMP_21 6 = SMP_22 7 = SMP_23 8 = SMP_24 9 = SMP_25 10 = SMP_26 11 = Host1x 12 = SRQ0_N_A 13 = SRQ1_N_A 14 = SRQ0_XRQ_A 15 = SRQ1_XRQ_B */
        unsigned int trig_sel:4;            /* 0 = SMP_30_same_as_bit_14 1 = SMP_31_same_as_bit_15 2 = HRQ2_XRQ_C 3 = HRQ3_XRQ_D 4 = HRQ4_N_A 5 = HRQ5_N_A 6 = HRQ6_TMR1 7 = HRQ7_TMR2 8 = AHB_0 9 = AHB_1 10 = AHB_2 11 = AHB_3 12 = SMP_28 13 = SMP_29 14 = SMP_30 15 = SMP_31 */
        unsigned int flow:1;                /* 0 = Independent of DRQ request 0 = DISABLE 1 = ENABLE */
        unsigned int trig:1;                /* 0 = Independent of Trigger 0 = DISABLE 1 = ENABLE */
        unsigned int once:1;                /* 0 = Run for Multiple Block Transfer 0 = DISABLE 1 = ENABLE */
        unsigned int dir:1;                 /* 0 = XMB read to AHB write 0 = DISABLE 1 = ENABLE */
        unsigned int hold:1;                /* 0 = Disable 0 = DISABLE 1 = ENABLE */
        unsigned int fl_btwn:1;             /* 0 = do not flush 0 = DISABLE 1 = ENABLE */
        unsigned int ie_eoc:1;              /* 0 = NOP 0 = DISABLE 1 = ENABLE */
        unsigned int enb:1;                 /* 0 = Disable the DMA Channel 0 = DISABLE 1 = ENABLE */
    };

    uint32_t reg32;
} ahbdmachan_channel_1_csr_t;

#define AHBDMACHAN_CHANNEL_1_STA_OFFSET 0x24 + 0x1000
#define AHBDMACHAN_CHANNEL_1_STA_RESET  0x00000000
typedef union ahbdmachan_channel_1_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Remaining transfer count in 32bit word cycles Flags set / cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int halt:1;                /* 0 = NOP  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_29:1;
        unsigned int is_eoc:1;              /* Write '1' to clear the flag  0 = NO_INTR 1 = INTR */
        unsigned int bsy:1;                 /* 0 = NOP Read-only 0 = DISABLE 1 = ENABLE */
    };

    uint32_t reg32;
} ahbdmachan_channel_1_sta_t;

#define AHBDMACHAN_CHANNEL_1_AHB_PTR_OFFSET 0x30 + 0x1000
#define AHBDMACHAN_CHANNEL_1_AHB_PTR_RESET  0x00000000
typedef union ahbdmachan_channel_1_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* AHB-DMA starting address pointer for internal AHB Bus */
    };

    uint32_t reg32;
} ahbdmachan_channel_1_ahb_ptr_t;

#define AHBDMACHAN_CHANNEL_1_AHB_SEQ_OFFSET 0x34 + 0x1000
#define AHBDMACHAN_CHANNEL_1_AHB_SEQ_RESET  0x00800000
typedef union ahbdmachan_channel_1_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_stride:16;         /* This field tells us number of words that are supposed to be skipped on AHB side */
        unsigned int ahb_addr_wrap:1;       /* 0 = disable  0 = DISABLE 1 = ENABLE */
        unsigned int dbl_buf:1;             /* 0 = Reload Base Address for 1X blocks (default), reload each time 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_20:1;
        unsigned int ahb_stride_size:3;     /* 0 = disabled, otherwise stride is enabled 0 = DISABLE 1 = WORDS_4 2 = WORDS_8 3 = WORDS_16 4 = WORDS_32 5 = WORDS_64 6 = WORDS_128 7 = WORDS_256 */
        unsigned int ahb_burst:3;           /* 0,1,5-7 = rsvd 2 = WORD 3 = FOUR_WORD 4 = EIGHT_WORD */
        unsigned int ahb_data_swap:1;       /* 0 = no data conversion, when 1 and writeAhb: [31:0]->{[7:0],[15:8],[23:16],[31:24]} enum (DISABLE=0x0,ENABLE=0x1) */
        unsigned int undefined_bits_28_30:3;
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP 1 = CPU 0 = COP */
    };

    uint32_t reg32;
} ahbdmachan_channel_1_ahb_seq_t;

#define AHBDMACHAN_CHANNEL_1_XMB_PTR_OFFSET 0x38 + 0x1000
#define AHBDMACHAN_CHANNEL_1_XMB_PTR_RESET  0x00000000
typedef union ahbdmachan_channel_1_xmb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int xmb_base:30;           /* AHB-DMA Starting address pointer for internal AHB Bus */
    };

    uint32_t reg32;
} ahbdmachan_channel_1_xmb_ptr_t;

#define AHBDMACHAN_CHANNEL_1_XMB_SEQ_OFFSET 0x3C + 0x1000
#define AHBDMACHAN_CHANNEL_1_XMB_SEQ_RESET  0x00000000
typedef union ahbdmachan_channel_1_xmb_seq_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int xmb_stride:16;         /* This field tells us number of words that are supposed to be skipped on XMB side */
        unsigned int xmb_addr_wrap:1;       /* 1 enable: 0 disable ; When enabled the Address on XMB gets wrapped to same address.  0 = DISABLE 1 = ENABLE */
        unsigned int dbl_buf:1;             /* 0 = Reload Base Address for 1X blocks (default), reload each time 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_20_26:7;
        unsigned int xmb_data_swap:1;       /* 0 = no data conversion, when 1 and writeXmb: [31:0]->{[7:0],[15:8],[23:16],[31:24]} 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_28_31:4;
    };

    uint32_t reg32;
} ahbdmachan_channel_1_xmb_seq_t;

#define AHBDMACHAN_CHANNEL_2_CSR_OFFSET 0x40 + 0x1000
#define AHBDMACHAN_CHANNEL_2_CSR_RESET  0x00000000
typedef union ahbdmachan_channel_2_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32 bit word cycles. This is encoded as N+1, so that if a value of 0 is programmed here, 1 32-bit word will be transferred */
        unsigned int req_sel:4;             /* 0 = CNTR_REQ 1 = SMP_17 2 = SMP_18 3 = SMP_19 4 = SMP_20 5 = SMP_21 6 = SMP_22 7 = SMP_23 8 = SMP_24 9 = SMP_25 10 = SMP_26 11 = Host1x 12 = SRQ0_N_A 13 = SRQ1_N_A 14 = SRQ0_XRQ_A 15 = SRQ1_XRQ_B */
        unsigned int trig_sel:4;            /* 0 = SMP_30_same_as_bit_14 1 = SMP_31_same_as_bit_15 2 = HRQ2_XRQ_C 3 = HRQ3_XRQ_D 4 = HRQ4_N_A 5 = HRQ5_N_A 6 = HRQ6_TMR1 7 = HRQ7_TMR2 8 = AHB_0 9 = AHB_1 10 = AHB_2 11 = AHB_3 12 = SMP_28 13 = SMP_29 14 = SMP_30 15 = SMP_31 */
        unsigned int flow:1;                /* 0 = Independent of DRQ request (no flow set) 0 = DISABLE 1 = ENABLE */
        unsigned int trig:1;                /* 0 = Independent of Trigger (no trigger set) 0 = DISABLE 1 = ENABLE */
        unsigned int once:1;                /* 0 = Run for Multiple Block Transfer 0 = DISABLE 1 = ENABLE */
        unsigned int dir:1;                 /* 0 = XMB read to AHB write 0 = DISABLE 1 = ENABLE */
        unsigned int hold:1;                /* 0 = Disable 0 = DISABLE 1 = ENABLE */
        unsigned int fl_btwn:1;             /* 0 = do not flush 0 = DISABLE 1 = ENABLE */
        unsigned int ie_eoc:1;              /* 0 = NOP or waiting 0 = DISABLE 1 = ENABLE */
        unsigned int enb:1;                 /* 0 = Disable the DMA Channel 0 = DISABLE 1 = ENABLE */
    };

    uint32_t reg32;
} ahbdmachan_channel_2_csr_t;

#define AHBDMACHAN_CHANNEL_2_STA_OFFSET 0x44 + 0x1000
#define AHBDMACHAN_CHANNEL_2_STA_RESET  0x00000000
typedef union ahbdmachan_channel_2_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Remaining transfer count in 32bit word cycles Flags set / cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int halt:1;                /* 0 = NOP (holding status) Read-only 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_29:1;
        unsigned int is_eoc:1;              /* Write '1' to clear the flag  0 = NO_INTR 1 = INTR */
        unsigned int bsy:1;                 /* 0 = NOP Read-only 0 = DISABLE 1 = ENABLE */
    };

    uint32_t reg32;
} ahbdmachan_channel_2_sta_t;

#define AHBDMACHAN_CHANNEL_2_AHB_PTR_OFFSET 0x50 + 0x1000
#define AHBDMACHAN_CHANNEL_2_AHB_PTR_RESET  0x00000000
typedef union ahbdmachan_channel_2_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* AHB-DMA starting address for internal AHB Bus */
    };

    uint32_t reg32;
} ahbdmachan_channel_2_ahb_ptr_t;

#define AHBDMACHAN_CHANNEL_2_AHB_SEQ_OFFSET 0x54 + 0x1000
#define AHBDMACHAN_CHANNEL_2_AHB_SEQ_RESET  0x00800000
typedef union ahbdmachan_channel_2_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_stride:16;         /* This field tells us number of words that are supposed to be skipped on AHB side */
        unsigned int ahb_addr_wrap:1;       /* 0 = disable  0 = DISABLE 1 = ENABLE */
        unsigned int dbl_buf:1;             /* 0 = Reload Base Address for 1X blocks (default), reload each time 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_20:1;
        unsigned int ahb_stride_size:3;     /* 0 = disabled, otherwise stride is enabled 0 = DISABLE 1 = WORDS_4 2 = WORDS_8 3 = WORDS_16 4 = WORDS_32 5 = WORDS_64 6 = WORDS_128 7 = WORDS_256 */
        unsigned int ahb_burst:3;           /* 0,1,5-7 = rsvd 2 = WORD 3 = FOUR_WORD 4 = EIGHT_WORD */
        unsigned int ahb_data_swap:1;       /* 0 = no data conversion, when 1 and writeAhb: [31:0]->{[7:0],[15:8],[23:16],[31:24]}  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_28_30:3;
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP 1 = CPU 0 = COP */
    };

    uint32_t reg32;
} ahbdmachan_channel_2_ahb_seq_t;

#define AHBDMACHAN_CHANNEL_2_XMB_PTR_OFFSET 0x58 + 0x1000
#define AHBDMACHAN_CHANNEL_2_XMB_PTR_RESET  0x00000000
typedef union ahbdmachan_channel_2_xmb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int xmb_base:30;           /* AHB-DMA Starting address for internal AHB Bus */
    };

    uint32_t reg32;
} ahbdmachan_channel_2_xmb_ptr_t;

#define AHBDMACHAN_CHANNEL_2_XMB_SEQ_OFFSET 0x5C + 0x1000
#define AHBDMACHAN_CHANNEL_2_XMB_SEQ_RESET  0x00000000
typedef union ahbdmachan_channel_2_xmb_seq_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int xmb_stride:16;         /* This field tells us number of words that are supposed to be skipped on XMB side */
        unsigned int xmb_addr_wrap:1;       /* 1 enable: 0 disable ; When enabled the Address on XMB gets wrapped to same address.  0 = DISABLE 1 = ENABLE */
        unsigned int dbl_buf:1;             /* 0 = Reload Base Address for 1X blocks (def) eload each time) 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_20_26:7;
        unsigned int xmb_data_swap:1;       /* 0 = no data conversion, when 1 and writeXmb: [31:0]->{[7:0],[15:8],[23:16],[31:24]} 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_28_31:4;
    };

    uint32_t reg32;
} ahbdmachan_channel_2_xmb_seq_t;

#define AHBDMACHAN_CHANNEL_3_CSR_OFFSET 0x60 + 0x1000
#define AHBDMACHAN_CHANNEL_3_CSR_RESET  0x00000000
typedef union ahbdmachan_channel_3_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32 bit word cycles. This is encoded as N+1, so that if a value of 0 is programmed here, 1 32-bit word will be transferred */
        unsigned int req_sel_req_sel:4;     /* 0 = CNTR_REQ 1 = SMP_17 2 = SMP_18 3 = SMP_19 4 = SMP_20 5 = SMP_21 6 = SMP_22 7 = SMP_23 8 = SMP_24 9 = SMP_25 10 = SMP_26 11 = Host1x 12 = SRQ0_N_A 13 = SRQ1_N_A 14 = SRQ0_XRQ_A 15 = SRQ1_XRQ_B; Lower 16 Requestors (15-0) */
        unsigned int trig_sel:4;            /* 0 = SMP_30_same_as_bit_14 1 = SMP_31_same_as_bit_15 2 = HRQ2_XRQ_C 3 = HRQ3_XRQ_D 4 = HRQ4_N_A 5 = HRQ5_N_A 6 = HRQ6_TMR1 7 = HRQ7_TMR2 8 = AHB_0 9 = AHB_1 10 = AHB_2 11 = AHB_3 12 = SMP_28 13 = SMP_29 14 = SMP_30 15 = SMP_31 */
        unsigned int flow:1;                /* 0 = Independent of DRQ request 0 = DISABLE 1 = ENABLE */
        unsigned int trig:1;                /* 0 = Independent of Trigger 0 = DISABLE 1 = ENABLE */
        unsigned int once:1;                /* 0 = Run for Multiple Block Transfer 0 = DISABLE 1 = ENABLE */
        unsigned int dir:1;                 /* 0 = XMB read to AHB write 0 = DISABLE 1 = ENABLE */
        unsigned int hold:1;                /* 0 = Disable 0 = DISABLE 1 = ENABLE */
        unsigned int fl_btwn:1;             /* 0 = do not flush 0 = DISABLE 1 = ENABLE */
        unsigned int ie_eoc:1;              /* 0 = NOP 0 = DISABLE 1 = ENABLE */
        unsigned int enb:1;                 /* 0 = Disable the DMA Channel 0 = DISABLE 1 = ENABLE */
    };

    uint32_t reg32;
} ahbdmachan_channel_3_csr_t;

#define AHBDMACHAN_CHANNEL_3_STA_OFFSET 0x64 + 0x1000
#define AHBDMACHAN_CHANNEL_3_STA_RESET  0x00000000
typedef union ahbdmachan_channel_3_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Remaining transfer count in 32bit word cycles Flags set / cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int halt:1;                /* 0 = NOP  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_29:1;
        unsigned int is_eoc:1;              /* Write '1' to clear the flag  0 = NO_INTR 1 = INTR */
        unsigned int bsy:1;                 /* 0 = NOP Read-only 0 = DISABLE 1 = ENABLE */
    };

    uint32_t reg32;
} ahbdmachan_channel_3_sta_t;

#define AHBDMACHAN_CHANNEL_3_AHB_PTR_OFFSET 0x70 + 0x1000
#define AHBDMACHAN_CHANNEL_3_AHB_PTR_RESET  0x00000000
typedef union ahbdmachan_channel_3_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* AHB-DMA starting address pointer for internal AHB Bus */
    };

    uint32_t reg32;
} ahbdmachan_channel_3_ahb_ptr_t;

#define AHBDMACHAN_CHANNEL_3_AHB_SEQ_OFFSET 0x74 + 0x1000
#define AHBDMACHAN_CHANNEL_3_AHB_SEQ_RESET  0x00800000
typedef union ahbdmachan_channel_3_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_stride:16;         /* This field tells us number of words that are supposed to be skipped on AHB side */
        unsigned int ahb_addr_wrap:1;       /* 0 = disable  0 = DISABLE 1 = ENABLE */
        unsigned int dbl_buf:1;             /* 0 = Reload Base Address for 1X blocks (default), reload each time 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_20:1;
        unsigned int ahb_stride_size:3;     /* 0 = disabled, otherwise stride is enabled 0 = DISABLE 1 = WORDS_4 2 = WORDS_8 3 = WORDS_16 4 = WORDS_32 5 = WORDS_64 6 = WORDS_128 7 = WORDS_256 */
        unsigned int ahb_burst:3;           /* 0,1,5-7 = rsvd 2 = WORD 3 = FOUR_WORD 4 = EIGHT_WORD */
        unsigned int ahb_data_swap:1;       /* 0 = no data conversion, when 1 and writeAhb: [31:0]->{[7:0],[15:8],[23:16],[31:24]}  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_28_30:3;
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP 1 = CPU 0 = COP */
    };

    uint32_t reg32;
} ahbdmachan_channel_3_ahb_seq_t;

#define AHBDMACHAN_CHANNEL_3_XMB_PTR_OFFSET 0x78 + 0x1000
#define AHBDMACHAN_CHANNEL_3_XMB_PTR_RESET  0x00000000
typedef union ahbdmachan_channel_3_xmb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int xmb_base:30;           /* AHB-DMA Starting address pointer for internal AHB Bus */
    };

    uint32_t reg32;
} ahbdmachan_channel_3_xmb_ptr_t;

#define AHBDMACHAN_CHANNEL_3_XMB_SEQ_OFFSET 0x7C + 0x1000
#define AHBDMACHAN_CHANNEL_3_XMB_SEQ_RESET  0x00000000
typedef union ahbdmachan_channel_3_xmb_seq_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int xmb_stride:16;         /* This field tells us number of words that are supposed to be skipped on XMB side */
        unsigned int xmb_addr_wrap:1;       /* 0 = disable  0 = DISABLE 1 = ENABLE */
        unsigned int dbl_buf:1;             /* 0 = Reload Base Address for 1X blocks (default), reload each time 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_20_26:7;
        unsigned int xmb_data_swap:1;       /* 0 = no data conversion, when 1 and writeXmb: [31:0]->{[7:0],[15:8],[23:16],[31:24]} 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_28_31:4;
    };

    uint32_t reg32;
} ahbdmachan_channel_3_xmb_seq_t;

#endif // TEGRA_AHB_DMA_H
