/*
 * ARM NVIDIA Tegra2 emulation.
 *
 * Copyright (c) 2014-2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* Autogenerated from TRM v02p */

#ifndef TEGRA_APB_DMA_H
#define TEGRA_APB_DMA_H

#define COMMAND_OFFSET 0x0
#define COMMAND_RESET  0x00000000
typedef union command_u {
    struct {
        unsigned int undefined_bits_0_30:31;
        unsigned int gen:1;                 /* Enables Global APB-DMA; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} command_t;

#define STATUS_OFFSET 0x4
#define STATUS_RESET  0x00000000
typedef union status_u {
    struct {
        unsigned int ise_eoc_0:1;           /* DMA channel0 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_1:1;           /* DMA channel1 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_2:1;           /* DMA channel2 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_3:1;           /* DMA channel3 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_4:1;           /* DMA channel4 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_5:1;           /* DMA channel5 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_6:1;           /* DMA channel6 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_7:1;           /* DMA channel7 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_8:1;           /* DMA channel8 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_9:1;           /* DMA channel9 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_10:1;          /* DMA channel10 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_11:1;          /* DMA channel11 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_12:1;          /* DMA channel12 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_13:1;          /* DMA channel13 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_14:1;          /* DMA channel14 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ise_eoc_15:1;          /* DMA channel15 Interrupt Status; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int bsy_0:1;               /* DMA channel0 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_1:1;               /* DMA channel1 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_2:1;               /* DMA channel2 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_3:1;               /* DMA channel3 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_4:1;               /* DMA channel4 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_5:1;               /* DMA channel5 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_6:1;               /* DMA channel6 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_7:1;               /* DMA channel7 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_8:1;               /* DMA channel8 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_9:1;               /* DMA channel9 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_10:1;              /* DMA channel10 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_11:1;              /* DMA channel11 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_12:1;              /* DMA channel12 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_13:1;              /* DMA channel13 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_14:1;              /* DMA channel14 status; 0 = NOT_BUSY; 1 = BUSY */
        unsigned int bsy_15:1;              /* DMA channel15 status; 0 = NOT_BUSY; 1 = BUSY */
    };

    uint32_t reg32;
} status_t;

#define REQUESTORS_TX_OFFSET 0x8
#define REQUESTORS_TX_RESET  0x00000000
typedef union requestors_tx_u {
    struct {
        unsigned int cntr_req:1;            /* 1 = Enable counter request. 0 = Disable counter request; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int i2s_2:1;               /* I2S Tx Output FIFO2 (Play) (Peripheral initiated DMA request) 1 = Activate DMA transfer0 = NOP; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int i2s_1:1;               /* I2S Tx Output FIFO1 (Record) (Peripheral initiated DMA request) 1 = Activate DMA transfer0 = NOP; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int spd_i:1;               /* SPDIF Output FIFO (Rx) (Peripheral initiated DMA request) 1 = Activate DMA transfer 0 = NOP; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ui_i:1;                /* EBU USR Output (Peripheral initiated DMA request) 1 = Activate DMA transfer 0 = NOP; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int mipi:1;                /* MIPI Rx Input FIFO */
        unsigned int i2s2_2:1;              /* I2S2 Tx Output FIFO2 (Play) (Peripheral initiated DMA request) 1 = Activate DMA transfer 0 = NOP; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int i2s2_1:1;              /* I2S2 Tx Output FIFO1 (Play) (Peripheral initiated DMA request) 1 = Activate DMA transfer 0 = NOP; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int uart_a:1;              /* UART 1; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int uart_b:1;              /* UART 2 (VFIR); 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int uart_c:1;              /* UART 3; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int spi:1;                 /* SPI Controller; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ac97:1;                /* AC97; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ac:1;                  /* 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int rsvd:1;                /* 0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int sl2b1:1;               /* SLINK 2B-1 (SPI1); 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int sl2b2:1;               /* SLINK 2B-2 (SPI2); 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int sl2b3:1;               /* SLINK 2B-3 (SPI3); 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int sl2b4:1;               /* SLINK 2B-4 (SPI4) 0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int uart_d:1;              /* UART4  0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int uart_e:1;              /* UART5  0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int i2c_1:1;               /* I2C1  0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int i2c_2:1;               /* I2C2  0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int i2c_3:1;               /* I2C3  0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int dvc_i2c:1;             /* DVC-I2C 0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int owr:1;                 /* OWR-I2C 0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} requestors_tx_t;

#define REQUESTORS_RX_OFFSET 0xC
#define REQUESTORS_RX_RESET  0x00000000
typedef union requestors_rx_u {
    struct {
        unsigned int cntr_req:1;            /* indicates Enabled counter request or not; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int i2s_1:1;               /* I2S Rx Input FIFO1 (Peripheral initiated DMA request) 1 = Activate DMA transfer 0 = NOP; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int i2s_2:1;               /* I2S Rx Input FIFO2 (Peripheral initiated DMA request) 1 = Activate DMA transfer 0 = NOP; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int spd_i:1;               /* SPDIF Input FIFO (Rx) (Peripheral initiated DMA request) 1 = Activate DMA transfer 0 = NOP; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ui_i:1;                /* EBU+SPDIF USR Input (Peripheral initiated DMA request) 1 = Activate DMA transfer 0 = NOP; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int mipi:1;                /* MIPI Rx Input FIFO */
        unsigned int i2s2_1:1;              /* I2S2 Rx Input FIFO1 (Peripheral initiated DMA request) 1 = Activate DMA transfer 0 = NOP; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int i2s2_2:1;              /* I2S2 Rx Input FIFO2 (Peripheral initiated DMA request) 1 = Activate DMA transfer 0 = NOP; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int uart_a:1;              /* UART 1; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int uart_b:1;              /* UART 2 (VFIR); 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int uart_c:1;              /* UART 3; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int spi:1;                 /* SPI Controller; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ac97:1;                /* AC97; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int ac:1;                  /* 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int rsvd:1;
        unsigned int sl2b1:1;               /* SLINK 2B-1 (SPI1); 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int sl2b2:1;               /* SLINK 2B-2 (SPI2); 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int sl2b3:1;               /* SLINK 2B-3 (SPI3); 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int sl2b4:1;               /* SLINK 2B-4 (SPI4) 0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int uart_d:1;              /* UART4  0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int uart_e:1;              /* UART5 0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int i2c_1:1;               /* I2C1  0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int i2c_2:1;               /* I2C2  0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int i2c_3:1;               /* I2C3  0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int dvc_i2c:1;             /* DVC-I2C 0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int owr:1;                 /* OWR-I2C 0 = NOT_ACTIVE 1 = ACTIVE */
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} requestors_rx_t;

#define CNTRL_REG_OFFSET 0x10
#define CNTRL_REG_RESET  0x00000000
typedef union cntrl_reg_u {
    struct {
        unsigned int count_value:16;        /* DMA COUNT Value */
        unsigned int ch0_cnt_en:1;          /* Enable the channel0 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch1_cnt_en:1;          /* Enable the channel1 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch2_cnt_en:1;          /* Enable the channel2 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch3_cnt_en:1;          /* Enable the channel3 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch4_cnt_en:1;          /* Enable the channel4 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch5_cnt_en:1;          /* Enable the channel5 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch6_cnt_en:1;          /* Enable the channel6 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch7_cnt_en:1;          /* Enable the channel7 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch8_cnt_en:1;          /* Enable the channel8 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch9_cnt_en:1;          /* Enable the channel9 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch10_cnt_en:1;         /* Enable the channel10 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch11_cnt_en:1;         /* Enable the channel11 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch12_cnt_en:1;         /* Enable the channel12 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch13_cnt_en:1;         /* Enable the channel13 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch14_cnt_en:1;         /* Enable the channel14 count; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch15_cnt_en:1;         /* Enable the channel15 count; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} cntrl_reg_t;

#define IRQ_STA_CPU_OFFSET 0x14
#define IRQ_STA_CPU_RESET  0x00000000
typedef union irq_sta_cpu_u {
    struct {
        unsigned int ch0:1;                 /* Gathers all the after-masking CPU directed IRQ status bits from channel0 */
        unsigned int ch1:1;                 /* Gathers all the after-masking CPU directed IRQ status bits from channel1; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch2:1;                 /* Gathers all the after-masking CPU directed IRQ status bits from channel2; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch3:1;                 /* Gathers all the after-masking CPU directed IRQ status bits from channel3; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch4:1;                 /* Gathers all the after-masking CPU directed IRQ status bits from channel4; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch5:1;                 /* Gathers all the after-masking CPU directed IRQ status bits from channel5; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch6:1;                 /* Gathers all the after-masking CPU directed IRQ status bits from channel6; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch7:1;                 /* Gathers all the after-masking CPU directed IRQ status bits from channel7; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch8:1;                 /* Gathers all the after-masking CPU directed IRQ status bits from channel8; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch9:1;                 /* Gathers all the after-masking CPU directed IRQ status bits from channel9; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch10:1;                /* Gathers all the after-masking CPU directed IRQ status bits from channel10; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch11:1;                /* Gathers all the after-masking CPU directed IRQ status bits from channel11; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch12:1;                /* Gathers all the after-masking CPU directed IRQ status bits from channel12; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch13:1;                /* Gathers all the after-masking CPU directed IRQ status bits from channel13; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch14:1;                /* Gathers all the after-masking CPU directed IRQ status bits from channel14; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch15:1;                /* Gathers all the after-masking CPU directed IRQ status bits from channel15; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} irq_sta_cpu_t;

#define IRQ_STA_COP_OFFSET 0x18
#define IRQ_STA_COP_RESET  0x00000000
typedef union irq_sta_cop_u {
    struct {
        unsigned int ch0:1;                 /* Gathers all the after-masking COP directed IRQ status bits from channel0 */
        unsigned int ch1:1;                 /* Gathers all the after-masking COP directed IRQ status bits from channel1; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch2:1;                 /* Gathers all the after-masking COP directed IRQ status bits from channel2; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch3:1;                 /* Gathers all the after-masking COP directed IRQ status bits from channel3; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch4:1;                 /* Gathers all the after-masking COP directed IRQ status bits from channel4; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch5:1;                 /* Gathers all the after-masking COP directed IRQ status bits from channel5; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch6:1;                 /* Gathers all the after-masking COP directed IRQ status bits from channel6; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch7:1;                 /* Gathers all the after-masking COP directed IRQ status bits from channel7; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch8:1;                 /* Gathers all the after-masking COP directed IRQ status bits from channel8; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch9:1;                 /* Gathers all the after-masking COP directed IRQ status bits from channel9; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch10:1;                /* Gathers all the after-masking COP directed IRQ status bits from channel10; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch11:1;                /* Gathers all the after-masking COP directed IRQ status bits from channel11; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch12:1;                /* Gathers all the after-masking COP directed IRQ status bits from channel12; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch13:1;                /* Gathers all the after-masking COP directed IRQ status bits from channel13; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch14:1;                /* Gathers all the after-masking COP directed IRQ status bits from channel14; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch15:1;                /* Gathers all the after-masking COP directed IRQ status bits from channel15; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} irq_sta_cop_t;

#define IRQ_MASK_OFFSET 0x1C
#define IRQ_MASK_RESET  0x00000000
typedef union irq_mask_u {
    struct {
        unsigned int ch0:1;                 /* Each bit allows the associated channel0 IRQ to propagate when '1' */
        unsigned int ch1:1;                 /* Each bit allows the associated channel1 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch2:1;                 /* Each bit allows the associated channel2 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch3:1;                 /* Each bit allows the associated channel3 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch4:1;                 /* Each bit allows the associated channel4 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch5:1;                 /* Each bit allows the associated channel5 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch6:1;                 /* Each bit allows the associated channel6 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch7:1;                 /* Each bit allows the associated channel7 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch8:1;                 /* Each bit allows the associated channel8 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch9:1;                 /* Each bit allows the associated channel9 IRQ to propagate when '1; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch10:1;                /* Each bit allows the associated channel10 IRQ to propagate when '1' 0 = DISABLE; 1 = ENABLE */
        unsigned int ch11:1;                /* Each bit allows the associated channel11 IRQ to propagate when '1' 0 = DISABLE; 1 = ENABLE */
        unsigned int ch12:1;                /* Each bit allows the associated channel12 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch13:1;                /* Each bit allows the associated channel13 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch14:1;                /* Each bit allows the associated channel14 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch15:1;                /* Each bit allows the associated channel15 IRQ to propagate when '1'; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} irq_mask_t;

#define IRQ_MASK_SET_OFFSET 0x20
#define IRQ_MASK_SET_RESET  0x00000000
typedef union irq_mask_set_u {
    struct {
        unsigned int ch0:1;                 /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch1:1;                 /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch2:1;                 /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch3:1;                 /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch4:1;                 /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch5:1;                 /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch6:1;                 /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch7:1;                 /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch8:1;                 /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch9:1;                 /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch10:1;                /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch11:1;                /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch12:1;                /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch13:1;                /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch14:1;                /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch15:1;                /* Sets the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} irq_mask_set_t;

#define IRQ_MASK_CLR_OFFSET 0x24
#define IRQ_MASK_CLR_RESET  0x00000000
typedef union irq_mask_clr_u {
    struct {
        unsigned int ch0:1;                 /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch1:1;                 /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch2:1;                 /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch3:1;                 /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch4:1;                 /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch5:1;                 /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch6:1;                 /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch7:1;                 /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch8:1;                 /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch9:1;                 /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch10:1;                /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch11:1;                /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch12:1;                /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch13:1;                /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch14:1;                /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int ch15:1;                /* Clears the Mask Register; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} irq_mask_clr_t;

#define TRIG_REG_OFFSET 0x28
#define TRIG_REG_RESET  0x00000000
typedef union trig_reg_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int smp_24:1;              /* Semaphore requests SW initiated DMA request; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int smp_25:1;              /* Semaphore requests SW initiated DMA request; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int smp_26:1;              /* Semaphore requests SW initiated DMA request; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int smp_27:1;              /* Semaphore requests SW initiated DMA request; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int xrq_a:1;               /* XRQ.A (GPIOA) (Hardware initiated DMA request); 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int xrq_b:1;               /* XRQ.B (GPIOB) (Hardware initiated DMA request); 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int tmr1:1;                /* Trigger select from Timer (Hardware initiated DMA request); 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int tmr2:1;                /* Trigger select from Timer (Hardware initiated DMA request); 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_0:1;               /* EOC-0 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_1:1;               /* EOC-1 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_2:1;               /* EOC-2 Initiated DMA Request after transfer completion); 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_3:1;               /* EOC-3 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_4:1;               /* EOC-4 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_5:1;               /* EOC-5 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_6:1;               /* EOC-6 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_7:1;               /* EOC-7 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_8:1;               /* EOC-8 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_9:1;               /* EOC-9 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_10:1;              /* EOC-10 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_11:1;              /* EOC-11 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_12:1;              /* EOC-12 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_13:1;              /* EOC-13 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_14:1;              /* EOC-14 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int apb_15:1;              /* EOC-15 Initiated DMA Request after transfer completion; 0 = NOT_ACTIVE; 1 = ACTIVE */
        unsigned int undefined_bits_25_31:7;
    };

    uint32_t reg32;
} trig_reg_t;

#define CHANNEL_0_CSR_OFFSET 0x1000
#define CHANNEL_0_CSR_RESET  0x00000000
typedef union channel_0_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_0_csr_t;

#define CHANNEL_0_STA_OFFSET 0x1004
#define CHANNEL_0_STA_RESET  0x00000000
#define CHANNEL_0_STA_WRMASK 0x4FFF0003
typedef union channel_0_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* if dir = AHB_WRITE : 0 - ping buffer transfer completed ; 1 - pong buffer transfer completed if dir = AHB_READ : 1 - ping buffer transfer completed ; 0 - pong buffer transfer completed; 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicates whether DMA Channel Status active or not; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_0_sta_t;

#define CHANNEL_0_AHB_PTR_OFFSET 0x1010
#define CHANNEL_0_AHB_PTR_RESET  0x00000000
typedef union channel_0_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_0_ahb_ptr_t;

#define CHANNEL_0_AHB_SEQ_OFFSET 0x1014
#define CHANNEL_0_AHB_SEQ_RESET  0x00002000
typedef union channel_0_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int dbl_buf:1;             /* 2X Double Buffering Mode (For Run-Multiple Mode with No Wrap Operations) 1 = Reload Base Address for 2X blocks (reload every other time) 0 = Reload Base Address for 1X blocks (def) (reload each time) 0 = RELOAD_FOR_1X_BLOCKS 1 = RELOAD_FOR_2X_BLOCKS */
        unsigned int undefined_bits_20_23:4;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits) else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24] }; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP */
    };

    uint32_t reg32;
} channel_0_ahb_seq_t;

#define CHANNEL_0_APB_PTR_OFFSET 0x1018
#define CHANNEL_0_APB_PTR_RESET  0x00000000
typedef union channel_0_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper  16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_0_apb_ptr_t;

#define CHANNEL_0_APB_SEQ_OFFSET 0x101C
#define CHANNEL_0_APB_SEQ_RESET  0x00002001
typedef union channel_0_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISBALE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_0_apb_seq_t;

#define CHANNEL_1_CSR_OFFSET 0x1020
#define CHANNEL_1_CSR_RESET  0x00000000
typedef union channel_1_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SL2B4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_1_csr_t;

#define CHANNEL_1_STA_OFFSET 0x1024
#define CHANNEL_1_STA_RESET  0x00000000
#define CHANNEL_1_STA_WRMASK 0x4FFF0003
typedef union channel_1_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicates whether DMA Channel Status active or not; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_1_sta_t;

#define CHANNEL_1_AHB_PTR_OFFSET 0x1030
#define CHANNEL_1_AHB_PTR_RESET  0x00000000
typedef union channel_1_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_1_ahb_ptr_t;

#define CHANNEL_1_AHB_SEQ_OFFSET 0x1034
#define CHANNEL_1_AHB_SEQ_RESET  0x00002000
typedef union channel_1_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int dbl_buf:1;             /* 2X Double Buffering Mode (For Run-Multiple Mode with No Wrap Operations) 1 = Reload Base Address for 2X blocks (reload every other time) 0 = Reload Base Address for 1X blocks (def) (reload each time); 0 = RELOAD_FOR_1X_BLOCKS; 1 = RELOAD_FOR_2X_BLOCKS */
        unsigned int undefined_bits_20_23:4;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits)else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD)4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_1_ahb_seq_t;

#define CHANNEL_1_APB_PTR_OFFSET 0x1038
#define CHANNEL_1_APB_PTR_RESET  0x00000000
typedef union channel_1_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper 16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_1_apb_ptr_t;

#define CHANNEL_1_APB_SEQ_OFFSET 0x103C
#define CHANNEL_1_APB_SEQ_RESET  0x00002001
typedef union channel_1_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISBALE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_1_apb_seq_t;

#define CHANNEL_2_CSR_OFFSET 0x1040
#define CHANNEL_2_CSR_RESET  0x00000000
typedef union channel_2_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4; 19 = UART4; 20 = UART5; 21 = I2C; 22 = I2C2; 23 = I2C3; 24 = DVC_I2C; 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_2_csr_t;

#define CHANNEL_2_STA_OFFSET 0x1044
#define CHANNEL_2_STA_RESET  0x00000000
#define CHANNEL_2_STA_WRMASK 0x4FFF0003
typedef union channel_2_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicates whether DMA Channel Status active or not; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_2_sta_t;

#define CHANNEL_2_AHB_PTR_OFFSET 0x1050
#define CHANNEL_2_AHB_PTR_RESET  0x00000000
typedef union channel_2_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_2_ahb_ptr_t;

#define CHANNEL_2_AHB_SEQ_OFFSET 0x1054
#define CHANNEL_2_AHB_SEQ_RESET  0x00002000
typedef union channel_2_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int dbl_buf:1;             /* 2X Double Buffering Mode (For Run-Multiple Mode with No Wrap Operations) 1 = Reload Base Address for 2X blocks (reload every other time) 0 = Reload Base Address for 1X blocks (def) (reload each time); 0 = RELOAD_FOR_1X_BLOCKS; 1 = RELOAD_FOR_2X_BLOCKS */
        unsigned int undefined_bits_20_23:4;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits)else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD)4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_2_ahb_seq_t;

#define CHANNEL_2_APB_PTR_OFFSET 0x1058
#define CHANNEL_2_APB_PTR_RESET  0x00000000
typedef union channel_2_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper 16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_2_apb_ptr_t;

#define CHANNEL_2_APB_SEQ_OFFSET 0x105C
#define CHANNEL_2_APB_SEQ_RESET  0x00002001
typedef union channel_2_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISBALE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_2_apb_seq_t;

#define CHANNEL_3_CSR_OFFSET 0x1060
#define CHANNEL_3_CSR_RESET  0x00000000
typedef union channel_3_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_3_csr_t;

#define CHANNEL_3_STA_OFFSET 0x1064
#define CHANNEL_3_STA_RESET  0x00000000
#define CHANNEL_3_STA_WRMASK 0x4FFF0003
typedef union channel_3_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicates whether DMA Channel Status active; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_3_sta_t;

#define CHANNEL_3_AHB_PTR_OFFSET 0x1070
#define CHANNEL_3_AHB_PTR_RESET  0x00000000
typedef union channel_3_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_3_ahb_ptr_t;

#define CHANNEL_3_AHB_SEQ_OFFSET 0x1074
#define CHANNEL_3_AHB_SEQ_RESET  0x00002000
typedef union channel_3_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int undefined_bits_19_23:5;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits)else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD)4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_3_ahb_seq_t;

#define CHANNEL_3_APB_PTR_OFFSET 0x1078
#define CHANNEL_3_APB_PTR_RESET  0x00000000
typedef union channel_3_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper 16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_3_apb_ptr_t;

#define CHANNEL_3_APB_SEQ_OFFSET 0x107C
#define CHANNEL_3_APB_SEQ_RESET  0x00002001
typedef union channel_3_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24] }; 0 = DISBALE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_3_apb_seq_t;

#define CHANNEL_4_CSR_OFFSET 0x1080
#define CHANNEL_4_CSR_RESET  0x00000000
typedef union channel_4_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_4_csr_t;

#define CHANNEL_4_STA_OFFSET 0x1084
#define CHANNEL_4_STA_RESET  0x00000000
#define CHANNEL_4_STA_WRMASK 0x4FFF0003
typedef union channel_4_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicates whether DMA Channel Status active or not; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_4_sta_t;

#define CHANNEL_4_AHB_PTR_OFFSET 0x1090
#define CHANNEL_4_AHB_PTR_RESET  0x00000000
typedef union channel_4_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_4_ahb_ptr_t;

#define CHANNEL_4_AHB_SEQ_OFFSET 0x1094
#define CHANNEL_4_AHB_SEQ_RESET  0x00002000
typedef union channel_4_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int dbl_buf:1;             /* 2X Double Buffering Mode (For Run-Multiple Mode with No Wrap Operations) 1 = Reload Base Address for 2X blocks (reload every other time) 0 = Reload Base Address for 1X blocks (def) (reload each time); 0 = RELOAD_FOR_1X_BLOCKS; 1 = RELOAD_FOR_2X_BLOCKS */
        unsigned int undefined_bits_20_23:4;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits)else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24] }; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_4_ahb_seq_t;

#define CHANNEL_4_APB_PTR_OFFSET 0x1098
#define CHANNEL_4_APB_PTR_RESET  0x00000000
typedef union channel_4_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper  16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_4_apb_ptr_t;

#define CHANNEL_4_APB_SEQ_OFFSET 0x109C
#define CHANNEL_4_APB_SEQ_RESET  0x00002001
typedef union channel_4_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISBALE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_4_apb_seq_t;

#define CHANNEL_5_CSR_OFFSET 0x10A0
#define CHANNEL_5_CSR_RESET  0x00000000
typedef union channel_5_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_5_csr_t;

#define CHANNEL_5_STA_OFFSET 0x10A4
#define CHANNEL_5_STA_RESET  0x00000000
#define CHANNEL_5_STA_WRMASK 0x4FFF0003
typedef union channel_5_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicate whether DMA Channel Status active or not; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_5_sta_t;

#define CHANNEL_5_AHB_PTR_OFFSET 0x10B0
#define CHANNEL_5_AHB_PTR_RESET  0x00000000
typedef union channel_5_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_5_ahb_ptr_t;

#define CHANNEL_5_AHB_SEQ_OFFSET 0x10B4
#define CHANNEL_5_AHB_SEQ_RESET  0x00002000
typedef union channel_5_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int dbl_buf:1;             /* 2X Double Buffering Mode (For Run-Multiple Mode with No Wrap Operations) 1 = Reload Base Address for 2X blocks (reload every other time) 0 = Reload Base Address for 1X blocks (def) (reload each time); 0 = RELOAD_FOR_1X_BLOCKS; 1 = RELOAD_FOR_2X_BLOCKS */
        unsigned int undefined_bits_20_23:4;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits)else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD)4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_5_ahb_seq_t;

#define CHANNEL_5_APB_PTR_OFFSET 0x10B8
#define CHANNEL_5_APB_PTR_RESET  0x00000000
typedef union channel_5_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper  16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_5_apb_ptr_t;

#define CHANNEL_5_APB_SEQ_OFFSET 0x10BC
#define CHANNEL_5_APB_SEQ_RESET  0x00002001
typedef union channel_5_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISBALE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_5_apb_seq_t;

#define CHANNEL_6_CSR_OFFSET 0x10C0
#define CHANNEL_6_CSR_RESET  0x00000000
typedef union channel_6_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_6_csr_t;

#define CHANNEL_6_STA_OFFSET 0x10C4
#define CHANNEL_6_STA_RESET  0x00000000
#define CHANNEL_6_STA_WRMASK 0x4FFF0003
typedef union channel_6_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicate whether DMA Channel Status active or not; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_6_sta_t;

#define CHANNEL_6_AHB_PTR_OFFSET 0x10D0
#define CHANNEL_6_AHB_PTR_RESET  0x00000000
typedef union channel_6_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_6_ahb_ptr_t;

#define CHANNEL_6_AHB_SEQ_OFFSET 0x10D4
#define CHANNEL_6_AHB_SEQ_RESET  0x00002000
typedef union channel_6_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int dbl_buf:1;             /* 2X Double Buffering Mode (For Run-Multiple Mode with No Wrap Operations) 1 = Reload Base Address for 2X blocks (reload every other time) 0 = Reload Base Address for 1X blocks (def) (reload each time); 0 = RELOAD_FOR_1X_BLOCKS; 1 = RELOAD_FOR_2X_BLOCKS */
        unsigned int undefined_bits_20_23:4;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits)else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD)4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_6_ahb_seq_t;

#define CHANNEL_6_APB_PTR_OFFSET 0x10D8
#define CHANNEL_6_APB_PTR_RESET  0x00000000
typedef union channel_6_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper  16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_6_apb_ptr_t;

#define CHANNEL_6_APB_SEQ_OFFSET 0x10DC
#define CHANNEL_6_APB_SEQ_RESET  0x00002001
typedef union channel_6_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISBALE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_6_apb_seq_t;

#define CHANNEL_7_CSR_OFFSET 0x10E0
#define CHANNEL_7_CSR_RESET  0x00000000
typedef union channel_7_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_7_csr_t;

#define CHANNEL_7_STA_OFFSET 0x10E4
#define CHANNEL_7_STA_RESET  0x00000000
#define CHANNEL_7_STA_WRMASK 0x4FFF0003
typedef union channel_7_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag 0 = NO_INTR 1 = INTR */
        unsigned int bsy:1;                 /* indicate whether DMA Channel Status Active or not; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_7_sta_t;

#define CHANNEL_7_AHB_PTR_OFFSET 0x10F0
#define CHANNEL_7_AHB_PTR_RESET  0x00000000
typedef union channel_7_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_7_ahb_ptr_t;

#define CHANNEL_7_AHB_SEQ_OFFSET 0x10F4
#define CHANNEL_7_AHB_SEQ_RESET  0x00002000
typedef union channel_7_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int dbl_buf:1;             /* 2X Double Buffering Mode (For Run-Multiple Mode with No Wrap Operations) 1 = Reload Base Address for 2X blocks (reload every other time) 0 = Reload Base Address for 1X blocks (def) (reload each time); 0 = RELOAD_FOR_1X_BLOCKS; 1 = RELOAD_FOR_2X_BLOCKS */
        unsigned int undefined_bits_20_23:4;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits)else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_7_ahb_seq_t;

#define CHANNEL_7_APB_PTR_OFFSET 0x10F8
#define CHANNEL_7_APB_PTR_RESET  0x00000000
typedef union channel_7_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper  16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_7_apb_ptr_t;

#define CHANNEL_7_APB_SEQ_OFFSET 0x10FC
#define CHANNEL_7_APB_SEQ_RESET  0x00002001
typedef union channel_7_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISABLE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_7_apb_seq_t;

#define CHANNEL_8_CSR_OFFSET 0x1100
#define CHANNEL_8_CSR_RESET  0x00000000
typedef union channel_8_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_8_csr_t;

#define CHANNEL_8_STA_OFFSET 0x1104
#define CHANNEL_8_STA_RESET  0x00000000
#define CHANNEL_8_STA_WRMASK 0x4FFF0003
typedef union channel_8_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicate DMA Channel Status activate or not; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_8_sta_t;

#define CHANNEL_8_AHB_PTR_OFFSET 0x1110
#define CHANNEL_8_AHB_PTR_RESET  0x00000000
typedef union channel_8_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_8_ahb_ptr_t;

#define CHANNEL_8_AHB_SEQ_OFFSET 0x1114
#define CHANNEL_8_AHB_SEQ_RESET  0x00002000
typedef union channel_8_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int dbl_buf:1;             /* 2X Double Buffering Mode (For Run-Multiple Mode with No Wrap Operations) 1 = Reload Base Address for 2X blocks (reload every other time) 0 = Reload Base Address for 1X blocks (def) (reload each time); 0 = RELOAD_FOR_1X_BLOCKS; 1 = RELOAD_FOR_2X_BLOCKS */
        unsigned int undefined_bits_20_23:4;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits)else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_8_ahb_seq_t;

#define CHANNEL_8_APB_PTR_OFFSET 0x1118
#define CHANNEL_8_APB_PTR_RESET  0x00000000
typedef union channel_8_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper  16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_8_apb_ptr_t;

#define CHANNEL_8_APB_SEQ_OFFSET 0x111C
#define CHANNEL_8_APB_SEQ_RESET  0x00002001
typedef union channel_8_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24] }; 0 = DISBALE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_8_apb_seq_t;

#define CHANNEL_9_CSR_OFFSET 0x1120
#define CHANNEL_9_CSR_RESET  0x00000000
typedef union channel_9_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_9_csr_t;

#define CHANNEL_9_STA_OFFSET 0x1124
#define CHANNEL_9_STA_RESET  0x00000000
#define CHANNEL_9_STA_WRMASK 0x4FFF0003
typedef union channel_9_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicate DMA Channel Status activate or not; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_9_sta_t;

#define CHANNEL_9_AHB_PTR_OFFSET 0x1130
#define CHANNEL_9_AHB_PTR_RESET  0x00000000
typedef union channel_9_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_9_ahb_ptr_t;

#define CHANNEL_9_AHB_SEQ_OFFSET 0x1134
#define CHANNEL_9_AHB_SEQ_RESET  0x00002000
typedef union channel_9_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int dbl_buf:1;             /* 2X Double Buffering Mode (For Run-Multiple Mode with No Wrap Operations) 1 = Reload Base Address for 2X blocks (reload every other time) 0 = Reload Base Address for 1X blocks (def) (reload each time); 0 = RELOAD_FOR_1X_BLOCKS; 1 = RELOAD_FOR_2X_BLOCKS */
        unsigned int undefined_bits_20_23:4;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits)else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD)4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_9_ahb_seq_t;

#define CHANNEL_9_APB_PTR_OFFSET 0x1138
#define CHANNEL_9_APB_PTR_RESET  0x00000000
typedef union channel_9_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper 16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_9_apb_ptr_t;

#define CHANNEL_9_APB_SEQ_OFFSET 0x113C
#define CHANNEL_9_APB_SEQ_RESET  0x00002001
typedef union channel_9_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24] }; 0 = DISBALE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_9_apb_seq_t;

#define CHANNEL_10_CSR_OFFSET 0x1140
#define CHANNEL_10_CSR_RESET  0x00000000
typedef union channel_10_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0= CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes 1 = Enable Hold (wait) 0 = Disable; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_10_csr_t;

#define CHANNEL_10_STA_OFFSET 0x1144
#define CHANNEL_10_STA_RESET  0x00000000
#define CHANNEL_10_STA_WRMASK 0x4FFF0003
typedef union channel_10_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicate DMA Channel Status activate or not; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_10_sta_t;

#define CHANNEL_10_AHB_PTR_OFFSET 0x1150
#define CHANNEL_10_AHB_PTR_RESET  0x00000000
typedef union channel_10_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_10_ahb_ptr_t;

#define CHANNEL_10_AHB_SEQ_OFFSET 0x1154
#define CHANNEL_10_AHB_SEQ_RESET  0x00002000
typedef union channel_10_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int dbl_buf:1;             /* 2X Double Buffering Mode (For Run-Multiple Mode with No Wrap Operations) 1 = Reload Base Address for 2X blocks (reload every other time) 0 = Reload Base Address for 1X blocks (def) (reload each time); 0 = RELOAD_FOR_1X_BLOCKS; 1 = RELOAD_FOR_2X_BLOCKS */
        unsigned int undefined_bits_20_23:4;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits)else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD)4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_10_ahb_seq_t;

#define CHANNEL_10_APB_PTR_OFFSET 0x1158
#define CHANNEL_10_APB_PTR_RESET  0x00000000
typedef union channel_10_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper 16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_10_apb_ptr_t;

#define CHANNEL_10_APB_SEQ_OFFSET 0x115C
#define CHANNEL_10_APB_SEQ_RESET  0x00002001
typedef union channel_10_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISBALE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_10_apb_seq_t;

#define CHANNEL_11_CSR_OFFSET 0x1160
#define CHANNEL_11_CSR_RESET  0x00000000
typedef union channel_11_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_11_csr_t;

#define CHANNEL_11_STA_OFFSET 0x1164
#define CHANNEL_11_STA_RESET  0x00000000
#define CHANNEL_11_STA_WRMASK 0x4FFF0003
typedef union channel_11_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicate DMA Channel Status activate or waiting; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_11_sta_t;

#define CHANNEL_11_AHB_PTR_OFFSET 0x1170
#define CHANNEL_11_AHB_PTR_RESET  0x00000000
typedef union channel_11_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_11_ahb_ptr_t;

#define CHANNEL_11_AHB_SEQ_OFFSET 0x1174
#define CHANNEL_11_AHB_SEQ_RESET  0x00002000
typedef union channel_11_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int undefined_bits_19_23:5;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits) else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD)4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_11_ahb_seq_t;

#define CHANNEL_11_APB_PTR_OFFSET 0x1178
#define CHANNEL_11_APB_PTR_RESET  0x00000000
typedef union channel_11_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper 16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_11_apb_ptr_t;

#define CHANNEL_11_APB_SEQ_OFFSET 0x117C
#define CHANNEL_11_APB_SEQ_RESET  0x00002001
typedef union channel_11_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISBALE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_11_apb_seq_t;

#define CHANNEL_12_CSR_OFFSET 0x1180
#define CHANNEL_12_CSR_RESET  0x00000000
typedef union channel_12_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_12_csr_t;

#define CHANNEL_12_STA_OFFSET 0x1184
#define CHANNEL_12_STA_RESET  0x00000000
#define CHANNEL_12_STA_WRMASK 0x4FFF0003
typedef union channel_12_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicate DMA Channel Status activate or not; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_12_sta_t;

#define CHANNEL_12_AHB_PTR_OFFSET 0x1190
#define CHANNEL_12_AHB_PTR_RESET  0x00000000
typedef union channel_12_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_12_ahb_ptr_t;

#define CHANNEL_12_AHB_SEQ_OFFSET 0x1194
#define CHANNEL_12_AHB_SEQ_RESET  0x00002000
typedef union channel_12_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int dbl_buf:1;             /* 2X Double Buffering Mode (For Run-Multiple Mode with No Wrap Operations) 1 = Reload Base Address for 2X blocks (reload every other time) 0 = Reload Base Address for 1X blocks (def) (reload each time); 0 = RELOAD_FOR_1X_BLOCKS; 1 = RELOAD_FOR_2X_BLOCKS */
        unsigned int undefined_bits_20_23:4;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits)else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24] }; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD)4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_12_ahb_seq_t;

#define CHANNEL_12_APB_PTR_OFFSET 0x1198
#define CHANNEL_12_APB_PTR_RESET  0x00000000
typedef union channel_12_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper  16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_12_apb_ptr_t;

#define CHANNEL_12_APB_SEQ_OFFSET 0x119C
#define CHANNEL_12_APB_SEQ_RESET  0x00002001
typedef union channel_12_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISBALE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_12_apb_seq_t;

#define CHANNEL_13_CSR_OFFSET 0x11A0
#define CHANNEL_13_CSR_RESET  0x00000000
typedef union channel_13_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0= AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_13_csr_t;

#define CHANNEL_13_STA_OFFSET 0x11A4
#define CHANNEL_13_STA_RESET  0x00000000
#define CHANNEL_13_STA_WRMASK 0x4FFF0003
typedef union channel_13_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicate DMA Channel Status activate or not; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_13_sta_t;

#define CHANNEL_13_AHB_PTR_OFFSET 0x11B0
#define CHANNEL_13_AHB_PTR_RESET  0x00000000
typedef union channel_13_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_13_ahb_ptr_t;

#define CHANNEL_13_AHB_SEQ_OFFSET 0x11B4
#define CHANNEL_13_AHB_SEQ_RESET  0x00002000
typedef union channel_13_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int dbl_buf:1;             /* 2X Double Buffering Mode (For Run-Multiple Mode with No Wrap Operations) 1 = Reload Base Address for 2X blocks (reload every other time) 0 = Reload Base Address for 1X blocks (def) (reload each time); 0 = RELOAD_FOR_1X_BLOCKS; 1 = RELOAD_FOR_2X_BLOCKS */
        unsigned int undefined_bits_20_23:4;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits)else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24] }; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD)4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_13_ahb_seq_t;

#define CHANNEL_13_APB_PTR_OFFSET 0x11B8
#define CHANNEL_13_APB_PTR_RESET  0x00000000
typedef union channel_13_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper  16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_13_apb_ptr_t;

#define CHANNEL_13_APB_SEQ_OFFSET 0x11BC
#define CHANNEL_13_APB_SEQ_RESET  0x00002001
typedef union channel_13_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0= DISBALE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_13_apb_seq_t;

#define CHANNEL_14_CSR_OFFSET 0x11C0
#define CHANNEL_14_CSR_RESET  0x00000000
typedef union channel_14_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_14_csr_t;

#define CHANNEL_14_STA_OFFSET 0x11C4
#define CHANNEL_14_STA_RESET  0x00000000
#define CHANNEL_14_STA_WRMASK 0x4FFF0003
typedef union channel_14_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicate DMA Channel Status activate or not; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_14_sta_t;

#define CHANNEL_14_AHB_PTR_OFFSET 0x11D0
#define CHANNEL_14_AHB_PTR_RESET  0x00000000
typedef union channel_14_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_14_ahb_ptr_t;

#define CHANNEL_14_AHB_SEQ_OFFSET 0x11D4
#define CHANNEL_14_AHB_SEQ_RESET  0x00002000
typedef union channel_14_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int dbl_buf:1;             /* 2X Double Buffering Mode (For Run-Multiple Mode with No Wrap Operations) 1 = Reload Base Address for 2X blocks (reload every other time) 0 = Reload Base Address for 1X blocks (def) (reload each time); 0 = RELOAD_FOR_1X_BLOCKS; 1 = RELOAD_FOR_2X_BLOCKS */
        unsigned int undefined_bits_20_23:4;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits)else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD)4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_14_ahb_seq_t;

#define CHANNEL_14_APB_PTR_OFFSET 0x11D8
#define CHANNEL_14_APB_PTR_RESET  0x00000000
typedef union channel_14_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper  16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_14_apb_ptr_t;

#define CHANNEL_14_APB_SEQ_OFFSET 0x11DC
#define CHANNEL_14_APB_SEQ_RESET  0x00002001
typedef union channel_14_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around Window 0 = No Wrap 1 = Wrap on 1 Word Window (def) 2 = Wrap on 2 Word Window 3 = Wrap on 4 Word Window 4 = Wrap on 8 Word Window 5 = Wrap on 16 Word Window 6 = Wrap on 32 Word Window 7 = Wrap on 64 Word Window (RSVD); 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISBALE; 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_14_apb_seq_t;

#define CHANNEL_15_CSR_OFFSET 0x11E0
#define CHANNEL_15_CSR_RESET  0x00000000
typedef union channel_15_csr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int wcount:14;             /* Number of 32bit word cycles */
        unsigned int req_sel:5;             /* 0 = CNTR_REQ; 1 = I2S_2; 2 = I2S_1; 3 = SPD_I; 4 = UI_I; 5 = MIPI; 6 = I2S2_2; 7 = I2S2_1; 8 = UART1; 9 = UART2; 10 = UART3; 11 = SPI; 12 = AC97; 13 = AC Modem; 14 = RSVD; 15 = SPI1; 16 = SPI2; 17 = SPI3; 18 = SPI4 19 = UART4 20 = UART5 21 = I2C 22 = I2C2 23 = I2C3 24 = DVC_I2C 25 = OWR; 26 = NA26; 27 = NA27; 28 = NA28; 29 = NA29; 30 = NA30; 31 = NA31 */
        unsigned int flow:1;                /* Flow Control Enable (Synchronize Burst Transfers) 1 = Link to DRQ source 0 = Independent of DRQ request; 0 = DISABLE; 1 = ENABLE */
        unsigned int trig_sel:5;            /* Enable on Non-Zero Value; 0 = NA1; 1 = SMP24; 2 = SMP25; 3 = SMP26; 4 = SMP27; 5 = XRQ_A; 6 = XRQ_B; 7 = TMR1; 8 = TMR2; 9 = APB_0; 10 = APB_1; 11 = APB_2; 12 = APB_3; 13 = APB_4; 14 = APB_5; 15 = APB_6; 16 = APB_7; 17 = APB_8; 18 = APB_9; 19 = APB_10; 20 = APB_11; 21 = APB_12; 22 = APB_13; 23 = APB_14; 24 = APB_15 */
        unsigned int once:1;                /* Run Once or Run Multiple Mode (Allow Retriggering of this Channel) 1 = Run for One Block Transfer 0 = Run for Multiple Block Transfer; 0 = MULTIPLE_BLOCK; 1 = SINGLE_BLOCK */
        unsigned int dir:1;                 /* DMA Transfer Direction 1 = AHB read to APB write 0 = APB read to AHB write; 0 = AHB_WRITE; 1 = AHB_READ */
        unsigned int hold:1;                /* Hold this Processor until DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eoc:1;              /* Interrupt when DMA Block Transfer Completes; 0 = DISABLE; 1 = ENABLE */
        unsigned int enb:1;                 /* Enable DMA channel transfer; 0 = DISABLE; 1 = ENABLE */
    };

    uint32_t reg32;
} channel_15_csr_t;

#define CHANNEL_15_STA_OFFSET 0x11E4
#define CHANNEL_15_STA_RESET  0x00000000
#define CHANNEL_15_STA_WRMASK 0x4FFF0003
typedef union channel_15_sta_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int count:14;              /* Current 32bit word cycles Flags set /cleared by HW */
        unsigned int undefined_bits_16_27:12;
        unsigned int ping_pong_sts:1;       /* 0 = PING_INTR_STS; 1 = PONG_INTR_STS */
        unsigned int halt:1;                /* Holding Status of Processor; 0 = NO_HALT; 1 = HALT */
        unsigned int ise_eoc:1;             /* Write '1' to clear the flag; 0 = NO_INTR; 1 = INTR */
        unsigned int bsy:1;                 /* indicate DMA Channel Status activate or not; 0 = WAIT; 1 = ACTIVE */
    };

    uint32_t reg32;
} channel_15_sta_t;

#define CHANNEL_15_AHB_PTR_OFFSET 0x11F0
#define CHANNEL_15_AHB_PTR_RESET  0x00000000
typedef union channel_15_ahb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int ahb_base:30;           /* APB-DMA Starting Address for AHB Bus: SW writes to modify */
    };

    uint32_t reg32;
} channel_15_ahb_ptr_t;

#define CHANNEL_15_AHB_SEQ_OFFSET 0x11F4
#define CHANNEL_15_AHB_SEQ_RESET  0x00002000
typedef union channel_15_ahb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int wrap:3;                /* AHB Address Wrap: AHB Address wrap-around window 0=No Wrap (default) 5=Wrap on 512 word window 1=Wrap on 32 word window 6=Wrap on 1024 word window 2=Wrap on 64 word window 7=Wrap on 2048 word window 3=Wrap on 128 word window 4=Wrap on 256 word window; 0 = NO_WRAP; 1 = WRAP_0N_32WORDS; 2 = WRAP_ON_64WORDS; 3 = WRAP_ON_128WORDS; 4 = WRAP_ON_256WORDS; 5 = WRAP_ON_512WORDS; 6 = WRAP_ON_1024WORDS; 7 = WRAP_ON_2048WORDS */
        unsigned int dbl_buf:1;             /* 2X Double Buffering Mode (For Run-Multiple Mode with No Wrap Operations) 1 = Reload Base Address for 2X blocks (reload every other time) 0 = Reload Base Address for 1X blocks (def) (reload each time); 0 = RELOAD_FOR_1X_BLOCKS; 1 = RELOAD_FOR_2X_BLOCKS */
        unsigned int undefined_bits_20_23:4;
        unsigned int ahb_burst:3;           /* AHB Burst Size DMA Burst Length (encoded) 4 = 1 Word (1x32bits) 5 = 4 Words (4x32bits)else = 8 Words (8x32bits) default; 4 = DMA_BURST_1WORDS; 5 = DMA_BURST_4WORDS; 6 = DMA_BURST_8WORDS */
        unsigned int ahb_data_swap:1;       /* When enabled the data going to AHB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISABLE; 1 = ENABLE */
        unsigned int ahb_bus_width:3;       /* AHB Bus Width 0 = 8 bit Bus (RSVD) 1 = 16 bit Bus (RSVD) 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD)4 = 128 bit Bus (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int intr_enb:1;            /* 0 = send interrupt to COP; 1 = CPU; 0 = COP */
    };

    uint32_t reg32;
} channel_15_ahb_seq_t;

#define CHANNEL_15_APB_PTR_OFFSET 0x11F8
#define CHANNEL_15_APB_PTR_RESET  0x00000000
typedef union channel_15_apb_ptr_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int apb_base:14;           /* APB-DMA Starting address for APB Bus: APB Base address: Upper  16 bits are fixed at 0x7000:XXXX */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} channel_15_apb_ptr_t;

#define CHANNEL_15_APB_SEQ_OFFSET 0x11FC
#define CHANNEL_15_APB_SEQ_RESET  0x00002001
typedef union channel_15_apb_seq_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int apb_addr_wrap:3;       /* APB Address Wrap-around; 0 = NO_WRAP; 1 = WRAP_0N_1WORDS; 2 = WRAP_ON_2WORDS; 3 = WRAP_ON_4WORDS; 4 = WRAP_ON_8WORDS; 5 = WRAP_ON_16WORDS; 6 = WRAP_ON_32WORDS; 7 = WRAP_ON_64WORDS */
        unsigned int undefined_bits_19_26:8;
        unsigned int apb_data_swap:1;       /* When enabled the data going to APB gets swapped as [31:0] --> {[7:0], [15:8], [23:16], [31:24]}; 0 = DISABLE 1 = ENABLE */
        unsigned int apb_bus_width:3;       /* 0 = 8 bit Bus 1 = 16 bit Bus 2 = 32 bit Bus (Def) 3 = 64 bit Bus (RSVD) 4 = 128 bit BUS (RSVD); 0 = BUS_WIDTH_8; 1 = BUS_WIDTH_16; 2 = BUS_WIDTH_32; 3 = BUS_WIDTH_64; 4 = BUS_WIDTH_128 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} channel_15_apb_seq_t;

#endif // TEGRA_APB_DMA_H
