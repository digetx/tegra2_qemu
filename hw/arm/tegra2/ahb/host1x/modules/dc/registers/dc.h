/*
 * ARM NVIDIA Tegra2 emulation.
 *
 * Copyright (c) 2014-2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* Autogenerated from TRM v02p */

#ifndef TEGRA_DC_H
#define TEGRA_DC_H

#include "regs.h"

#define CMD_GENERAL_INCR_SYNCPT_OFFSET 0x0
#define CMD_GENERAL_INCR_SYNCPT_RESET  0x00000000
typedef union cmd_general_incr_syncpt_u {
    struct {
        unsigned int general_indx:8;        /* syncpt index value */
        unsigned int general_cond:8;        /* Condition mapped from raise/wait 0 = IMMEDIATE 1 = OP_DONE 2 = RD_DONE 3 = REG_WR_SAFE 4 = HSPI 5 = FRAME_DONE 6 = VPULSE3 7 = FRAME_START 8 = COND_8 9 = COND_9 10 = COND_10 11 = COND_11 12 = COND_12 13 = COND_13 14 = COND_14 15 = COND_15 */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} cmd_general_incr_syncpt_t;

#define CMD_GENERAL_INCR_SYNCPT_CNTRL_OFFSET 0x1
#define CMD_GENERAL_INCR_SYNCPT_CNTRL_RESET  0x00000000
typedef union cmd_general_incr_syncpt_cntrl_u {
    struct {
        unsigned int general_incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs */
        unsigned int undefined_bits_1_7:7;
        unsigned int general_incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} cmd_general_incr_syncpt_cntrl_t;

#define CMD_GENERAL_INCR_SYNCPT_ERROR_OFFSET 0x2
#define CMD_GENERAL_INCR_SYNCPT_ERROR_RESET  0x00000000
typedef union cmd_general_incr_syncpt_error_u {
    struct {
        unsigned int general_cond_status:32;/* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    uint32_t reg32;
} cmd_general_incr_syncpt_error_t;

#define CMD_WIN_A_INCR_SYNCPT_OFFSET 0x8
#define CMD_WIN_A_INCR_SYNCPT_RESET  0x00000000
typedef union cmd_win_a_incr_syncpt_u {
    struct {
        unsigned int win_a_indx:8;          /* syncpt index value */
        unsigned int win_a_cond:8;          /* Condition mapped from raise/wait 0 = IMMEDIATE 1 = OP_DONE 2 = RD_DONE 3 = REG_WR_SAFE 4 = COND_4 5 = COND_5 6 = COND_6 7 = COND_7 8 = COND_8 9 = COND_9 10 = COND_10 11 = COND_11 12 = COND_12 13 = COND_13 14 = COND_14 15 = COND_15 */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} cmd_win_a_incr_syncpt_t;

#define CMD_WIN_A_INCR_SYNCPT_CNTRL_OFFSET 0x9
#define CMD_WIN_A_INCR_SYNCPT_CNTRL_RESET  0x00000000
typedef union cmd_win_a_incr_syncpt_cntrl_u {
    struct {
        unsigned int win_a_incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs */
        unsigned int undefined_bits_1_7:7;
        unsigned int win_a_incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} cmd_win_a_incr_syncpt_cntrl_t;

#define CMD_WIN_A_INCR_SYNCPT_ERROR_OFFSET 0xA
#define CMD_WIN_A_INCR_SYNCPT_ERROR_RESET  0x00000000
typedef union cmd_win_a_incr_syncpt_error_u {
    struct {
        unsigned int win_a_cond_status:32;  /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    uint32_t reg32;
} cmd_win_a_incr_syncpt_error_t;

#define CMD_WIN_B_INCR_SYNCPT_OFFSET 0x10
#define CMD_WIN_B_INCR_SYNCPT_RESET  0x00000000
typedef union cmd_win_b_incr_syncpt_u {
    struct {
        unsigned int win_b_indx:8;          /* syncpt index value */
        unsigned int win_b_cond:8;          /* Condition mapped from raise/wait 0 = IMMEDIATE 1 = OP_DONE 2 = RD_DONE 3 = REG_WR_SAFE 4 = COND_4 5 = COND_5 6 = COND_6 7 = COND_7 8 = COND_8 9 = COND_9 10 = COND_10 11 = COND_11 12 = COND_12 13 = COND_13 14 = COND_14 15 = COND_15 */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} cmd_win_b_incr_syncpt_t;

#define CMD_WIN_B_INCR_SYNCPT_CNTRL_OFFSET 0x11
#define CMD_WIN_B_INCR_SYNCPT_CNTRL_RESET  0x00000000
typedef union cmd_win_b_incr_syncpt_cntrl_u {
    struct {
        unsigned int win_b_incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs */
        unsigned int undefined_bits_1_7:7;
        unsigned int win_b_incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} cmd_win_b_incr_syncpt_cntrl_t;

#define CMD_WIN_B_INCR_SYNCPT_ERROR_OFFSET 0x12
#define CMD_WIN_B_INCR_SYNCPT_ERROR_RESET  0x00000000
typedef union cmd_win_b_incr_syncpt_error_u {
    struct {
        unsigned int win_b_cond_status:32;  /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    uint32_t reg32;
} cmd_win_b_incr_syncpt_error_t;

#define CMD_WIN_C_INCR_SYNCPT_OFFSET 0x18
#define CMD_WIN_C_INCR_SYNCPT_RESET  0x00000000
typedef union cmd_win_c_incr_syncpt_u {
    struct {
        unsigned int win_c_indx:8;          /* syncpt index value */
        unsigned int win_c_cond:8;          /* Condition mapped from raise/wait 0 = IMMEDIATE 1 = OP_DONE 2 = RD_DONE 3 = REG_WR_SAFE 4 = COND_4 5 = COND_5 6 = COND_6 7 = COND_7 8 = COND_8 9 = COND_9 10 = COND_10 11 = COND_11 12 = COND_12 13 = COND_13 14 = COND_14 15 = COND_15 */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} cmd_win_c_incr_syncpt_t;

#define CMD_WIN_C_INCR_SYNCPT_CNTRL_OFFSET 0x19
#define CMD_WIN_C_INCR_SYNCPT_CNTRL_RESET  0x00000000
typedef union cmd_win_c_incr_syncpt_cntrl_u {
    struct {
        unsigned int win_c_incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs */
        unsigned int undefined_bits_1_7:7;
        unsigned int win_c_incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} cmd_win_c_incr_syncpt_cntrl_t;

#define CMD_WIN_C_INCR_SYNCPT_ERROR_OFFSET 0x1A
#define CMD_WIN_C_INCR_SYNCPT_ERROR_RESET  0x00000000
typedef union cmd_win_c_incr_syncpt_error_u {
    struct {
        unsigned int win_c_cond_status:32;  /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    uint32_t reg32;
} cmd_win_c_incr_syncpt_error_t;

#define CMD_CONT_SYNCPT_VSYNC_OFFSET 0x28
#define CMD_CONT_SYNCPT_VSYNC_RESET  0x00000000
typedef union cmd_cont_syncpt_vsync_u {
    struct {
        unsigned int vsync_indx:8;          /* return INDX (set HOST_CLRD packet TYPE field to SYNCPT) */
        unsigned int vsync_en:1;            /* on host read bus every time VSYNC (V-blank leading edge) happens and VSYNC_EN is set 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} cmd_cont_syncpt_vsync_t;

#define CMD_CTXSW_OFFSET 0x30
#define CMD_CTXSW_RESET  0x0000F800
typedef union cmd_ctxsw_u {
    struct {
        unsigned int curr_class:10;         /* Current working class */
        unsigned int undefined_bit_10:1;
        unsigned int auto_ack:1;            /* Automatically acknowledge any incoming context switch requests 0 = MANUAL 1 = AUTOACK */
        unsigned int curr_channel:4;        /* Current working channel, reset to 'invalid' */
        unsigned int next_class:10;         /* Next requested class */
        unsigned int undefined_bits_26_27:2;
        unsigned int next_channel:4;        /* Next requested channel */
    };

    uint32_t reg32;
} cmd_ctxsw_t;

#define CMD_DISPLAY_COMMAND_OPTION0_OFFSET 0x31
#define CMD_DISPLAY_COMMAND_OPTION0_RESET  0x00000000
typedef union cmd_display_command_option0_u {
    struct {
        unsigned int msf_polarity:1;        /* Main-Display Stop Frame (MSF) Polarity; 0= Active high; 1= Active low */
        unsigned int msf_enable:1;          /* Main-Display Stop Frame (MSF) input This is effective only in Non-Continuous Display mode 0= Disabled 1= Enabled When enabled, MSF signal can be input through LSPI pin. When MSF is enabled a trigger to send a frame in Non-Continuous Display mode will be delayed until MSF is active. 0 = DISABLE 1 = ENABLE */
        unsigned int msf_source:2;          /* Source pin for the MSF input Controls which pin will be used as the source for the trigger input when MSF mode is enabled. Note that although the same pins are available for both MSF and SSF, the order in the enum and hence the values differ between the pins. This is to maintain backwards compatibility with previous chips, which had a fixed mapping. The init value and the first value in the enum reflects this historical mapping. 0= LCD_SPI pin (legacy default) 1= LCD_DC pin 2= LCD_SDI pin 3= RESERVED for future use. 0 = MSF_LSPI 1 = MSF_LDC 2 = MSF_LSDI */
        unsigned int ssf_polarity:1;        /* Sub-Display Stop Frame (SSF) Polarity; 0= Active high; 1= Active low */
        unsigned int ssf_enable:1;          /* Sub-Display Stop Frame (SSF) input This is effective only in Non-Continuous Display mode 0= Disabled 1= Enabled When enabled, SSF signal can be input through LDC pin. When SSF is enabled a trigger to send a frame in Non-Continuous Display mode will be delayed until SSF is active. 0 = DISABLE 1 = ENABLE */
        unsigned int ssf_source:2;          /* Source pin for the SSF input Controls which pin will be used as the source for the trigger input when MSF mode is enabled. Note that although the same pins are available for both MSF and SSF, the order in the enum and hence the values differ between the pins. This is to maintain backwards compatibility with previous chips, which had a fixed mapping. The init value and the first value in the enum reflects this historical mapping. 0= LCD_DC pin (legacy default) 1= LCD_SPI pin 2= LCD_SDI pin 3= RESERVED for future use. 0 = SSF_LDC 1 = SSF_LSPI 2 = SSF_LSDI */
        unsigned int undefined_bits_8_15:8;
        unsigned int window_a_nc_display:1; /* Window A Non-Continuous Display This is effective only in Non-Continuous Display mode when window A buffer switching is not controlled by host. If this bit is enabled, a frame is sent whenever Window A buffer is switched.  0 = DISABLE 1 = ENABLE */
        unsigned int window_b_nc_display:1; /* Window B Non-Continuous Display This is effective only in Non-Continuous Display mode when window B buffer switching is not controlled by host. If this bit is enabled, a frame is sent whenever Window B buffer is switched.  0 = DISABLE 1 = ENABLE */
        unsigned int window_c_nc_display:1; /* Window C Non-Continuous Display This is effective only in Non-Continuous Display mode when window B buffer switching is not controlled by host. If this bit is enabled, a frame is sent whenever Window B buffer is switched; 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_19_31:13;
    };

    uint32_t reg32;
} cmd_display_command_option0_t;

#define CMD_DISPLAY_COMMAND_OFFSET 0x32
#define CMD_DISPLAY_COMMAND_RESET  0x00000000
typedef union cmd_display_command_u {
    struct {
        unsigned int disp_command_raise:1;  /* Display Command Raise. Raise vector will be returned at the end of command completion 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_1_4:4;
        unsigned int display_ctrl_mode:2;   /* Display Controller Mode 0= Stop Display, this can be used to stop sending frame at the next frame boundary. This is automatically generated in Non-Continuous Display after sending one frame. If this is issued when display controller is already stopped then there is no frame sent. Raise vector (if raise is enabled) is also returned immediately. This command can also be used in non-continuous display mode to stop accepting non-host trigger conditions from other clients; 1= Continuous Display, the display controller will continuously send frame. Continuous display mode can be stopped by switching to Non-Continuous Display or by issuing Stop Display.; 2= Non-Continuous Display, the display controller is forced to send one frame of each active display and then wait for the next time this command is issued or for other (non-host) trigger conditions to send frame. The sending of frames may be delayed by MSF or SSF input signals from the display device. If a Stop
Display is issued while in non-continuous display mode then non-host trigger conditions will no longer be accepted until the next time Non-Continuous Display is issued 0 = STOP 1 = C_DISPLAY 2 = NC_DISPLAY */
        unsigned int undefined_bits_7_21:15;
        unsigned int disp_command_raise_vector:5;/* Display Command Raise Vector This raise vector is at the next line or frame boundary, depending on GENERAL_ACT_CNTR_SEL */
        unsigned int disp_command_raise_channel_id:4;/* Display Command Channel ID */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} cmd_display_command_t;

#define CMD_SIGNAL_RAISE_OFFSET 0x33
#define CMD_SIGNAL_RAISE_RESET  0x00000000
typedef union cmd_signal_raise_u {
    struct {
        unsigned int signal_raise_vector:5; /* bit number to raise */
        unsigned int undefined_bits_5_7:3;
        unsigned int signal_raise_select:3; /* which signal to raise on 0= none, no raise sent back 1= Frame End signal 2= V Blank signal 3= V Pulse 3 signal 4= Rising edge of V Blank signal 5= Falling edge of V Blank signal 6= Rising edge of V Pulse 3 signal 7= Falling edge of V Pulse 3 signal 0 = NONE 1 = FRAME_END 2 = VBLANK 3 = VPULSE3 4 = VBLANK_START 5 = VBLANK_END 6 = VPULSE3_START 7 = VPULSE3_END */
        unsigned int undefined_bit_11:1;
        unsigned int signal_raise_type:1;   /* 0= Oneshot, single raise returned 1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE_SELECT=NONE or SIGNAL_RAISE_TYPE=ONESHOT 0 = ONESHOT 1 = CONT */
        unsigned int undefined_bits_13_15:3;
        unsigned int signal_raise_channel_id:4;/* Signal Raise Channel ID */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} cmd_signal_raise_t;

#define CMD_DISPLAY_POWER_CONTROL_OFFSET 0x36
#define CMD_DISPLAY_POWER_CONTROL_RESET  0x00000000
typedef union cmd_display_power_control_u {
    struct {
        unsigned int pw0_enable:1;          /* PW0 signal Enable. This signal controls the display H and V counters. It must be enabled first and disabled last during display power sequencing. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int pw1_enable:1;          /* PW1 signal Enable. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_3:1;
        unsigned int pw2_enable:1;          /* PW2 signal Enable. This signal controls pixel data processing. It should be enabled during V blank time. This signal also controls the time when pin polarity takes effect at the pad. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_5:1;
        unsigned int pw3_enable:1;          /* PW3 signal Enable. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_7:1;
        unsigned int pw4_enable:1;          /* PW4 signal Enable. This signal can be output at the pad for display power sequencing. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_9_15:7;
        unsigned int pm0_enable:1;          /* PM0 signal Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int pm1_enable:1;          /* PM1 signal Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_19_23:5;
        unsigned int spi_enable:1;          /* SPI interface Enable. This enables clock to SPI interface logic for Host SPI, IS SPI, and LCD SPI. 0 = DISABLE 1 = ENABLE */
        unsigned int hspi_enable:1;         /* Host SPI write cycle Enable. SPI_ENABLE must be enabled also for this bit to be effective. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} cmd_display_power_control_t;

#define CMD_INT_STATUS_OFFSET 0x37
#define CMD_INT_STATUS_RESET  0x00000000
typedef union cmd_int_status_u {
    struct {
        unsigned int ctxsw_int:1;           /* Context Switch Interrupt Status (this is cleared on write); 0= interrupt not pending; 1= interrupt pending */
        unsigned int frame_end_int:1;       /* Frame End Interrupt; 0= interrupt not pending; 1= interrupt pending */
        unsigned int v_blank_int:1;         /* Vertical Blank Interrupt; 0= interrupt not pending; 1= interrupt pending */
        unsigned int h_blank_int:1;         /* Horizontal Blank Interrupt; 0= interrupt not pending; 1= interrupt pending */
        unsigned int v_pulse3_int:1;        /* Vertical Pulse 3 Interrupt; 0= interrupt not pending; 1= interrupt pending */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int:1;        /* SPI Busy Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_a_uf_int:1;        /* Window A Underflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_b_uf_int:1;        /* Window B Underflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_c_uf_int:1;        /* Window C Underflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int epp_of_int:1;          /* Display2epp Overflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int msf_int:1;             /* Main-Display Stop Frame Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int ssf_int:1;             /* Sub-Display Stop Frame Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_a_of_int:1;        /* Window A Overflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_b_of_int:1;        /* Window B Overflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int win_c_of_int:1;        /* Window C Overflow Interrupt Status; 0= interrupt not pending; 1= interrupt pending */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int:1;          /* GPIO 0 Interrupt Status, connected to LCD_PWR0; 0= interrupt not pending; 1= interrupt pending */
        unsigned int gpio_1_int:1;          /* GPIO 1 Interrupt Status, connected to LCD_PWR1; 0= interrupt not pending; 1= interrupt pending */
        unsigned int gpio_2_int:1;          /* GPIO 2 Interrupt Status, connected to LCD_PWR2; 0= interrupt not pending; 1= interrupt pending */
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} cmd_int_status_t;

#define CMD_INT_MASK_OFFSET 0x38
#define CMD_INT_MASK_RESET  0x00000000
typedef union cmd_int_mask_u {
    struct {
        unsigned int ctxsw_int_mask:1;      /* Context Switch Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int frame_end_int_mask:1;  /* Frame End Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int v_blank_int_mask:1;    /* Vertical Blank Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int h_blank_int_mask:1;    /* Horizontal Blank Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int v_pulse3_int_mask:1;   /* Vertical Pulse 3 Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int_mask:1;   /* SPI Busy Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_a_uf_int_mask:1;   /* Window A Underflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_b_uf_int_mask:1;   /* Window B Underflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_c_uf_int_mask:1;   /* Window C Underflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bit_11:1;
        unsigned int msf_int_mask:1;        /* Main-Display Stop Frame Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ssf_int_mask:1;        /* Sub-Display Stop Frame Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_a_of_int_mask:1;   /* Window A Overflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_b_of_int_mask:1;   /* Window B Overflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int win_c_of_int_mask:1;   /* Window C Overflow Interrupt Mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int_mask:1;     /* GPIO 0 Interrupt Mask, connected to LCD_PWR0 0= interrupt masked 1= interrupt not masked 0 = MASKED 1 = NOTMASKED */
        unsigned int gpio_1_int_mask:1;     /* GPIO 1 Interrupt Mask, connected to LCD_PWR1  0 = MASKED 1 = NOTMASKED */
        unsigned int gpio_2_int_mask:1;     /* GPIO 2 Interrupt Mask, connected to LCD_PWR2  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} cmd_int_mask_t;

#define CMD_INT_ENABLE_OFFSET 0x39
#define CMD_INT_ENABLE_RESET  0x00000001
typedef union cmd_int_enable_u {
    struct {
        unsigned int ctxsw_int_enable:1;    /* Context Switch Interrupt Enable 0= interrupt disabled 1= interrupt enabled 0 = DISABLE 1 = ENABLE */
        unsigned int frame_end_int_enable:1;/* Frame End Interrupt Enable 0= interrupt masked 1= interrupt not masked 0 = DISABLE 1 = ENABLE */
        unsigned int v_blank_int_enable:1;  /* Vertical Blank Interrupt Enable 0= interrupt masked 1= interrupt not masked 0 = DISABLE 1 = ENABLE */
        unsigned int h_blank_int_enable:1;  /* Horizontal Blank Interrupt Enable 0= interrupt masked 1= interrupt not masked 0 = DISABLE 1 = ENABLE */
        unsigned int v_pulse3_int_enable:1; /* Vertical Pulse 3 Interrupt Enable 0= interrupt masked 1= interrupt not masked 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int_enable:1; /* SPI Busy Interrupt Enable; 0 = DISABLE 1 = ENABLE */
        unsigned int win_a_uf_int_enable:1; /* Window A Underflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int win_b_uf_int_enable:1; /* Window B Underflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int win_c_uf_int_enable:1; /* Window C Underflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_11:1;
        unsigned int msf_int_enable:1;      /* Main-Display Stop Frame Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int ssf_int_enable:1;      /* Sub-Display Stop Frame Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int win_a_of_int_enable:1; /* Window A Overflow Interrupt Enable; 0 = DISABLE 1 = ENABLE */
        unsigned int win_b_of_int_enable:1; /* Window B Overflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int win_c_of_int_enable:1; /* Window C Overflow Interrupt Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int_enable:1;   /* Display GPIO_0 Interrupt Enable, connected to LCD_PWR0; 0 = DISABLE 1 = ENABLE */
        unsigned int gpio_1_int_enable:1;   /* Display GPIO_1 Interrupt Enable, connected to LCD_PWR1  0 = DISABLE 1 = ENABLE */
        unsigned int gpio_2_int_enable:1;   /* Display GPIO_2 Interrupt Enable, connected to LCD_PWR2  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} cmd_int_enable_t;

#define CMD_INT_TYPE_OFFSET 0x3A
#define CMD_INT_TYPE_RESET  0x00000000
typedef union cmd_int_type_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int frame_end_int_type:1;  /* Frame End Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int v_blank_int_type:1;    /* Vertical Blank Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int h_blank_int_type:1;    /* Horizontal Blank Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int v_pulse3_int_type:1;   /* Vertical Pulse 3 Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int_type:1;   /* SPI Busy Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_a_uf_int_type:1;   /* Window A Underflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_b_uf_int_type:1;   /* Window B Underflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_c_uf_int_type:1;   /* Window C Underflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int undefined_bit_11:1;
        unsigned int msf_int_type:1;        /* Main-Display Stop Frame Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int ssf_int_type:1;        /* Sub-Display Stop Frame Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_a_of_int_type:1;   /* Window A Overflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_b_of_int_type:1;   /* Window B Overflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int win_c_of_int_type:1;   /* Window C Overflow Interrupt Type  0 = EDGE 1 = LEVEL */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int_type:1;     /* Display GPIO_0 Interrupt Type, connected to LCD_PWR0  0 = EDGE 1 = LEVEL */
        unsigned int gpio_1_int_type:1;     /* Display GPIO_1 Interrupt Type, connected to LCD_PWR1  0 = EDGE 1 = LEVEL */
        unsigned int gpio_2_int_type:1;     /* Display GPIO_2 Interrupt Type, connected to LCD_PWR2  0 = EDGE 1 = LEVEL */
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} cmd_int_type_t;

#define CMD_INT_POLARITY_OFFSET 0x3B
#define CMD_INT_POLARITY_RESET  0x00000000
typedef union cmd_int_polarity_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int frame_end_int_polarity:1;/* Frame End. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int v_blank_int_polarity:1;/* V Blank. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int h_blank_int_polarity:1;/* H Blank. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int v_pulse3_int_polarity:1;/* V Pulse 3. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int undefined_bits_5_6:2;
        unsigned int spi_busy_int_polarity:1;/* SPI Busy. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_a_uf_int_polarity:1;/* Window A Underflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_b_uf_int_polarity:1;/* Window B Underflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_c_uf_int_polarity:1;/* Window C Underflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int undefined_bit_11:1;
        unsigned int msf_int_polarity:1;    /* Main-Display Stop Frame. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int ssf_int_polarity:1;    /* Sub-Display Stop Frame. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_a_of_int_polarity:1;/* Window A Overflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_b_of_int_polarity:1;/* Window B Overflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int win_c_of_int_polarity:1;/* Window C Overflow. Interrupt Polarity 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int undefined_bit_17:1;
        unsigned int gpio_0_int_polarity:1; /* Display GPIO_0 Interrupt. Interrupt Polarity, connected to LCD_PWR0 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int gpio_1_int_polarity:1; /* Display GPIO_1 Interrupt. Interrupt Polarity, connected to LCD_PWR1 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int gpio_2_int_polarity:1; /* Display GPIO_2 Interrupt. Interrupt Polarity, connected to LCD_PWR2 0= falling edge or low level interrupt 1= rising edge or high level interrupt 0 = LOW 1 = HIGH */
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} cmd_int_polarity_t;

#define CMD_SIGNAL_RAISE1_OFFSET 0x3C
#define CMD_SIGNAL_RAISE1_RESET  0x00000000
typedef union cmd_signal_raise1_u {
    struct {
        unsigned int signal_raise1_vector:5;/* bit number to raise */
        unsigned int undefined_bits_5_7:3;
        unsigned int signal_raise1_select:3;/* which signal to raise on 0= none, no raise sent back 1= Frame End signal 2= V Blank signal 3= V Pulse 3 signal 4= Rising edge of V Blank signal 5= Falling edge of V Blank signal 6= Rising edge of V Pulse 3 signal 7= Falling edge of V Pulse 3 signal 0 = NONE 1 = FRAME_END 2 = VBLANK 3 = VPULSE3 4 = VBLANK_START 5 = VBLANK_END 6 = VPULSE3_START 7 = VPULSE3_END */
        unsigned int undefined_bit_11:1;
        unsigned int signal_raise1_type:1;  /* 0= Oneshot, single raise returned 1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE1_SELECT=NONE or SIGNAL_RAISE1_TYPE=ONESHOT 0 = ONESHOT 1 = CONT */
        unsigned int undefined_bits_13_15:3;
        unsigned int signal_raise1_channel_id:4;/* Signal Raise Channel ID */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} cmd_signal_raise1_t;

#define CMD_SIGNAL_RAISE2_OFFSET 0x3D
#define CMD_SIGNAL_RAISE2_RESET  0x00000000
typedef union cmd_signal_raise2_u {
    struct {
        unsigned int signal_raise2_vector:5;/* bit number to raise */
        unsigned int undefined_bits_5_7:3;
        unsigned int signal_raise2_select:3;/* which signal to raise on 0= none, no raise sent back 1= Frame End signal 2= V Blank signal 3= V Pulse 3 signal 4= Rising edge of V Blank signal 5= Falling edge of V Blank signal 6= Rising edge of V Pulse 3 signal 7= Falling edge of V Pulse 3 signal 0 = NONE 1 = FRAME_END 2 = VBLANK 3 = VPULSE3 4 = VBLANK_START 5 = VBLANK_END 6 = VPULSE3_START 7 = VPULSE3_END */
        unsigned int undefined_bit_11:1;
        unsigned int signal_raise2_type:1;  /* 0= Oneshot, single raise returned 1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE2_SELECT=NONE or SIGNAL_RAISE2_TYPE=ONESHOT 0 = ONESHOT 1 = CONT */
        unsigned int undefined_bits_13_15:3;
        unsigned int signal_raise2_channel_id:4;/* Signal Raise Channel ID */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} cmd_signal_raise2_t;

#define CMD_SIGNAL_RAISE3_OFFSET 0x3E
#define CMD_SIGNAL_RAISE3_RESET  0x00000000
typedef union cmd_signal_raise3_u {
    struct {
        unsigned int signal_raise3_vector:5;/* bit number to raise */
        unsigned int undefined_bits_5_7:3;
        unsigned int signal_raise3_select:3;/* which signal to raise on 0= none, no raise sent back 1= Frame End signal 2= V Blank signal 3= V Pulse 3 signal 4= Rising edge of V Blank signal 5= Falling edge of V Blank signal 6= Rising edge of V Pulse 3 signal 7= Falling edge of V Pulse 3 signal 0 = NONE 1 = FRAME_END 2 = VBLANK 3 = VPULSE3 4 = VBLANK_START 5 = VBLANK_END 6 = VPULSE3_START 7 = VPULSE3_END */
        unsigned int undefined_bit_11:1;
        unsigned int signal_raise3_type:1;  /* 0= Oneshot, single raise returned 1= Continuous, raise is returned persistently whenever raise event is true until this register is reprogrammed such that SIGNAL_RAISE3_SELECT=NONE or SIGNAL_RAISE3_TYPE=ONESHOT 0 = ONESHOT 1 = CONT */
        unsigned int undefined_bits_13_15:3;
        unsigned int signal_raise3_channel_id:4;/* Signal Raise Channel ID */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} cmd_signal_raise3_t;

#define CMD_STATE_ACCESS_OFFSET 0x40
#define CMD_STATE_ACCESS_RESET  0x00000000
typedef union cmd_state_access_u {
    struct {
        unsigned int read_mux:1;            /* Read access control 0= read assembly state 1= read active state Arm state register read is not controlled by this mux, but by reading the registers with "_NS" suffix 0 = ASSEMBLY 1 = ACTIVE */
        unsigned int undefined_bit_1:1;
        unsigned int write_mux:1;           /* Write access control 0= write assembly state 1= write active state When set to ACTIVE, register writes also propagate to assembly set for double buffered registers, to both assembly and arm set for triple buffered registers. 0 = ASSEMBLY 1 = ACTIVE */
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} cmd_state_access_t;

#define CMD_STATE_CONTROL_OFFSET 0x41
#define CMD_STATE_CONTROL_RESET  0x00000000
typedef union cmd_state_control_u {
    struct {
        unsigned int general_act_req:1;     /* Non-window-specific 0= no req pending/req completed 1= activation requested/pending 0 = DISABLE 1 = ENABLE */
        unsigned int win_a_act_req:1;       /* Window A activation request 0= no req pending/req completed 1= activation requested/pending 0 = DISABLE 1 = ENABLE */
        unsigned int win_b_act_req:1;       /* Window B activation request 0= no req pending/req completed 1= activation requested/pending 0 = DISABLE 1 = ENABLE */
        unsigned int win_c_act_req:1;       /* Window C activation request 0= no req pending/req completed 1= activation requested/pending 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_4_7:4;
        unsigned int general_update:1;      /* Trigger for arming state (from assembly to armed state) for a subset of the triple buffered registers. This register is also known as "Update Register"  0 = DISABLE 1 = ENABLE */
        unsigned int win_a_update:1;        /* Trigger for arming state (from assembly to armed state) for the win A subset of the triple buffered registers. This register is also known as "Update Register"  0 = DISABLE 1 = ENABLE */
        unsigned int win_b_update:1;        /* Trigger for arming state (from assembly to armed state) for the win B subset of the triple buffered registers. This register is also known as "Update Register"  0 = DISABLE 1 = ENABLE */
        unsigned int win_c_update:1;        /* Trigger for arming state (from assembly to armed state) for the win C subset of the triple buffered registers. This register is also known as "Update Register"  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_12_23:12;
        unsigned int nc_host_trig_enable:1; /* Host trigger enable. Effective only in Non-continuous mode. The exception is that when TVO is enabled, this trigger is ignored so as not to corrupt TV output. Note that when this field is enabled, GENERAL_ACT_REQ must be enabled at the same time. 0= disable: no frame is triggered  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_25_31:7;
    };

    uint32_t reg32;
} cmd_state_control_t;

#define CMD_DISPLAY_WINDOW_HEADER_OFFSET 0x42
#define CMD_DISPLAY_WINDOW_HEADER_RESET  0x00000000
typedef union cmd_display_window_header_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int window_a_select:1;     /* Window A Select 0= disable window A programming 1= enable window A programming 0 = DISABLE 1 = ENABLE */
        unsigned int window_b_select:1;     /* Window B Select 0= disable window B programming 1= enable window B programming 0 = DISABLE 1 = ENABLE */
        unsigned int window_c_select:1;     /* Window C Select 0= disable window C programming 1= enable window C programming 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_7_31:25;
    };

    uint32_t reg32;
} cmd_display_window_header_t;

#define CMD_REG_ACT_CONTROL_OFFSET 0x43
#define CMD_REG_ACT_CONTROL_RESET  0x00000000
typedef union cmd_reg_act_control_u {
    struct {
        unsigned int general_act_cntr_sel:1;/* Select which counter to use for general activation  0 = VCOUNTER 1 = HCOUNTER */
        unsigned int undefined_bit_1:1;
        unsigned int win_a_act_cntr_sel:1;  /* Select which counter to use for window A activation  0 = VCOUNTER 1 = HCOUNTER */
        unsigned int undefined_bit_3:1;
        unsigned int win_b_act_cntr_sel:1;  /* Select which counter to use for window B activation  0 = VCOUNTER 1 = HCOUNTER */
        unsigned int undefined_bit_5:1;
        unsigned int win_c_act_cntr_sel:1;  /* Select which counter to use for window C activation  0 = VCOUNTER 1 = HCOUNTER */
        unsigned int undefined_bits_7_31:25;
    };

    uint32_t reg32;
} cmd_reg_act_control_t;

#define COM_CRC_CONTROL_OFFSET 0x300
#define COM_CRC_CONTROL_RESET  0x00000000
typedef union com_crc_control_u {
    struct {
        unsigned int crc_enable:1;          /* CRC Enable  0 = DISABLE 1 = ENABLE */
        unsigned int crc_wait:1;            /* CRC Wait 0= 1 Vsync 1= 2 Vsync */
        unsigned int crc_input_data:1;      /* CRC input data 0= Full frame (RGB data and control) 1= Active display (Only RGB data)  0 = FULL_FRAME 1 = ACTIVE_DATA */
        unsigned int crc_always:1;          /* CRC always: calculate CRC for every following frames Must use with CRC_INPUT_DATA = ACTIVE_DATA if enabled, CRC_WAIT field is ignored.  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} com_crc_control_t;

#define COM_CRC_CHECKSUM_OFFSET 0x301
#define COM_CRC_CHECKSUM_RESET  0x00000000
typedef union com_crc_checksum_u {
    struct {
        unsigned int crc_checksum:32;       /* CRC Checksum */
    };

    uint32_t reg32;
} com_crc_checksum_t;

#define COM_PIN_OUTPUT_ENABLE0_OFFSET 0x302
#define COM_PIN_OUTPUT_ENABLE0_RESET  0x00000000
typedef union com_pin_output_enable0_u {
    struct {
        unsigned int ld0_output_enable:1;   /* LD0 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_1:1;
        unsigned int ld1_output_enable:1;   /* LD1 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_3:1;
        unsigned int ld2_output_enable:1;   /* LD2 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_5:1;
        unsigned int ld3_output_enable:1;   /* LD3 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_7:1;
        unsigned int ld4_output_enable:1;   /* LD4 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_9:1;
        unsigned int ld5_output_enable:1;   /* LD5 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_11:1;
        unsigned int ld6_output_enable:1;   /* LD6 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_13:1;
        unsigned int ld7_output_enable:1;   /* LD7 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_15:1;
        unsigned int ld8_output_enable:1;   /* LD8 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_17:1;
        unsigned int ld9_output_enable:1;   /* LD9 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_19:1;
        unsigned int ld10_output_enable:1;  /* LD10 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_21:1;
        unsigned int ld11_output_enable:1;  /* LD11 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_23:1;
        unsigned int ld12_output_enable:1;  /* LD12 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_25:1;
        unsigned int ld13_output_enable:1;  /* LD13 pin output enable; 0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_27:1;
        unsigned int ld14_output_enable:1;  /* LD14 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_29:1;
        unsigned int ld15_output_enable:1;  /* LD15 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_output_enable0_t;

#define COM_PIN_OUTPUT_ENABLE1_OFFSET 0x303
#define COM_PIN_OUTPUT_ENABLE1_RESET  0x00000000
typedef union com_pin_output_enable1_u {
    struct {
        unsigned int ld16_output_enable:1;  /* LD16 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_1:1;
        unsigned int ld17_output_enable:1;  /* LD17 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_3_15:13;
        unsigned int lpw0_output_enable:1;  /* LCD_PWR0 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_17:1;
        unsigned int lpw1_output_enable:1;  /* LCD_PWR1 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_19:1;
        unsigned int lpw2_output_enable:1;  /* LCD_PWR2 pin output enable; 0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_21_23:3;
        unsigned int lsc0_output_enable:1;  /* LCD_PCLK pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_25:1;
        unsigned int lsc1_output_enable:1;  /* LCD_WR_N pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_27:1;
        unsigned int lvs_output_enable:1;   /* LVS pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_29:1;
        unsigned int lhs_output_enable:1;   /* LCD_HSYNC pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_output_enable1_t;

#define COM_PIN_OUTPUT_ENABLE2_OFFSET 0x304
#define COM_PIN_OUTPUT_ENABLE2_RESET  0x00510104
typedef union com_pin_output_enable2_u {
    struct {
        unsigned int lhp0_output_enable:1;  /* LCD_D21 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_1:1;
        unsigned int lhp1_output_enable:1;  /* LCD_D18 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_3:1;
        unsigned int lhp2_output_enable:1;  /* LCD_D19 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_5_7:3;
        unsigned int lvp0_output_enable:1;  /* LCD_DC1 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_9:1;
        unsigned int lvp1_output_enable:1;  /* LCD_D20 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_11_15:5;
        unsigned int lm0_output_enable:1;   /* LCD_CS1_N pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_17:1;
        unsigned int lm1_output_enable:1;   /* LCD_M1 pin output enable  0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bit_19:1;
        unsigned int ldi_output_enable:1;   /* LCD_D22 pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_21:1;
        unsigned int lpp_output_enable:1;   /* LCD_D23 pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bits_23_31:9;
    };

    uint32_t reg32;
} com_pin_output_enable2_t;

#define COM_PIN_OUTPUT_ENABLE3_OFFSET 0x305
#define COM_PIN_OUTPUT_ENABLE3_RESET  0x00000555
typedef union com_pin_output_enable3_u {
    struct {
        unsigned int lsck_output_enable:1;  /* LSCK pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_1:1;
        unsigned int lsda_output_enable:1;  /* LSDA pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_3:1;
        unsigned int lcsn_output_enable:1;  /* LCSN pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_5:1;
        unsigned int ldc_output_enable:1;   /* LDC pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_7:1;
        unsigned int lspi_output_enable:1;  /* LSPI pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bit_9:1;
        unsigned int lsdi_output_enable:1;  /* LSDI pin output enable  0 = ENABLE 1 = DISABLE (default after reset) */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} com_pin_output_enable3_t;

#define COM_PIN_OUTPUT_POLARITY0_OFFSET 0x306
#define COM_PIN_OUTPUT_POLARITY0_RESET  0x00000000
typedef union com_pin_output_polarity0_u {
    struct {
        unsigned int ld0_output_polarity:1; /* LD0 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_1:1;
        unsigned int ld1_output_polarity:1; /* LD1 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_3:1;
        unsigned int ld2_output_polarity:1; /* LD2 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int ld3_output_polarity:1; /* LD3 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_7:1;
        unsigned int ld4_output_polarity:1; /* LD4 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_9:1;
        unsigned int ld5_output_polarity:1; /* LD5 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_11:1;
        unsigned int ld6_output_polarity:1; /* LD6 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_13:1;
        unsigned int ld7_output_polarity:1; /* LD7 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_15:1;
        unsigned int ld8_output_polarity:1; /* LD8 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_17:1;
        unsigned int ld9_output_polarity:1; /* LD9 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_19:1;
        unsigned int ld10_output_polarity:1;/* LD10 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_21:1;
        unsigned int ld11_output_polarity:1;/* LD11 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_23:1;
        unsigned int ld12_output_polarity:1;/* LD12 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_25:1;
        unsigned int ld13_output_polarity:1;/* LD13 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_27:1;
        unsigned int ld14_output_polarity:1;/* LD14 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_29:1;
        unsigned int ld15_output_polarity:1;/* LD15 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_output_polarity0_t;

#define COM_PIN_OUTPUT_POLARITY1_OFFSET 0x307
#define COM_PIN_OUTPUT_POLARITY1_RESET  0x00000000
typedef union com_pin_output_polarity1_u {
    struct {
        unsigned int ld16_output_polarity:1;/* LD16 pin output polarity; 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_1:1;
        unsigned int ld17_output_polarity:1;/* LD17 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_3_15:13;
        unsigned int lpw0_output_polarity:1;/* LCD_PWR0 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_17:1;
        unsigned int lpw1_output_polarity:1;/* LCD_PWR1 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_19:1;
        unsigned int lpw2_output_polarity:1;/* LCD_PWR2 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_21_23:3;
        unsigned int lsc0_output_polarity:1;/* LCD_PCLK pin output polarity. When used as PCLK (pixel clock), HIGH means that rising edge coincides with data transition, and LOW means that falling edge coincides with data transition. 0= active high 1= active low  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_25:1;
        unsigned int lsc1_output_polarity:1;/* LCD_WR_N pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_27:1;
        unsigned int lvs_output_polarity:1; /* LVS pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_29:1;
        unsigned int lhs_output_polarity:1; /* LCD_HSYNC pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_output_polarity1_t;

#define COM_PIN_OUTPUT_POLARITY2_OFFSET 0x308
#define COM_PIN_OUTPUT_POLARITY2_RESET  0x00000000
typedef union com_pin_output_polarity2_u {
    struct {
        unsigned int lhp0_output_polarity:1;/* LCD_D21 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_1:1;
        unsigned int lhp1_output_polarity:1;/* LCD_D18 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_3:1;
        unsigned int lhp2_output_polarity:1;/* LCD_D19 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_5_7:3;
        unsigned int lvp0_output_polarity:1;/* LCD_DC1 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_9:1;
        unsigned int lvp1_output_polarity:1;/* LCD_D20 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_11_15:5;
        unsigned int lm0_output_polarity:1; /* LCD_CS1_N pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_17:1;
        unsigned int lm1_output_polarity:1; /* LCD_M1 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_19:1;
        unsigned int ldi_output_polarity:1; /* LCD_D22 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_21:1;
        unsigned int lpp_output_polarity:1; /* LCD_D23 pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_23_31:9;
    };

    uint32_t reg32;
} com_pin_output_polarity2_t;

#define COM_PIN_OUTPUT_POLARITY3_OFFSET 0x309
#define COM_PIN_OUTPUT_POLARITY3_RESET  0x00000000
typedef union com_pin_output_polarity3_u {
    struct {
        unsigned int lsck_output_polarity:1;/* LSCK pin output polarity; 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_1:1;
        unsigned int lsda_output_polarity:1;/* LSDA pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_3:1;
        unsigned int lcsn_output_polarity:1;/* LCSN pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int ldc_output_polarity:1; /* LDC pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_7:1;
        unsigned int lspi_output_polarity:1;/* LSPI pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_9:1;
        unsigned int lsdi_output_polarity:1;/* LSDI pin output polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} com_pin_output_polarity3_t;

#define COM_PIN_OUTPUT_DATA0_OFFSET 0x30A
#define COM_PIN_OUTPUT_DATA0_RESET  0x00000000
typedef union com_pin_output_data0_u {
    struct {
        unsigned int ld0_output_data:1;     /* LD0 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld0_output_data_mask:1;/* LD0 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld1_output_data:1;     /* LD1 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld1_output_data_mask:1;/* LD1 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld2_output_data:1;     /* LD2 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld2_output_data_mask:1;/* LD2 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld3_output_data:1;     /* LD3 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld3_output_data_mask:1;/* LD3 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld4_output_data:1;     /* LD4 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld4_output_data_mask:1;/* LD4 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld5_output_data:1;     /* LD5 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld5_output_data_mask:1;/* LD5 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld6_output_data:1;     /* LD6 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld6_output_data_mask:1;/* LD6 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld7_output_data:1;     /* LD7 pin output data; 0 = LOW 1 = HIGH */
        unsigned int ld7_output_data_mask:1;/* LD7 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld8_output_data:1;     /* LD8 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld8_output_data_mask:1;/* LD8 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld9_output_data:1;     /* LD9 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld9_output_data_mask:1;/* LD9 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld10_output_data:1;    /* LD10 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld10_output_data_mask:1;/* LD10 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld11_output_data:1;    /* LD11 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld11_output_data_mask:1;/* LD11 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld12_output_data:1;    /* LD12 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld12_output_data_mask:1;/* LD12 pin output data  0 = MASKED 1 = NOTMASKED */
        unsigned int ld13_output_data:1;    /* LD13 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld13_output_data_mask:1;/* LD13 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld14_output_data:1;    /* LD14 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld14_output_data_mask:1;/* LD14 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld15_output_data:1;    /* LD15 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld15_output_data_mask:1;/* LD15 pin output data mask  0 = MASKED 1 = NOTMASKED */
    };

    uint32_t reg32;
} com_pin_output_data0_t;

#define COM_PIN_OUTPUT_DATA1_OFFSET 0x30B
#define COM_PIN_OUTPUT_DATA1_RESET  0x00000000
typedef union com_pin_output_data1_u {
    struct {
        unsigned int ld16_output_data:1;    /* LD16 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld16_output_data_mask:1;/* LD16 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ld17_output_data:1;    /* LD17 pin output data  0 = LOW 1 = HIGH */
        unsigned int ld17_output_data_mask:1;/* LD17 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_4_15:12;
        unsigned int lpw0_output_data:1;    /* LCD_PWR0 pin output data  0 = LOW 1 = HIGH */
        unsigned int lpw0_output_data_mask:1;/* LCD_PWR0 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lpw1_output_data:1;    /* LCD_PWR1 pin output data  0 = LOW 1 = HIGH */
        unsigned int lpw1_output_data_mask:1;/* LCD_PWR1 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lpw2_output_data:1;    /* LCD_PWR2 pin output data  0 = LOW 1 = HIGH */
        unsigned int lpw2_output_data_mask:1;/* LCD_PWR2 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_22_23:2;
        unsigned int lsc0_output_data:1;    /* LCD_PCLK pin output data  0 = LOW 1 = HIGH */
        unsigned int lsc0_output_data_mask:1;/* LCD_PCLK pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lsc1_output_data:1;    /* LCD_WR_N pin output data  0 = LOW 1 = HIGH */
        unsigned int lsc1_output_data_mask:1;/* LCD_WR_N pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lvs_output_data:1;     /* LVS pin output data  0 = LOW 1 = HIGH */
        unsigned int lvs_output_data_mask:1;/* LVS pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lhs_output_data:1;     /* LCD_HSYNC pin output data  0 = LOW 1 = HIGH */
        unsigned int lhs_output_data_mask:1;/* LCD_HSYNC pin output data mask  0 = MASKED 1 = NOTMASKED */
    };

    uint32_t reg32;
} com_pin_output_data1_t;

#define COM_PIN_OUTPUT_DATA2_OFFSET 0x30C
#define COM_PIN_OUTPUT_DATA2_RESET  0x00000000
typedef union com_pin_output_data2_u {
    struct {
        unsigned int lhp0_output_data:1;    /* LCD_D21 pin output data  0 = LOW 1 = HIGH */
        unsigned int lhp0_output_data_mask:1;/* LCD_D21 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lhp1_output_data:1;    /* LCD_D18 pin output data  0 = LOW 1 = HIGH */
        unsigned int lhp1_output_data_mask:1;/* LCD_D18 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lhp2_output_data:1;    /* LCD_D19 pin output data  0 = LOW 1 = HIGH */
        unsigned int lhp2_output_data_mask:1;/* LCD_D19 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_6_7:2;
        unsigned int lvp0_output_data:1;    /* LCD_DC1 pin output data  0 = LOW 1 = HIGH */
        unsigned int lvp0_output_data_mask:1;/* LCD_DC1 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lvp1_output_data:1;    /* LCD_D20 pin output data  0 = LOW 1 = HIGH */
        unsigned int lvp1_output_data_mask:1;/* LCD_D20 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_12_15:4;
        unsigned int lm0_output_data:1;     /* LCD_CS1_N pin output data  0 = LOW 1 = HIGH */
        unsigned int lm0_output_data_mask:1;/* LCD_CS1_N pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lm1_output_data:1;     /* LCD_M1 pin output data  0 = LOW 1 = HIGH */
        unsigned int lm1_output_data_mask:1;/* LCD_M1 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ldi_output_data:1;     /* LCD_D22 pin output data  0 = LOW 1 = HIGH */
        unsigned int ldi_output_data_mask:1;/* LCD_D22 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lpp_output_data:1;     /* LCD_D23 pin output data  0 = LOW 1 = HIGH */
        unsigned int lpp_output_data_mask:1;/* LCD_D23 pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} com_pin_output_data2_t;

#define COM_PIN_OUTPUT_DATA3_OFFSET 0x30D
#define COM_PIN_OUTPUT_DATA3_RESET  0x00000000
typedef union com_pin_output_data3_u {
    struct {
        unsigned int lsck_output_data:1;    /* LSCK pin output data  0 = LOW 1 = HIGH */
        unsigned int lsck_output_data_mask:1;/* LSCK pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lsda_output_data:1;    /* LSDA pin output data  0 = LOW 1 = HIGH */
        unsigned int lsda_output_data_mask:1;/* LSDA pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lcsn_output_data:1;    /* LCSN pin output data  0 = LOW 1 = HIGH */
        unsigned int lcsn_output_data_mask:1;/* LCSN pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int ldc_output_data:1;     /* LDC pin output data  0 = LOW 1 = HIGH */
        unsigned int ldc_output_data_mask:1;/* LDC pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lspi_output_data:1;    /* LSPI pin output data  0 = LOW 1 = HIGH */
        unsigned int lspi_output_data_mask:1;/* LSPI pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int lsdi_output_data:1;    /* LSDI pin output data  0 = LOW 1 = HIGH */
        unsigned int lsdi_output_data_mask:1;/* LSDI pin output data mask  0 = MASKED 1 = NOTMASKED */
        unsigned int undefined_bits_12_31:20;
    };

    uint32_t reg32;
} com_pin_output_data3_t;

#define COM_PIN_INPUT_ENABLE0_OFFSET 0x30E
#define COM_PIN_INPUT_ENABLE0_RESET  0x00000000
typedef union com_pin_input_enable0_u {
    struct {
        unsigned int ld0_input_enable:1;    /* LD0 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int ld1_input_enable:1;    /* LD1 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_3:1;
        unsigned int ld2_input_enable:1;    /* LD2 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_5:1;
        unsigned int ld3_input_enable:1;    /* LD3 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_7:1;
        unsigned int ld4_input_enable:1;    /* LD4 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_9:1;
        unsigned int ld5_input_enable:1;    /* LD5 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_11:1;
        unsigned int ld6_input_enable:1;    /* LD6 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_13:1;
        unsigned int ld7_input_enable:1;    /* LD7 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_15:1;
        unsigned int ld8_input_enable:1;    /* LD8 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int ld9_input_enable:1;    /* LD9 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_19:1;
        unsigned int ld10_input_enable:1;   /* LD10 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_21:1;
        unsigned int ld11_input_enable:1;   /* LD11 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_23:1;
        unsigned int ld12_input_enable:1;   /* LD12 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_25:1;
        unsigned int ld13_input_enable:1;   /* LD13 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_27:1;
        unsigned int ld14_input_enable:1;   /* LD14 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_29:1;
        unsigned int ld15_input_enable:1;   /* LD15 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_input_enable0_t;

#define COM_PIN_INPUT_ENABLE1_OFFSET 0x30F
#define COM_PIN_INPUT_ENABLE1_RESET  0x00000000
typedef union com_pin_input_enable1_u {
    struct {
        unsigned int ld16_input_enable:1;   /* LD16 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int ld17_input_enable:1;   /* LD17 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_3_15:13;
        unsigned int lpw0_input_enable:1;   /* LCD_PWR0 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int lpw1_input_enable:1;   /* LCD_PWR1 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_19:1;
        unsigned int lpw2_input_enable:1;   /* LCD_PWR2 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_21_23:3;
        unsigned int lsc0_input_enable:1;   /* LCD_PCLK pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_25:1;
        unsigned int lsc1_input_enable:1;   /* LCD_WR_N pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_27:1;
        unsigned int lvs_input_enable:1;    /* LCD_VSYNC pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_29:1;
        unsigned int lhs_input_enable:1;    /* LCD_HSYNC pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_input_enable1_t;

#define COM_PIN_INPUT_ENABLE2_OFFSET 0x310
#define COM_PIN_INPUT_ENABLE2_RESET  0x00000000
typedef union com_pin_input_enable2_u {
    struct {
        unsigned int lhp0_input_enable:1;   /* LCD_D21 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int lhp1_input_enable:1;   /* LCD_D18 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_3:1;
        unsigned int lhp2_input_enable:1;   /* LCD_D19 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_5_7:3;
        unsigned int lvp0_input_enable:1;   /* LCD_DC1 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_9:1;
        unsigned int lvp1_input_enable:1;   /* LCD_D20 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_11_15:5;
        unsigned int lm0_input_enable:1;    /* LCD_CS1_N pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int lm1_input_enable:1;    /* LCD_M1 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_19:1;
        unsigned int ldi_input_enable:1;    /* LCD_D22 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_21:1;
        unsigned int lpp_input_enable:1;    /* LCD_D23 pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_23_31:9;
    };

    uint32_t reg32;
} com_pin_input_enable2_t;

#define COM_PIN_INPUT_ENABLE3_OFFSET 0x311
#define COM_PIN_INPUT_ENABLE3_RESET  0x00000000
typedef union com_pin_input_enable3_u {
    struct {
        unsigned int lsck_input_enable:1;   /* LSCK pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int lsda_input_enable:1;   /* LSDA pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_3:1;
        unsigned int lcsn_input_enable:1;   /* LCSN pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_5:1;
        unsigned int ldc_input_enable:1;    /* LDC pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_7:1;
        unsigned int lspi_input_enable:1;   /* LSPI pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_9:1;
        unsigned int lsdi_input_enable:1;   /* LSDI pin input enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} com_pin_input_enable3_t;

#define COM_PIN_INPUT_DATA0_OFFSET 0x312
#define COM_PIN_INPUT_DATA0_RESET  0x00000000
typedef union com_pin_input_data0_u {
    struct {
        unsigned int ld0_input_data:1;      /* LD0 pin input data */
        unsigned int ld1_input_data:1;      /* LD1 pin input data */
        unsigned int ld2_input_data:1;      /* LD2 pin input data */
        unsigned int ld3_input_data:1;      /* LD3 pin input data */
        unsigned int ld4_input_data:1;      /* LD4 pin input data */
        unsigned int ld5_input_data:1;      /* LD5 pin input data */
        unsigned int ld6_input_data:1;      /* LD6 pin input data */
        unsigned int ld7_input_data:1;      /* LD7 pin input data */
        unsigned int ld8_input_data:1;      /* LD8 pin input data */
        unsigned int ld9_input_data:1;      /* LD9 pin input data */
        unsigned int ld10_input_data:1;     /* LD10 pin input data */
        unsigned int ld11_input_data:1;     /* LD11 pin input data */
        unsigned int ld12_input_data:1;     /* LD12 pin input data */
        unsigned int ld13_input_data:1;     /* LD13 pin input data */
        unsigned int ld14_input_data:1;     /* LD14 pin input data */
        unsigned int ld15_input_data:1;     /* LD15 pin input data */
        unsigned int ld16_input_data:1;     /* LD16 pin input data */
        unsigned int ld17_input_data:1;     /* LD17 pin input data */
        unsigned int undefined_bits_18_31:14;
    };

    uint32_t reg32;
} com_pin_input_data0_t;

#define COM_PIN_INPUT_DATA1_OFFSET 0x313
#define COM_PIN_INPUT_DATA1_RESET  0x00000000
typedef union com_pin_input_data1_u {
    struct {
        unsigned int lpw0_input_data:1;     /* LPW0 pin input data */
        unsigned int lpw1_input_data:1;     /* LPW1 pin input data */
        unsigned int lpw2_input_data:1;     /* LPW2 pin input data */
        unsigned int undefined_bit_3:1;
        unsigned int lsc0_input_data:1;     /* LSC0 pin input data */
        unsigned int lsc1_input_data:1;     /* LSC1 pin input data */
        unsigned int lvs_input_data:1;      /* LVS pin input data */
        unsigned int lhs_input_data:1;      /* LHS pin input data */
        unsigned int lhp0_input_data:1;     /* LHP0 pin input data */
        unsigned int lhp1_input_data:1;     /* LHP1 pin input data */
        unsigned int lhp2_input_data:1;     /* LHP2 pin input data */
        unsigned int undefined_bit_11:1;
        unsigned int lvp0_input_data:1;     /* LVP0 pin input data */
        unsigned int lvp1_input_data:1;     /* LVP1 pin input data */
        unsigned int undefined_bits_14_15:2;
        unsigned int lm0_input_data:1;      /* LM0 pin input data */
        unsigned int lm1_input_data:1;      /* LM1 pin input data */
        unsigned int ldi_input_data:1;      /* LDI pin input data */
        unsigned int lpp_input_data:1;      /* LPP pin input data */
        unsigned int lsck_input_data:1;     /* LSCK pin input data */
        unsigned int lsda_input_data:1;     /* LSDA pin input data */
        unsigned int lcsn_input_data:1;     /* LCSN pin input data */
        unsigned int ldc_input_data:1;      /* LDC pin input data */
        unsigned int lspi_input_data:1;     /* LSPI pin input data */
        unsigned int lsdi_input_data:1;     /* LSDI pin input data */
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} com_pin_input_data1_t;

#define COM_PIN_OUTPUT_SELECT0_OFFSET 0x314
#define COM_PIN_OUTPUT_SELECT0_RESET  0x00000000
typedef union com_pin_output_select0_u {
    struct {
        unsigned int ld0_output_select:3;   /* LD0 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int ld1_output_select:3;   /* LD1 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int ld2_output_select:3;   /* LD2 pin output select */
        unsigned int undefined_bit_11:1;
        unsigned int ld3_output_select:3;   /* LD3 pin output select */
        unsigned int undefined_bit_15:1;
        unsigned int ld4_output_select:3;   /* LD4 pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int ld5_output_select:3;   /* LD5 pin output select */
        unsigned int undefined_bit_23:1;
        unsigned int ld6_output_select:3;   /* LD6 pin output select */
        unsigned int undefined_bit_27:1;
        unsigned int ld7_output_select:3;   /* LD7 pin output select */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_output_select0_t;

#define COM_PIN_OUTPUT_SELECT1_OFFSET 0x315
#define COM_PIN_OUTPUT_SELECT1_RESET  0x00000000
typedef union com_pin_output_select1_u {
    struct {
        unsigned int ld8_output_select:3;   /* LD8 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int ld9_output_select:3;   /* LD9 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int ld10_output_select:3;  /* LD10 pin output select */
        unsigned int undefined_bit_11:1;
        unsigned int ld11_output_select:3;  /* LD11 pin output select */
        unsigned int undefined_bit_15:1;
        unsigned int ld12_output_select:3;  /* LD12 pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int ld13_output_select:3;  /* LD13 pin output select */
        unsigned int undefined_bit_23:1;
        unsigned int ld14_output_select:3;  /* LD14 pin output select */
        unsigned int undefined_bit_27:1;
        unsigned int ld15_output_select:3;  /* LD15 pin output select */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_output_select1_t;

#define COM_PIN_OUTPUT_SELECT2_OFFSET 0x316
#define COM_PIN_OUTPUT_SELECT2_RESET  0x00000000
typedef union com_pin_output_select2_u {
    struct {
        unsigned int ld16_output_select:3;  /* LD16 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int ld17_output_select:3;  /* LD17 pin output select */
        unsigned int undefined_bits_7_31:25;
    };

    uint32_t reg32;
} com_pin_output_select2_t;

#define COM_PIN_OUTPUT_SELECT3_OFFSET 0x317
#define COM_PIN_OUTPUT_SELECT3_RESET  0x00000000
typedef union com_pin_output_select3_u {
    struct {
        unsigned int lpw0_output_select:3;  /* LCD_PWR0 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int lpw1_output_select:3;  /* LCD_PWR1 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int lpw2_output_select:3;  /* LCD_PWR2 pin output select */
        unsigned int undefined_bits_11_15:5;
        unsigned int lsc0_output_select:3;  /* LCD_PCLK pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int lsc1_output_select:3;  /* LCD_WR_N pin output select */
        unsigned int undefined_bit_23:1;
        unsigned int lvs_output_select:3;   /* LCD_VSYNC pin output select */
        unsigned int undefined_bit_27:1;
        unsigned int lhs_output_select:3;   /* LCD_HSYNC pin output select */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} com_pin_output_select3_t;

#define COM_PIN_OUTPUT_SELECT4_OFFSET 0x318
#define COM_PIN_OUTPUT_SELECT4_RESET  0x00000000
typedef union com_pin_output_select4_u {
    struct {
        unsigned int lhp0_output_select:3;  /* LCD_D21 pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int lhp1_output_select:3;  /* LCD_D18 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int lhp2_output_select:3;  /* LCD_D19 pin output select */
        unsigned int undefined_bits_11_15:5;
        unsigned int lvp0_output_select:3;  /* LCD_DC1 pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int lvp1_output_select:3;  /* LCD_D20 pin output select */
        unsigned int undefined_bits_23_31:9;
    };

    uint32_t reg32;
} com_pin_output_select4_t;

#define COM_PIN_OUTPUT_SELECT5_OFFSET 0x319
#define COM_PIN_OUTPUT_SELECT5_RESET  0x00000000
typedef union com_pin_output_select5_u {
    struct {
        unsigned int lm0_output_select:3;   /* LCD_CS1_N pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int lm1_output_select:3;   /* LCD_M1 pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int ldi_output_select:3;   /* LCD_D22 pin output select */
        unsigned int undefined_bit_11:1;
        unsigned int lpp_output_select:3;   /* LCD_D23 pin output select */
        unsigned int undefined_bits_15_31:17;
    };

    uint32_t reg32;
} com_pin_output_select5_t;

#define COM_PIN_OUTPUT_SELECT6_OFFSET 0x31A
#define COM_PIN_OUTPUT_SELECT6_RESET  0x00000000
typedef union com_pin_output_select6_u {
    struct {
        unsigned int lsck_output_select:3;  /* LSCK pin output select */
        unsigned int undefined_bit_3:1;
        unsigned int lsda_output_select:3;  /* LSDA pin output select */
        unsigned int undefined_bit_7:1;
        unsigned int lcsn_output_select:3;  /* LCSN pin output select */
        unsigned int undefined_bit_11:1;
        unsigned int ldc_output_select:3;   /* LDC pin output select */
        unsigned int undefined_bit_15:1;
        unsigned int lspi_output_select:3;  /* LSPI pin output select */
        unsigned int undefined_bit_19:1;
        unsigned int lsdi_output_select:3;  /* LSDI pin output select */
        unsigned int undefined_bits_23_31:9;
    };

    uint32_t reg32;
} com_pin_output_select6_t;

#define COM_PIN_MISC_CONTROL_OFFSET 0x31B
#define COM_PIN_MISC_CONTROL_RESET  0x00000000
typedef union com_pin_misc_control_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int disp_clock_output:1;   /* Display Clock (DCLK) Enable 0= disable 1= enable display clock to be output on LCD_DE pin (LCD_DE output select must be appropriately programmed for this to be effective) 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} com_pin_misc_control_t;

#define COM_PM0_CONTROL_OFFSET 0x31C
#define COM_PM0_CONTROL_RESET  0x00000000
typedef union com_pm0_control_u {
    struct {
        unsigned int pm0_clock_select:2;    /* PM0 Clock Select 0= output of shift clock divider 1= pixel clock 2= line clock 3= frame clock Notes: 1) Pixel clock, line clock, and frame clock is running only when PW0 signal is enabled. 2) In non-continuous mode, shift clock and pixel clock run continuously, but line clock and frame clock only run while a frame is being sent */
        unsigned int undefined_bits_2_3:2;
        unsigned int pm0_clock_divider:6;   /* PM0 Clock Divider (1 to 64) */
        unsigned int undefined_bits_10_17:8;
        unsigned int pm0_period:6;          /* PM0 Period (4, 8, ... , 256 clock cycles) */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} com_pm0_control_t;

#define COM_PM0_DUTY_CYCLE_OFFSET 0x31D
#define COM_PM0_DUTY_CYCLE_RESET  0x00000000
typedef union com_pm0_duty_cycle_u {
    struct {
        unsigned int pm0_duty_cycle:9;      /* PM0 Duty Cycle (or D) From 1/P to D/P pulse high time where P is the period. This must not be larger than the period */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} com_pm0_duty_cycle_t;

#define COM_PM1_CONTROL_OFFSET 0x31E
#define COM_PM1_CONTROL_RESET  0x00000000
typedef union com_pm1_control_u {
    struct {
        unsigned int pm1_clock_select:2;    /* PM1 Clock Select 0= output of shift clock divider 1= pixel clock 2= line clock 3= frame clock Notes: 1) Pixel clock, line clock, and frame clock is running only when PW0 signal is enabled. 2) In non-continuous mode, shift clock and pixel clock run continuously, but line clock and frame clock only run while a frame is being sent */
        unsigned int undefined_bits_2_3:2;
        unsigned int pm1_clock_divider:6;   /* PM1 Clock Divider (1 to 64) */
        unsigned int undefined_bits_10_17:8;
        unsigned int pm1_period:6;          /* PM1 Period (4, 8, ... , 256 clock cycles) */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} com_pm1_control_t;

#define COM_PM1_DUTY_CYCLE_OFFSET 0x31F
#define COM_PM1_DUTY_CYCLE_RESET  0x00000000
typedef union com_pm1_duty_cycle_u {
    struct {
        unsigned int pm1_duty_cycle:9;      /* PM1 Duty Cycle from 1/P to P/P pulse high time where P is the period. This must not be larger than the period */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} com_pm1_duty_cycle_t;

#define COM_SPI_CONTROL_OFFSET 0x320
#define COM_SPI_CONTROL_RESET  0x00000000
typedef union com_spi_control_u {
    struct {
        unsigned int spi_serial_clk_control:2;/* SPI Serial Clock Control 0= SCK rising edge is active edge 1-clock chip select and no SCK clock edge to latch chip select 1= SCK rising edge is active edge 2-clock chip select with SCK rising clock edge to latch it 2= SCK falling edge is active edge 1-clock chip select and no SCK clock edge to latch chip select 3= SCK falling edge is active edge 2-clock chip select with SCK falling clock edge to latch it This is valid for Host, IS, and LCD SPI */
        unsigned int undefined_bit_2:1;
        unsigned int spi_data_direction:1;  /* SPI Data Direction. This is valid for Host SPI and for sending initialization sequence (IS SPI) only. Note that data direction does not affect the start byte direction (always msb to lsb) and position (always first 8-bit of serial data) for SPI16SB mode. 0 = MSB2LSB 1 = LSB2MSB */
        unsigned int spi_bits_per_cycle:4;  /* SPI Bits per Cycle This is valid for Host and IS SPI only. This parameter determines the number of bits/cycle when SPI is used for host write or for sending initialization sequence. If SPI is used for sending pixel data to the display then pixel clock divider determines the SPI bits/cycle. SPI8DC is 8-bit SPI plus data/command bit SPI16DC is 16-bit SPI plus data/command bit SPI16SB is 16-bit SPI plus an 8-bit start byte preceding the 16-bit data. 0 = SPI8 1 = SPI8DC 2 = SPI12 3 = SPI16 4 = SPI16DC 5 = SPI16SB 6 = SPI18 7 = SPI24 */
        unsigned int undefined_bits_8_15:8;
        unsigned int spi_clk_divider:5;     /* SPI Clock Divider (1 to 32) This clock divider is used only if SPI is enabled for host writes (Host SPI) or for sending initialization sequence (IS SPI). Programmed value is 1 less than the desired (actual) clock divider value. This parameter is forced to 0 (clock divide by 1) for LCD SPI */
        unsigned int undefined_bits_21_23:3;
        unsigned int spi_status_enable:2;   /* SPI Status Enable 00= SPI status disable 01= SPI status enabled for host SPI only 10= SPI status enabled for IS and LCD SPI only 11= SPI status enabled for all SPI cycles SPI status is reflected in SPI_BUSY bit and can generate interrupt. SPI status indicates when SPI module is busy (SPI write cycles are in progress) so its falling edge should be used to generate interrupt. SPI status can also be output on LCD_DE pin. When Host SPI is triggered, the SPI busy is asserted within three display clock cycles after the end of the host write cycle. SPI status is disabled when SPI_ENABLE bit is disabled */
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} com_spi_control_t;

#define COM_SPI_START_BYTE_OFFSET 0x321
#define COM_SPI_START_BYTE_RESET  0x00000000
typedef union com_spi_start_byte_u {
    struct {
        unsigned int spi_data_start_byte:8; /* SPI Data Start Byte This is valid for Host, IS, and LCD SPI */
        unsigned int spi_command_start_byte:8;/* SPI Command Start Byte This is valid for Host, IS, and LCD SPI */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} com_spi_start_byte_t;

#define COM_HSPI_WRITE_DATA_AB_OFFSET 0x322
#define COM_HSPI_WRITE_DATA_AB_RESET  0x00000000
typedef union com_hspi_write_data_ab_u {
    struct {
        unsigned int hspi_write_data_a:16;  /* Host SPI Write Data A bits 15-0 */
        unsigned int hspi_write_data_b:16;  /* Host SPI Write Data B bits 15-0 */
    };

    uint32_t reg32;
} com_hspi_write_data_ab_t;

#define COM_HSPI_WRITE_DATA_CD_OFFSET 0x323
#define COM_HSPI_WRITE_DATA_CD_RESET  0x00000000
typedef union com_hspi_write_data_cd_u {
    struct {
        unsigned int hspi_write_data_c:16;  /* Host SPI Write Data C bits 15-0 */
        unsigned int hspi_write_data_d:16;  /* Host SPI Write Data D bits 15-0 */
    };

    uint32_t reg32;
} com_hspi_write_data_cd_t;

#define COM_HSPI_CS_DC_OFFSET 0x324
#define COM_HSPI_CS_DC_RESET  0x00000000
typedef union com_hspi_cs_dc_u {
    struct {
        unsigned int hspi_raise:1;          /* Host SPI Raise. Raise vector will be returned at the end of the host SPI write cycles 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_1_3:3;
        unsigned int hspi_dc:4;             /* Host SPI Data/Command_ (SDC) 0= Command cycle (SDC=0) 1= Data cycle (SDC=1) This is valid for Host SPI only. Each bit of this parameter corresponds to the four possible host SPI cycles */
        unsigned int hspi_main_cs:4;        /* Host SPI Main display Chip Select (Main SCS_) 0= Main display not selected (Main SCS_=1) 1= Main display selected (Main SCS_=0) This is valid for Host SPI only. Each bit of this parameter corresponds to the four possible host SPI cycles */
        unsigned int hspi_sub_cs:4;         /* Host SPI Sub display Chip Select (Sub SCS_) 0= Sub display not selected (Sub SCS_=1) 1= Sub display selected (Sub SCS_=0) This is valid for Host SPI only. Each bit of this parameter corresponds to the four possible host SPI cycles */
        unsigned int hspi_raise_channel_id:4;/* Win G Channel ID */
        unsigned int undefined_bits_20_23:4;
        unsigned int hspi_raise_vector:5;   /* Host SPI Raise Vector This raise vector is returned after all the triggered host SPI cycles are executed */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} com_hspi_cs_dc_t;

#define COM_SCRATCH_REGISTER_A_OFFSET 0x325
#define COM_SCRATCH_REGISTER_A_RESET  0x00000000
typedef union com_scratch_register_a_u {
    struct {
        unsigned int scratch_register_a:32; /* Scratch Register A */
    };

    uint32_t reg32;
} com_scratch_register_a_t;

#define COM_SCRATCH_REGISTER_B_OFFSET 0x326
#define COM_SCRATCH_REGISTER_B_RESET  0x00000000
typedef union com_scratch_register_b_u {
    struct {
        unsigned int scratch_register_b:32; /* Scratch Register B */
    };

    uint32_t reg32;
} com_scratch_register_b_t;

#define COM_GPIO_CTRL_OFFSET 0x327
#define COM_GPIO_CTRL_RESET  0x00000000
typedef union com_gpio_ctrl_u {
    struct {
        unsigned int gpio_0_debounce_enable:1;/* maps to display pin LCD_PWR0  0 = DISABLE 1 = ENABLE */
        unsigned int gpio_1_debounce_enable:1;/* maps to display pin LCD_PWR1  0 = DISABLE 1 = ENABLE */
        unsigned int gpio_2_debounce_enable:1;/* maps to display pin LCD_PWR2  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} com_gpio_ctrl_t;

#define COM_GPIO_DEBOUNCE_COUNTER_OFFSET 0x328
#define COM_GPIO_DEBOUNCE_COUNTER_RESET  0x00000400
typedef union com_gpio_debounce_counter_u {
    struct {
        unsigned int debounce_counter:32;
    };

    uint32_t reg32;
} com_gpio_debounce_counter_t;

#define COM_CRC_CHECKSUM_LATCHED_OFFSET 0x329
#define COM_CRC_CHECKSUM_LATCHED_RESET  0x00000000
typedef union com_crc_checksum_latched_u {
    struct {
        unsigned int crc_checksum_latched:32;/* CRC Checksum latched */
    };

    uint32_t reg32;
} com_crc_checksum_latched_t;

#define DISP_DISP_SIGNAL_OPTIONS0_OFFSET 0x400
#define DISP_DISP_SIGNAL_OPTIONS0_RESET  0x00000000
typedef union disp_disp_signal_options0_u {
    struct {
        unsigned int undefined_bits_0_7:8;
        unsigned int h_pulse0_enable:1;     /* H Pulse 0 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_9:1;
        unsigned int h_pulse1_enable:1;     /* H Pulse 1 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_11:1;
        unsigned int h_pulse2_enable:1;     /* H Pulse 2 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse0_enable:1;     /* V Pulse 0 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int v_pulse1_enable:1;     /* V Pulse 1 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int v_pulse2_enable:1;     /* V Pulse 2 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int v_pulse3_enable:1;     /* V Pulse 3 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_21_23:3;
        unsigned int m0_enable:1;           /* M0 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_25:1;
        unsigned int m1_enable:1;           /* M1 Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_27_31:5;
    };

    uint32_t reg32;
} disp_disp_signal_options0_t;

#define DISP_DISP_SIGNAL_OPTIONS1_OFFSET 0x401
#define DISP_DISP_SIGNAL_OPTIONS1_RESET  0x00000000
typedef union disp_disp_signal_options1_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int di_enable:1;           /* DI Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_17:1;
        unsigned int pp_enable:1;           /* PP Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_19_31:13;
    };

    uint32_t reg32;
} disp_disp_signal_options1_t;

#define DISP_DISP_WIN_OPTIONS_OFFSET 0x402
#define DISP_DISP_WIN_OPTIONS_RESET  0x00000000
typedef union disp_disp_win_options_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int cursor_enable:1;       /* Cursor Enable  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_17_27:11;
        unsigned int tvo_enable:1;          /* TVO Enable. Steps to start displaying on TV (The order of the first 3 steps can freely change): -- Program and enable TVO module -- Program DISPLAY_CTRL_MODE to NC_DISPLAY -- Program the ASSEMBLY shadow copy of this register field with ENABLE -- Program GENERAL_ACT_REQ to activate the shadow 0 = DISABLE 1 = ENABLE */
        unsigned int dsi_enable:1;          /* MIPI Display Serial Interface Enable. The DSI unit must also be separately enabled in its own register space in order to use DSI functionality. 0 = DISABLE 1 = ENABLE */
        unsigned int hdmi_enable:1;         /* HDMI interface. The HDMI unit must also be separately enabled in its own register space in order to use HDMI functionality. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} disp_disp_win_options_t;

#define DISP_MEM_HIGH_PRIORITY_OFFSET 0x403
#define DISP_MEM_HIGH_PRIORITY_RESET  0x00000000
typedef union disp_mem_high_priority_u {
    struct {
        unsigned int cbr_display0a2mc_hpth:8;/* Window A Memory High Priority threshold Memory access for this window is high priority if the number of filled entries in the return data fifo is less than or equal to this value. Setting this parameter to 0 disables high priority memory request */
        unsigned int cbr_displayb2mc_hpth:7;/* Window B Memory High Priority threshold Memory access for this window is high priority if the number of filled entries in the return data fifo is less than or equal to this value. Setting this parameter to 0 disables high priority memory request. This register is used for both window B0 and B1 */
        unsigned int undefined_bit_15:1;
        unsigned int cbr_display0c2mc_hpth:7;/* Window C Memory High Priority threshold Memory access for this window is high priority if the number of filled entries in the return data fifo is less than or equal to this value. Setting this parameter to 0 disables high priority memory request */
        unsigned int undefined_bit_23:1;
        unsigned int csr_displayhc2mc_hpth:3;/* Cursor Memory High Priority enable 0= memory access for cursor is normal priority 1= memory access for cursor is high priority */
        unsigned int undefined_bits_27_31:5;
    };

    uint32_t reg32;
} disp_mem_high_priority_t;

#define DISP_MEM_HIGH_PRIORITY_TIMER_OFFSET 0x404
#define DISP_MEM_HIGH_PRIORITY_TIMER_RESET  0x00000000
typedef union disp_mem_high_priority_timer_u {
    struct {
        unsigned int cbr_display0a2mc_hptm:6;/* Window A Memory High Priority timer */
        unsigned int undefined_bits_6_7:2;
        unsigned int cbr_displayb2mc_hptm:6;/* Window B Memory High Priority timer This register is used for both window B0 and B1 */
        unsigned int undefined_bits_14_15:2;
        unsigned int cbr_display0c2mc_hptm:6;/* Window C Memory High Priority timer */
        unsigned int undefined_bits_22_23:2;
        unsigned int csr_displayhc2mc_hptm:6;/* Cursor Memory High Priority timer */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} disp_mem_high_priority_timer_t;

#define DISP_DISP_TIMING_OPTIONS_OFFSET 0x405
#define DISP_DISP_TIMING_OPTIONS_RESET  0x00000000
typedef union disp_disp_timing_options_u {
    struct {
        unsigned int vsync_h_position:13;   /* VSYNC Horizontal Position This parameter specifies the position where VSYNC can toggle with respect to H reference point */
        unsigned int undefined_bits_13_31:19;
    };

    uint32_t reg32;
} disp_disp_timing_options_t;

#define DISP_REF_TO_SYNC_OFFSET 0x406
#define DISP_REF_TO_SYNC_RESET  0x00000000
typedef union disp_ref_to_sync_u {
    struct {
        unsigned int h_ref_to_sync:13;      /* H reference to HSYNC (minimum 0 pixel clock) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_ref_to_sync:13;      /* V reference to VSYNC (minimum 1 line clock) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_ref_to_sync_t;

#define DISP_SYNC_WIDTH_OFFSET 0x407
#define DISP_SYNC_WIDTH_RESET  0x00000000
typedef union disp_sync_width_u {
    struct {
        unsigned int h_sync_width:13;       /* HSYNC pulse width (minimum 1 pixel clock) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_sync_width:13;       /* VSYNC pulse width (minimum 1 line clock) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_sync_width_t;

#define DISP_BACK_PORCH_OFFSET 0x408
#define DISP_BACK_PORCH_RESET  0x00000000
typedef union disp_back_porch_u {
    struct {
        unsigned int h_back_porch:13;       /* H back porch */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_back_porch:13;       /* V back porch */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_back_porch_t;

#define DISP_DISP_ACTIVE_OFFSET 0x409
#define DISP_DISP_ACTIVE_RESET  0x00000000
typedef union disp_disp_active_u {
    struct {
        unsigned int h_disp_active:13;      /* H display active width (minimum 16 pixels) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_disp_active:13;      /* V display active width (minimum 16 lines) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_disp_active_t;

#define DISP_FRONT_PORCH_OFFSET 0x40A
#define DISP_FRONT_PORCH_RESET  0x00000000
typedef union disp_front_porch_u {
    struct {
        unsigned int h_front_porch:13;      /* HSYNC front porch (minimum -=PS_=-H_REF_TO_SYNC + 1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_front_porch:13;      /* VSYNC front porch (minimum -=PS_=-V_REF_TO_SYNC + 1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_front_porch_t;

#define DISP_H_PULSE0_CONTROL_OFFSET 0x40B
#define DISP_H_PULSE0_CONTROL_RESET  0x00000000
typedef union disp_h_pulse0_control_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int h_pulse0_mode:1;       /* H Pulse 0 Mode 0= Normal mode 1= Single-clock mode 0 = NORMAL 1 = ONE_CLOCK */
        unsigned int h_pulse0_polarity:1;   /* H Pulse 0 Polarity. Polarity adjustment is done before the vertical qualifier is applied. 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int h_pulse0_v_qual:2;     /* H Pulse 0 Vertical Qualifier 0= always running 2= run during vertical active area 3= run during vertical active plus 1 line 0 = ALWAYS 2 = VACTIVE 3 = VACTIVE1 */
        unsigned int h_pulse0_last:4;       /* H Pulse 0 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position 6= end on Start D position 7= end on End D position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C 6 = START_D 7 = END_D */
        unsigned int undefined_bits_12_31:20;
    };

    uint32_t reg32;
} disp_h_pulse0_control_t;

#define DISP_H_PULSE0_POSITION_A_OFFSET 0x40C
#define DISP_H_PULSE0_POSITION_A_RESET  0x00000000
typedef union disp_h_pulse0_position_a_u {
    struct {
        unsigned int h_pulse0_start_a:13;   /* H Pulse 0 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse0_end_a:13;     /* H Pulse 0 End A (minimum -=PS_=-H_PULSE0_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse0_position_a_t;

#define DISP_H_PULSE0_POSITION_B_OFFSET 0x40D
#define DISP_H_PULSE0_POSITION_B_RESET  0x00000000
typedef union disp_h_pulse0_position_b_u {
    struct {
        unsigned int h_pulse0_start_b:13;   /* H Pulse 0 Start B (minimum -=PS_=-H_PULSE0_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse0_end_b:13;     /* H Pulse 0 End B (minimum -=PS_=-H_PULSE0_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse0_position_b_t;

#define DISP_H_PULSE0_POSITION_C_OFFSET 0x40E
#define DISP_H_PULSE0_POSITION_C_RESET  0x00000000
typedef union disp_h_pulse0_position_c_u {
    struct {
        unsigned int h_pulse0_start_c:13;   /* H Pulse 0 Start C (minimum -=PS_=-H_PULSE0_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse0_end_c:13;     /* H Pulse 0 End C (minimum -=PS_=-H_PULSE0_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse0_position_c_t;

#define DISP_H_PULSE0_POSITION_D_OFFSET 0x40F
#define DISP_H_PULSE0_POSITION_D_RESET  0x00000000
typedef union disp_h_pulse0_position_d_u {
    struct {
        unsigned int h_pulse0_start_d:13;   /* H Pulse 0 Start D (minimum -=PS_=-H_PULSE0_END_C+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse0_end_d:13;     /* H Pulse 0 End D (minimum -=PS_=-H_PULSE0_START_D+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse0_position_d_t;

#define DISP_H_PULSE1_CONTROL_OFFSET 0x410
#define DISP_H_PULSE1_CONTROL_RESET  0x00000000
typedef union disp_h_pulse1_control_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int h_pulse1_mode:1;       /* H Pulse 1 Mode 0= Normal mode 1= Single-clock mode 0 = NORMAL 1 = ONE_CLOCK */
        unsigned int h_pulse1_polarity:1;   /* H Pulse 1 Polarity. Polarity adjustment is done before the vertical qualifier is applied 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int h_pulse1_v_qual:2;     /* H Pulse 1 Vertical Qualifier 0= always running 2= run during vertical active area 3= run during vertical active plus 1 line 0 = ALWAYS 2 = VACTIVE 3 = VACTIVE1 */
        unsigned int h_pulse1_last:4;       /* H Pulse 1 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position 6= end on Start D position 7= end on End D position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C 6 = START_D 7 = END_D */
        unsigned int undefined_bits_12_31:20;
    };

    uint32_t reg32;
} disp_h_pulse1_control_t;

#define DISP_H_PULSE1_POSITION_A_OFFSET 0x411
#define DISP_H_PULSE1_POSITION_A_RESET  0x00000000
typedef union disp_h_pulse1_position_a_u {
    struct {
        unsigned int h_pulse1_start_a:13;   /* H Pulse 1 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse1_end_a:13;     /* H Pulse 1 End A (minimum -=PS_=-H_PULSE1_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse1_position_a_t;

#define DISP_H_PULSE1_POSITION_B_OFFSET 0x412
#define DISP_H_PULSE1_POSITION_B_RESET  0x00000000
typedef union disp_h_pulse1_position_b_u {
    struct {
        unsigned int h_pulse1_start_b:13;   /* H Pulse 1 Start B (minimum -=PS_=-H_PULSE1_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse1_end_b:13;     /* H Pulse 1 End B (minimum -=PS_=-H_PULSE1_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse1_position_b_t;

#define DISP_H_PULSE1_POSITION_C_OFFSET 0x413
#define DISP_H_PULSE1_POSITION_C_RESET  0x00000000
typedef union disp_h_pulse1_position_c_u {
    struct {
        unsigned int h_pulse1_start_c:13;   /* H Pulse 1 Start C (minimum -=PS_=-H_PULSE1_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse1_end_c:13;     /* H Pulse 1 End C (minimum -=PS_=-H_PULSE1_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse1_position_c_t;

#define DISP_H_PULSE1_POSITION_D_OFFSET 0x414
#define DISP_H_PULSE1_POSITION_D_RESET  0x00000000
typedef union disp_h_pulse1_position_d_u {
    struct {
        unsigned int h_pulse1_start_d:13;   /* H Pulse 1 Start D (minimum -=PS_=-H_PULSE1_END_C+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse1_end_d:13;     /* H Pulse 1 End D (minimum -=PS_=-H_PULSE1_START_D+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse1_position_d_t;

#define DISP_H_PULSE2_CONTROL_OFFSET 0x415
#define DISP_H_PULSE2_CONTROL_RESET  0x00000000
typedef union disp_h_pulse2_control_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int h_pulse2_mode:1;       /* H Pulse 2 Mode 0= Normal mode 1= Single-clock mode 0 = NORMAL 1 = ONE_CLOCK */
        unsigned int h_pulse2_polarity:1;   /* H Pulse 2 Polarity. Polarity adjustment is done before the vertical qualifier is applied 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int h_pulse2_v_qual:2;     /* H Pulse 2 Vertical Qualifier 0= always running 2= run during vertical active area 3= run during vertical active plus 1 line 0 = ALWAYS 2 = VACTIVE 3 = VACTIVE1 */
        unsigned int h_pulse2_last:4;       /* H Pulse 2 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position 6= end on Start D position 7= end on End D position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C 6 = START_D 7 = END_D */
        unsigned int undefined_bits_12_31:20;
    };

    uint32_t reg32;
} disp_h_pulse2_control_t;

#define DISP_H_PULSE2_POSITION_A_OFFSET 0x416
#define DISP_H_PULSE2_POSITION_A_RESET  0x00000000
typedef union disp_h_pulse2_position_a_u {
    struct {
        unsigned int h_pulse2_start_a:13;   /* H Pulse 2 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse2_end_a:13;     /* H Pulse 2 End A (minimum -=PS_=-H_PULSE2_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse2_position_a_t;

#define DISP_H_PULSE2_POSITION_B_OFFSET 0x417
#define DISP_H_PULSE2_POSITION_B_RESET  0x00000000
typedef union disp_h_pulse2_position_b_u {
    struct {
        unsigned int h_pulse2_start_b:13;   /* H Pulse 2 Start B (minimum -=PS_=-H_PULSE2_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse2_end_b:13;     /* H Pulse 2 End B (minimum -=PS_=-H_PULSE2_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse2_position_b_t;

#define DISP_H_PULSE2_POSITION_C_OFFSET 0x418
#define DISP_H_PULSE2_POSITION_C_RESET  0x00000000
typedef union disp_h_pulse2_position_c_u {
    struct {
        unsigned int h_pulse2_start_c:13;   /* H Pulse 2 Start C (minimum -=PS_=-H_PULSE2_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse2_end_c:13;     /* H Pulse 2 End C (minimum -=PS_=-H_PULSE2_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse2_position_c_t;

#define DISP_H_PULSE2_POSITION_D_OFFSET 0x419
#define DISP_H_PULSE2_POSITION_D_RESET  0x00000000
typedef union disp_h_pulse2_position_d_u {
    struct {
        unsigned int h_pulse2_start_d:13;   /* H Pulse 2 Start D (minimum -=PS_=-H_PULSE2_END_C+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int h_pulse2_end_d:13;     /* H Pulse 2 End D (minimum -=PS_=-H_PULSE2_START_D+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_h_pulse2_position_d_t;

#define DISP_V_PULSE0_CONTROL_OFFSET 0x41A
#define DISP_V_PULSE0_CONTROL_RESET  0x00000000
typedef union disp_v_pulse0_control_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int v_pulse0_polarity:1;   /* V Pulse 0 Polarity 0= High 1= Low 0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int v_pulse0_delay:2;      /* V Pulse 0 Delay 0= no delay 1= 1-line delay 2= 2-line delay 3= reserved 0 = NODELAY 1 = DELAY1 2 = DELAY2 */
        unsigned int v_pulse0_last:4;       /* V Pulse 0 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C */
        unsigned int undefined_bits_12_15:4;
        unsigned int v_pulse0_h_position:13;/* V Pulse 0 Horizontal Position This parameter specifies the position where V Pulse 0 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse0_control_t;

#define DISP_V_PULSE0_POSITION_A_OFFSET 0x41B
#define DISP_V_PULSE0_POSITION_A_RESET  0x00000000
typedef union disp_v_pulse0_position_a_u {
    struct {
        unsigned int v_pulse0_start_a:13;   /* V Pulse 0 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse0_end_a:13;     /* V Pulse 0 End A (minimum -=PS_=-V_PULSE0_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse0_position_a_t;

#define DISP_V_PULSE0_POSITION_B_OFFSET 0x41C
#define DISP_V_PULSE0_POSITION_B_RESET  0x00000000
typedef union disp_v_pulse0_position_b_u {
    struct {
        unsigned int v_pulse0_start_b:13;   /* V Pulse 0 Start B (minimum -=PS_=-V_PULSE0_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse0_end_b:13;     /* V Pulse 0 End B (minimum -=PS_=-V_PULSE0_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse0_position_b_t;

#define DISP_V_PULSE0_POSITION_C_OFFSET 0x41D
#define DISP_V_PULSE0_POSITION_C_RESET  0x00000000
typedef union disp_v_pulse0_position_c_u {
    struct {
        unsigned int v_pulse0_start_c:13;   /* V Pulse 0 Start C (minimum -=PS_=-V_PULSE0_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse0_end_c:13;     /* V Pulse 0 End C (minimum -=PS_=-V_PULSE0_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse0_position_c_t;

#define DISP_V_PULSE1_CONTROL_OFFSET 0x41E
#define DISP_V_PULSE1_CONTROL_RESET  0x00000000
typedef union disp_v_pulse1_control_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int v_pulse1_polarity:1;   /* V pulse 1 Polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bit_5:1;
        unsigned int v_pulse1_delay:2;      /* V pulse 1 Delay 0= no delay 1= 1-line delay 2= 2-line delay 3= reserved 0 = NODELAY 1 = DELAY1 2 = DELAY2 */
        unsigned int v_pulse1_last:4;       /* V pulse 1 Last point 0= end on Start A position 1= end on End A position 2= end on Start B position 3= end on End B position 4= end on Start C position 5= end on End C position others= reserved 0 = START_A 1 = END_A 2 = START_B 3 = END_B 4 = START_C 5 = END_C */
        unsigned int undefined_bits_12_15:4;
        unsigned int v_pulse1_h_position:13;/* V Pulse 1 Horizontal Position This parameter specifies the position where V Pulse 1 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse1_control_t;

#define DISP_V_PULSE1_POSITION_A_OFFSET 0x41F
#define DISP_V_PULSE1_POSITION_A_RESET  0x00000000
typedef union disp_v_pulse1_position_a_u {
    struct {
        unsigned int v_pulse1_start_a:13;   /* V Pulse 1 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse1_end_a:13;     /* V Pulse 1 End A (minimum -=PS_=-V_PULSE1_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse1_position_a_t;

#define DISP_V_PULSE1_POSITION_B_OFFSET 0x420
#define DISP_V_PULSE1_POSITION_B_RESET  0x00000000
typedef union disp_v_pulse1_position_b_u {
    struct {
        unsigned int v_pulse1_start_b:13;   /* V Pulse 1 Start B (minimum -=PS_=-V_PULSE1_END_A+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse1_end_b:13;     /* V Pulse 1 End B (minimum -=PS_=-V_PULSE1_START_B+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse1_position_b_t;

#define DISP_V_PULSE1_POSITION_C_OFFSET 0x421
#define DISP_V_PULSE1_POSITION_C_RESET  0x00000000
typedef union disp_v_pulse1_position_c_u {
    struct {
        unsigned int v_pulse1_start_c:13;   /* V Pulse 1 Start C (minimum -=PS_=-V_PULSE1_END_B+1) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse1_end_c:13;     /* V Pulse 1 End C (minimum -=PS_=-V_PULSE1_START_C+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse1_position_c_t;

#define DISP_V_PULSE2_CONTROL_OFFSET 0x422
#define DISP_V_PULSE2_CONTROL_RESET  0x00000000
typedef union disp_v_pulse2_control_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int v_pulse2_polarity:1;   /* V pulse 2 Polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_5_7:3;
        unsigned int v_pulse2_last:1;       /* V pulse 2 Last point 0= end on Start A position 1= end on End A position others= reserved 0 = START_A 1 = END_A */
        unsigned int undefined_bits_9_15:7;
        unsigned int v_pulse2_h_position:13;/* V Pulse 2 Horizontal Position This parameter specifies the position where V Pulse 2 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse2_control_t;

#define DISP_V_PULSE2_POSITION_A_OFFSET 0x423
#define DISP_V_PULSE2_POSITION_A_RESET  0x00000000
typedef union disp_v_pulse2_position_a_u {
    struct {
        unsigned int v_pulse2_start_a:13;   /* V Pulse 2 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse2_end_a:13;     /* V Pulse 2 End A (minimum -=PS_=-V_PULSE2_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse2_position_a_t;

#define DISP_V_PULSE3_CONTROL_OFFSET 0x424
#define DISP_V_PULSE3_CONTROL_RESET  0x00000000
typedef union disp_v_pulse3_control_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int v_pulse3_polarity:1;   /* V pulse 3 Polarity  0 = HIGH 1 = LOW */
        unsigned int undefined_bits_5_7:3;
        unsigned int v_pulse3_last:1;       /* V pulse 3 Last point 0= end on Start A position 1= end on End A position others= reserved 0 = START_A 1 = END_A */
        unsigned int undefined_bits_9_15:7;
        unsigned int v_pulse3_h_position:13;/* V Pulse 3 Horizontal Position This parameter specifies the position where V Pulse 3 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse3_control_t;

#define DISP_V_PULSE3_POSITION_A_OFFSET 0x425
#define DISP_V_PULSE3_POSITION_A_RESET  0x00000000
typedef union disp_v_pulse3_position_a_u {
    struct {
        unsigned int v_pulse3_start_a:13;   /* V Pulse 3 Start A (minimum 0) */
        unsigned int undefined_bits_13_15:3;
        unsigned int v_pulse3_end_a:13;     /* V Pulse 3 End A (minimum -=PS_=-V_PULSE3_START_A+1) */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_v_pulse3_position_a_t;

#define DISP_M0_CONTROL_OFFSET 0x426
#define DISP_M0_CONTROL_RESET  0x00000000
typedef union disp_m0_control_u {
    struct {
        unsigned int m0_clock_select:2;     /* M0 Clock Select 00= pixel clock (for diagnostic) 01= reserved 10= line clock 11= frame clock 0 = PCLK 2 = LCLK 3 = FCLK */
        unsigned int undefined_bits_2_3:2;
        unsigned int m0_phase_control:2;    /* M0 Phase Control 00= free-running 01= reserved 10= reset at beginning of vertical active display 11= invert at beginning of frame This should be set to free-running if frame clock is used. 0 = FREE_RUN 2 = VACTIVE_RESTART 3 = FRAME_INVERT */
        unsigned int m0_phase_reset:1;      /* M0 Phase Reset This bit is effective only when M0 is not free running. 0= frequency (phase) counter is not reset 1= frequency (phase) counter is reset at beginning of vertical active display if phase control is set to VACTIVE_RESTART or at beginning of frame if phase control is set to FRAME_INVERT 0 = DISABLE 1 = ENABLE */
        unsigned int m0_polarity:1;         /* M0 Polarity. Polarity adjustment is applied last after phase control is applied. 0 = HIGH 1 = LOW */
        unsigned int m0_period:5;           /* M0 Period This should be program to the half of the desired M0 period (in lines) minus 1 */
        unsigned int undefined_bits_13_15:3;
        unsigned int m0_h_position:13;      /* M0 Horizontal Position This parameter specifies the position where M0 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_m0_control_t;

#define DISP_M1_CONTROL_OFFSET 0x427
#define DISP_M1_CONTROL_RESET  0x00000000
typedef union disp_m1_control_u {
    struct {
        unsigned int m1_clock_select:2;     /* M1 Clock Select 00= pixel clock (for diagnostic) 01= synchronous to M0 provided that M0 is generated using line clock. This will not work if M0 is not generated using line clock. In this case, M1 is controlled by -=PS_=-M0_PHASE_RESET and -=PS_=-M0_PERIOD, -=PS_=-M1_PHASE_CONTROL and -=PS_=-M1_POLARITY. 10= line clock 11= frame clock 0 = PCLK 1 = M0SYNC 2 = LCLK 3 = FCLK */
        unsigned int undefined_bits_2_3:2;
        unsigned int m1_phase_control:2;    /* M1 Phase Control 00= free-running 01= reserved 10= reset at beginning of vertical active display 11= invert at beginning of frame This should be set to free-running if frame clock is used. 0 = FREE_RUN 2 = VACTIVE_RESTART 3 = FRAME_INVERT */
        unsigned int m1_phase_reset:1;      /* M1 Phase Reset This bit is effective only when M1 is not free running. 0= frequency (phase) counter is not reset 1= frequency (phase) counter is reset at beginning of vertical active display if phase control is set to VACTIVE_RESTART or at beginning of frame if phase control is set to FRAME_INVERT 0 = DISABLE 1 = ENABLE */
        unsigned int m1_polarity:1;         /* M1 Polarity. Polarity adjustment is applied last after phase control is applied. 0 = HIGH 1 = LOW */
        unsigned int m1_period:5;           /* M1 Period This should be program to the half of the desired M1 period (in lines) minus 1 */
        unsigned int undefined_bits_13_15:3;
        unsigned int m1_h_position:13;      /* M1 Horizontal Position This parameter specifies the position where M0 can toggle with respect to H reference point */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_m1_control_t;

#define DISP_DI_CONTROL_OFFSET 0x428
#define DISP_DI_CONTROL_RESET  0x00000000
typedef union disp_di_control_u {
    struct {
        unsigned int di_mode:2;             /* DI signal Mode 00= DI is always low 01= DI is always high 10= DI is forced high every time M0 (before polarity adjustment) toggles from low to high; otherwise then DI toggles every line 11= DI has same frequency (phase) as M0 (before M0 polarity adjustment) */
        unsigned int undefined_bits_2_3:2;
        unsigned int pixdata_inv_select:1;  /* Pixel Data Inversion Select 0= DI signal controls pixel data inversion 1= (DI xor M0) controls pixel data inversion. 0 = DI 1 = DIXORM0 */
        unsigned int undefined_bit_5:1;
        unsigned int pixdata_inv_control:2; /* Pixel Data Inversion Control The control signal for pixel data inversion is defined by -=PS_=-PIXDATA_INV_SELECT 00= no pixel data inversion regardless of control signal state. 01= Pixels 0, 2, 4 ... are inverted if control signal is high. Pixels 1, 3, 5 ... are inverted if control signal is low. 10= Pixels 1, 3, 5 ... are inverted if control signal is high. Pixels 0, 2, 4 ... are inverted if control signal is low. 11= all pixel data is inverted if control signal is high. NOTE: Pixel data inversion is NOT supported for 2-pixel/3-clock 12-bit parallel display data format!!! 0 = NOINV 1 = EVENINV 2 = ODDINV 3 = ALLINV */
        unsigned int undefined_bits_8_15:8;
        unsigned int di_h_position:13;      /* DI signal Horizontal Position This parameter specifies the position where DI signal can toggle with respect to H reference point. It should not be programmed larger than -=PS_=-PP_H_POSITION if DI is used to control PP signal generation */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} disp_di_control_t;

#define DISP_PP_CONTROL_OFFSET 0x429
#define DISP_PP_CONTROL_RESET  0x00000000
typedef union disp_pp_control_u {
    struct {
        unsigned int pp_direction:2;        /* PP Direction (incrementing or decrementing) 0= always from pulse 0 to 127 (regardless of DI signal) 1= 0 to 127 if DI=0 and 127 to 0 if DI=1 2= 127 to 0 if DI=0 and 0 to 127 if DI=1 3= always 127 to 0 regardless of DI 0 = ALWAYS_INC 1 = INC_IF_DI0 2 = DEC_IF_DI0 3 = ALWAYS_DEC */
        unsigned int pp_v_qualifier:2;      /* PP Vertical Qualifier 0= free running (not qualified) 1= V Pulse 1 qualified 2= V Pulse 2 qualified 3= V Pulse 3 qualified 0 = FREE_RUN 1 = VPULSE1 2 = VPULSE2 3 = VPULSE3 */
        unsigned int pp_h_delay:4;          /* PP signal Horizontal Delay (0 to 15) This parameter specifies the position where PP signal generation starts with respect to H reference point. If DI is used to generate PP signal then this parameter should not be smaller than -=PS_=-DI_H_POSITION */
        unsigned int pp_high_pulse:4;       /* PP High Pulse width (1 to 16) */
        unsigned int pp_low_pulse:4;        /* PP Low Pulse width (1 to 16) */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} disp_pp_control_t;

#define DISP_PP_SELECT_A_OFFSET 0x42A
#define DISP_PP_SELECT_A_RESET  0x00000000
typedef union disp_pp_select_a_u {
    struct {
        unsigned int pp_select_a:32;        /* PP Select bits 31 to 0 */
    };

    uint32_t reg32;
} disp_pp_select_a_t;

#define DISP_PP_SELECT_B_OFFSET 0x42B
#define DISP_PP_SELECT_B_RESET  0x00000000
typedef union disp_pp_select_b_u {
    struct {
        unsigned int pp_select_b:32;        /* PP Select bits 63 to 32 */
    };

    uint32_t reg32;
} disp_pp_select_b_t;

#define DISP_PP_SELECT_C_OFFSET 0x42C
#define DISP_PP_SELECT_C_RESET  0x00000000
typedef union disp_pp_select_c_u {
    struct {
        unsigned int pp_select_c:32;        /* PP Select bits 95 to 64 */
    };

    uint32_t reg32;
} disp_pp_select_c_t;

#define DISP_PP_SELECT_D_OFFSET 0x42D
#define DISP_PP_SELECT_D_RESET  0x00000000
typedef union disp_pp_select_d_u {
    struct {
        unsigned int pp_select_d:32;        /* PP Select bits 127 to 96 */
    };

    uint32_t reg32;
} disp_pp_select_d_t;

#define DISP_DISP_CLOCK_CONTROL_OFFSET 0x42E
#define DISP_DISP_CLOCK_CONTROL_RESET  0x00000006
typedef union disp_disp_clock_control_u {
    struct {
        unsigned int shift_clk_divider:8;   /* Shift Clock Divider 0 = divide by 1 1 = divide by 1.5 2 = divide by 2 3 = divide by 2.5 4 = divide by 3 : : : : 254 = divide by 128 255 = divide by 128.5 Pixel clock divider is used to divide output of internal shift clock divider to generate internal pixel clock which is used to clock the internal horizontal and vertical counters. This divider also determines the output format for parallel interface, serial interface, and LCD SPI interface in conjunction with Display Data Format parameter. For 1-pixel/1-clock parallel display interface, valid settings are PCD1, PCD2, and PCD4.  Note that the main reason to use PCD2 and PCD4 is to get higher frequency PP clock because the PP clock is always generated from the output of shift clock divider. For non 1-pixel/1-clock parallel display interface, valid settings are, PCD1H (2-pixel/3-clock), PCD2 (1-pixel/2-clock), and PCD3 (1-pixel/3-clock).  For 1-channel serial display interface, valid settings are PCD3 (3-bpp 1-ch),
 PCD4 (3-bpp 1-ch), PCD6 (6-bpp 1-ch), PCD9 (9-bpp 1-ch), PCD12 (12-bpp 1-ch), PCD16 (16-bpp 1-ch), PCD18 (18-bpp 1-ch).  For 2-channel serial display interface, valid settings are PCD2 (3-bpp 2-ch), PCD3 (6-bpp 2-ch), PCD6 (12-bpp 2-ch), PCD8 (16-bpp 2-ch), PCD9 (18-bpp 2-ch).  For 3-channel serial display interface, valid settings are PCD1 (3-bpp 3-ch), PCD2 (6-bpp 3-ch), PCD3 (9-bpp 3-ch), PCD4 (12-bpp 3-ch), PCD6 (18-bpp 3-ch).  For LCD SPI interface, valid settings are PCD12 (B4G4R4), PCD16 (B5G6R5), PCD18 (B6G6R6), PCD24 (B8G8R8), PCD8 (B5G6R5 with data/command bit), PCD6 (B5G6R5 with data/command start byte - depending on data/command bit), PCD4 (P8 for spi8), PCD9 (B5G6R5 with chip select deassertion at 8-bit boundary, spi16x2), PCD3 (P8 for spidc), PCD2 (B5G6R5 with data/command bit and chip select deassertion at 9-bit boundary, spi16x2dc), and PCD13 (spi12p2, no chip select deassertion between pairs of pixels) */
        unsigned int pixel_clk_divider:4;   /* Pixel Clock Divider 0000= divide by 1 0001= divide by 1.5 0010= divide by 2 0011= divide by 3 0100= divide by 4 0101= divide by 6 0110= divide by 8 0111= divide by 9 1000= divide by 12 1001= divide by 16 1010= divide by 18 1011= divide by 24 1100= divide by 13 other= reserved 0 = PCD1 1 = PCD1H 2 = PCD2 3 = PCD3 4 = PCD4 5 = PCD6 6 = PCD8 7 = PCD9 8 = PCD12 9 = PCD16 10 = PCD18 11 = PCD24 12 = PCD13 */
        unsigned int undefined_bits_12_31:20;
    };

    uint32_t reg32;
} disp_disp_clock_control_t;

#define DISP_DISP_INTERFACE_CONTROL_OFFSET 0x42F
#define DISP_DISP_INTERFACE_CONTROL_RESET  0x00000000
typedef union disp_disp_interface_control_u {
    struct {
        unsigned int disp_data_format:4;    /* Display Data Format Pixel Clock Divider is used together with this parameter to determine the exact display data format. 0 = DF1P1C : 0= 1-pixel/1-clock up to 24-bit parallel  1 = DF1P2C24B : 1= 1-pixel/2-clock 24-bit parallel  2 = DF1P2C18B : 2= 1-pixel/2-clock 18-bit parallel or 2-pixel/3-clock 12-bit parallel or 1-pixel/3-clock 18-bit parallel NOTE: for 2-pixel/3-clock 12-bit parallel, the horizontal display active time must be even number of pixels.  3 = DF1P2C16B : 3= 1-pixel/2-clock 16-bit parallel  4 = DF1S : 4= 1-channel serial NOTE: 1-/2-/3-channel serial display interface supported is a low-voltage differential serial interface.  5 = DF2S : 5= 2-channel serial  6 = DF3S : 6= 3-channel serial  7 = DFSPI : 7= SPI serial  8 = DF1P3C24B : 8= 1-pixel/3-clock 24-bit parallel  9 = DF2P1C18B : 9= 2-pixel/1-clock 18-bit parallel */
        unsigned int undefined_bits_4_7:4;
        unsigned int disp_data_alignment:1; /* Display Data Alignment This is effective for parallel display data format and the associated Initialization Sequence (IS). 0= Output data is MSB-aligned For 1-pixel/1-clock parallel display the output data ordering is the same regardless of display Base Color Size.  For 1-pixel/1-clock parallel display data alignment is optimized for 18-bpp so the 24-bit data ordering is: LD[5:0] is blue data bits 7-2 LD[11:6] is green data bits 7-2 LD[17:12] is red data bits 7-2 LD[19:18] is blue data bits 1-0 LD[21:20] is green data bits 1-0 LD[23:22] is red data bits 1-0 Note that LD18 to LD23 signals are multiplexed with control pins (see Pin Output Select definition) 1= Output data is LSB-aligned.  For 1-pixel/1-clock parallel display the output data ordering is determined by display Base Color Size. For 1-pixel/1-clock parallel display data alignment is optimized for 24-bpp as follows: LD[7:0] is blue data bits 7-0 LD[15:8] is green data bits 7-0 LD[23:16] is red data bits
7-0 Note that LD18 to LD23 signals are multiplexed with control pins (see Pin Output Select definition) 0 = MSB 1 = LSB */
        unsigned int disp_data_order:1;     /* Display Data Order This is effective only for 1-pixel/2-clock 16-/18-/24- bit parallel interface 0= Red pixel is output in the first clock and blue pixel is output in the second cycle 1= Blue pixel is output in the first clock cycle and red pixel is output in the second clock cycle 0 = RED_BLUE 1 = BLUE_RED */
        unsigned int undefined_bits_10_31:22;
    };

    uint32_t reg32;
} disp_disp_interface_control_t;

#define DISP_DISP_COLOR_CONTROL_OFFSET 0x430
#define DISP_DISP_COLOR_CONTROL_RESET  0x00000000
typedef union disp_disp_color_control_u {
    struct {
        unsigned int base_color_size:4;     /* Display Base Color Size This parameter determines the number of bits per color after dither. 0= 6 bits 1= 1 bit 2= 2 bits 3= 3 bits 4= 4 bits 5= 5 bits 6= 5 bits for R,B and 6 bits for G 7= 3 bits for R,G and 2 bits for B 8= 8 bits, this also forces dither to be disabled. This setting can be used to output 24-bit data in 1-pixel/clock parallel display data format. 0 = BASE666 1 = BASE111 2 = BASE222 3 = BASE333 4 = BASE444 5 = BASE555 6 = BASE565 7 = BASE332 8 = BASE888 */
        unsigned int undefined_bits_4_7:4;
        unsigned int dither_control:2;      /* Dither Control 00= dither disabled 01= reserved 10= ordered dither 11= error-diffusion dither  Design Note: initial dither matrix (where d is 2 dither bits) d=00 d=01 d=10 d=11 --------- --------- --------- ---------  0  0   1  0   0  1   0  1  --------- --------- --------- ---------  0  0   0  0   1  0   1  1  --------- --------- --------- ---------  Note: 0 in the matrix specifies no addition to base color 1 in the matrix specifies incrementation of base color (with saturation) 0 = DISABLE 2 = ORDERED 3 = ERRDIFF */
        unsigned int undefined_bits_10_11:2;
        unsigned int ord_dither_rotation:2; /* Ordered Dither Frame Rotation This parameter specifies the rotation frequency of the dither matrix in terms of number of frames. If programmed to 0, there is no dither matrix rotation. If programmed to N where N is larger than 0, the dither matrix is rotated clockwise every N frame */
        unsigned int undefined_bits_14_15:2;
        unsigned int disp_color_swap:1;     /* Display Color Swap 0= RGB (normal) 1= BGR (red-blue reverse) 0 = RGB 1 = BGR */
        unsigned int blank_color:1;         /* Blank Color 0= zeros 1= ones Non Base Color applies to least significant color bits which are not part of base color and it has higher priority over Border Color but lower priority over Blank color */
        unsigned int non_base_color:1;      /* Non Base Color 0= zeros 1= ones MD0-3 signals are general purpose mode signals that can be output in various pins (see Pin Output Select) to configure the display device. These bits are effective at start of frame. Typically these can be programmed in shadow register which takes effect on the next frame */
        unsigned int undefined_bits_19_23:5;
        unsigned int lcd_md0:1;             /* LCD Mode 0 signal  0 = LOW 1 = HIGH */
        unsigned int lcd_md1:1;             /* LCD Mode 1 signal  0 = LOW 1 = HIGH */
        unsigned int lcd_md2:1;             /* LCD Mode 2 signal  0 = LOW 1 = HIGH */
        unsigned int lcd_md3:1;             /* LCD Mode 3 signal  0 = LOW 1 = HIGH */
        unsigned int undefined_bits_28_31:4;
    };

    uint32_t reg32;
} disp_disp_color_control_t;

#define DISP_SHIFT_CLOCK_OPTIONS_OFFSET 0x431
#define DISP_SHIFT_CLOCK_OPTIONS_RESET  0x00000000
typedef union disp_shift_clock_options_u {
    struct {
        unsigned int sc0_h_qualifier:3;     /* SC0 Horizontal Qualifier 0= disable (regardless of vertical qualifier) 1= no horizontal qualifier (V qualifier only) 2= horizontal display active 3= 1-clock early & extended H display active 4= H Pulse 0 (HP0) 5= 1-clock early & extended H Pulse 0 others= reserved 0 = DISABLE 1 = NO_HQUAL 2 = HACTIVE 3 = EXT_HACTIVE 4 = HPULSE0 5 = EXT_HPULSE0 */
        unsigned int sc0_v_qualifier:3;     /* SC0 Vertical Qualifier 0= no vertical qualifier 2= vertical display active 3= 1-line extended vertical display active 4= V Pulse 0 (VP0) 5= 1-line extended V Pulse 0 others= reserved If SC0 is divided by 2 or 4 then it is synchronously reset at the beginning of the horizontal qualifier such that rising edge of SC0 is generated for the first horizontally qualified 'pixel'. In the case where there is no horizontal qualifier start of horizontal display active will be used to generate the synchronous reset. If Initialization Sequence (IS) is enabled on parallel interface then only divide by 1 is allowed for SC0 Clock Divider and SC0 must have vertical and horizontal qualifiers enabled. 0 = NO_VQUAL 1 = RESERVED 2 = VACTIVE 3 = EXT_VACTIVE 4 = VPULSE0 5 = EXT_VPULSE0 */
        unsigned int sc0_clk_divider:2;     /* SC0 Clock Divider 0= divide by 1 - this is valid for all display interface 1= divide by 2 - this is valid only for 1-pixel/1-clock parallel display and 2-pixel/1-clock parallel display 2= divide by 4 - this is valid only for 1-pixel/1-clock parallel display 3= reserved 0 = DIV1 1 = DIV2 2 = DIV4 */
        unsigned int undefined_bits_8_15:8;
        unsigned int sc1_h_qualifier:3;     /* SC1 Horizontal Qualifier 0= disable (regardless of vertical qualifier) 1= no horizontal qualifier (V qualifier only) 2= horizontal display active 3= 1-clock early & extended H display active 4= H Pulse 1 (HP1) 5= 1-clock early & extended H Pulse 1 others= reserved 0 = DISABLE 1 = NO_HQUAL 2 = HACTIVE 3 = EXT_HACTIVE 4 = HPULSE1 5 = EXT_HPULSE1 */
        unsigned int sc1_v_qualifier:3;     /* SC1 Vertical Qualifier 0= no vertical qualifier 2= vertical display active 3= 1-line extended vertical display active 4= V Pulse 1 (VP1) 5= 1-line extended V Pulse 1 others= reserved If SC1 is divided by 2 then it is synchronously reset at the beginning of the horizontal qualifier such that rising edge of SC1 is generated for the first horizontally qualified 'pixel'. If SC1 is divided by 4 then it is synchronously reset at the beginning of the horizontal qualifier such that rising edge of LCD_WR_N is generated for the second horizontally qualified 'pixel'. In the case where there is no horizontal qualifier start of horizontal display active will be used to generate the synchronous reset. If Initialization Sequence (IS) is enabled on parallel interface then only divide by 1 is allowed for SC1 Clock Divider and SC1 must have vertical and horizontal qualifiers enabled. 0 = NO_VQUAL 1 = RESERVED 2 = VACTIVE 3 = EXT_VACTIVE 4 = VPULSE1 5 = EXT_VPULSE1 */
        unsigned int sc1_clk_divider:2;     /* SC1 Clock Divider 0= divide by 1 - this is valid for all display interface 1= divide by 2 - this is valid only for 1-pixel/1-clock parallel display and 2-pixel/1-clock parallel display 2= divide by 4 - this is valid only for 1-pixel/1-clock parallel display 3= reserved 0 = DIV1 1 = DIV2 2 = DIV4 */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_shift_clock_options_t;

#define DISP_DATA_ENABLE_OPTIONS_OFFSET 0x432
#define DISP_DATA_ENABLE_OPTIONS_RESET  0x00000000
typedef union disp_data_enable_options_u {
    struct {
        unsigned int de_select:2;           /* DE (Data Enable) vertical coverage control 0= DE is generated on every lines (active & blank) 1= DE is generated only for active lines 2= DE is generated for active lines and Initialization sequence (if IS is enabled). DE is also asserted in the time gap between the IS and the first active line. This bit also controls STH for serial display interface in the same manner. 0 = ACTIVE_BLANK 1 = ACTIVE 2 = ACTIVE_IS */
        unsigned int de_control:3;          /* DE (Data Enable) horizontal coverage control 0= 1-pixel clock pulse preceding active line (1-clock DE) 1= LDE active for horizontal display active time (normal DE) 2= LDE starts 1-pixel clock preceding active line but stays high on horizontal display active (early and extended DE) 3= 1-pixel clock early horizontal display active (early DE) 4= DE is active for the whole line, covering both active data and h blank (active and blank)  0 = ONECLK 1 = NORMAL 2 = EARLY_EXT 3 = EARLY 4 = ACTIVE_BLANK */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} disp_data_enable_options_t;

#define DISP_SERIAL_INTERFACE_OPTIONS_OFFSET 0x433
#define DISP_SERIAL_INTERFACE_OPTIONS_RESET  0x00000000
typedef union disp_serial_interface_options_u {
    struct {
        unsigned int sdt_stp_mode:2;        /* SDT and STP modes 0= SDT and STP disabled 1= reserved 2= SDT & STP enabled, duplicate data sent 3= SDT & STP enabled, duplicate data not sent 0 = DISABLE 1 = RESERVED 2 = ENABLE_DUP 3 = ENABLE */
        unsigned int sdt_stp_duration:4;    /* SDT and STP signal duration 0= 1 shift clock 1= 1 pixel clock 2= 1 pixel clock - 1 shift clock 3= 1 pixel clock - 2 shift clock 4= 1 pixel clock - 3 shift clock 5= 1 pixel clock - 4 shift clock : : : F= 1 pixel clock - 14 shift clock STP active duration is same as SDT if next pixel is not the same as current pixel; else, STP active duration is always 1 pixel clock. Maximum valid setting is pixel clock divider - 1 for pixel clock divider > 4. If pixel clock divider is 4 or less, SDT and STP is always low */
        unsigned int sth_duration:1;        /* STH signal duration 0= STH is high for 1 pixel clock in all cases except for 3-bit 2-channel and 6-bit 3-channel where STH is 1.5 pixel clock and for 3-bit 3-channel STH is 3 pixel clocks. 1= STH is high for 2 pixel clock in all cases except for 3-bit 3-channel STH is 4 pixel clocks. 0 = ONE_CLOCK 1 = TWO_CLOCK */
        unsigned int stp_control:1;         /* STP signal control 0= STP is not OR-ed with H Pulse 2 and vertical blank 1= STP is OR-ed with H Pulse 2 and vertical blank This may be set to 1 when STP needs to be forced high during blank time in which case H Pulse 2 should be programmed when STP needs to be forced high. Vertical blank is the area outside vertical display active. 0 = NORMAL 1 = EXTENDED */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} disp_serial_interface_options_t;

#define DISP_LCD_SPI_OPTIONS_OFFSET 0x434
#define DISP_LCD_SPI_OPTIONS_RESET  0x00000000
typedef union disp_lcd_spi_options_u {
    struct {
        unsigned int lcd_spi_cs:1;          /* LCD SPI Chip Select (SCS_) 0= Send LCD SPI data to Main Display (Main SCS_ is activated) 1= Send LCD SPI data to Sub Display (Sub SCS_ is activated) This bit is also used when SPI Chip Select Control are NOT LCD_IS_SPI to determine either Main SCS_ or Sub SCS_ to be forced active. 0 = MAIN 1 = SUB */
        unsigned int lcd_spi_dc:1;          /* LCD SPI Data/Command (SDC) 0= SPI Data/Command is low for LCD SPI writes to the display. For PCD6 data format, command byte is sent. 1= SPI Data/Command is high for LCD SPI writes to the display. For PCD6 data format, data byte is sent. 0 = LOW 1 = HIGH */
        unsigned int spi_cs_control:2;      /* LCD SPI Chip Select (SCS_) Control for both IS SPI or LCD SPI 0= Main SCS_ or Sub SCS_ is controlled by LCD SPI or by IS SPI 1= Main SCS_ or Sub SCS_ is controlled by LCD SPI, and depending on LCD SPI Chip Select bit, one of them is forced active for 1-line prior to display active when IS SPI is enabled 2= Main SCS_ or Sub SCS_ is controlled by IS SPI, and depending on LCD SPI Chip Select bit, one of them is forced active during vertical display active area when LCD SPI is enabled 3= Main SCS_ or Sub SCS_, depending on LCD SPI Chip Select bit, is forced active 1-line prior to display active when IS SPI is enabled and also during vertical display active area when LCD SPI is enabled 0 = LCD_IS_SPI 1 = LCD_SPI 2 = IS_SPI 3 = FORCED */
        unsigned int lcd_spi_direction:1;   /* LCD SPI Data Direction. Note that data direction does not affect the start byte direction (which is always msb to lsb) and position (always first 8-bit of serial data) for SPI16SB mode. 0 = MSB2LSB 1 = LSB2MSB */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} disp_lcd_spi_options_t;

#define DISP_BORDER_COLOR_OFFSET 0x435
#define DISP_BORDER_COLOR_RESET  0x00000000
typedef union disp_border_color_u {
    struct {
        unsigned int border_color_r:8;      /* Red Border Color */
        unsigned int border_color_g:8;      /* Green Border Color */
        unsigned int border_color_b:8;      /* Blue Border Color */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_border_color_t;

#define DISP_COLOR_KEY0_LOWER_OFFSET 0x436
#define DISP_COLOR_KEY0_LOWER_RESET  0x00000000
typedef union disp_color_key0_lower_u {
    struct {
        unsigned int color_key0_l_r:8;      /* Color Key 0 Red (V) Lower value */
        unsigned int color_key0_l_g:8;      /* Color Key 0 Green (Y) Lower value */
        unsigned int color_key0_l_b:8;      /* Color Key 0 Blue (U) Lower value */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_color_key0_lower_t;

#define DISP_COLOR_KEY0_UPPER_OFFSET 0x437
#define DISP_COLOR_KEY0_UPPER_RESET  0x00000000
typedef union disp_color_key0_upper_u {
    struct {
        unsigned int color_key0_u_r:8;      /* Color Key 0 Red (V) Upper value */
        unsigned int color_key0_u_g:8;      /* Color Key 0 Green (Y) Upper value */
        unsigned int color_key0_u_b:8;      /* Color Key 0 Blue (U) Upper value */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_color_key0_upper_t;

#define DISP_COLOR_KEY1_LOWER_OFFSET 0x438
#define DISP_COLOR_KEY1_LOWER_RESET  0x00000000
typedef union disp_color_key1_lower_u {
    struct {
        unsigned int color_key1_l_r:8;      /* Color Key 1 Red (V) Lower value */
        unsigned int color_key1_l_g:8;      /* Color Key 1 Green (Y) Lower value */
        unsigned int color_key1_l_b:8;      /* Color Key 1 Blue (U) Lower value */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_color_key1_lower_t;

#define DISP_COLOR_KEY1_UPPER_OFFSET 0x439
#define DISP_COLOR_KEY1_UPPER_RESET  0x00000000
typedef union disp_color_key1_upper_u {
    struct {
        unsigned int color_key1_u_r:8;      /* Color Key 1 Red (V) Upper value */
        unsigned int color_key1_u_g:8;      /* Color Key 1 Green (Y) Upper value */
        unsigned int color_key1_u_b:8;      /* Color Key 1 Blue (U) Upper value */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_color_key1_upper_t;

#define DISP_CURSOR_FOREGROUND_OFFSET 0x43C
#define DISP_CURSOR_FOREGROUND_RESET  0x00000000
typedef union disp_cursor_foreground_u {
    struct {
        unsigned int cursor_foreground_r:8; /* Cursor Red Foreground Color */
        unsigned int cursor_foreground_g:8; /* Cursor Green Foreground Color */
        unsigned int cursor_foreground_b:8; /* Cursor Blue Foreground Color */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_cursor_foreground_t;

#define DISP_CURSOR_BACKGROUND_OFFSET 0x43D
#define DISP_CURSOR_BACKGROUND_RESET  0x00000000
typedef union disp_cursor_background_u {
    struct {
        unsigned int cursor_background_r:8; /* Cursor Red Background Color */
        unsigned int cursor_background_g:8; /* Cursor Green Background Color */
        unsigned int cursor_background_b:8; /* Cursor Blue Background Color */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} disp_cursor_background_t;

#define DISP_CURSOR_START_ADDR_OFFSET 0x43E
#define DISP_CURSOR_START_ADDR_RESET  0x00000000
typedef union disp_cursor_start_addr_u {
    struct {
        unsigned int cursor_start_addr:22;  /* Cursor Start Address bits 25:10 */
        unsigned int undefined_bits_22_23:2;
        unsigned int cursor_size:1;         /* Cursor Size 0= 32x32 1= 64x64 0 = C32X32 1 = C64X64 */
        unsigned int undefined_bits_25_27:3;
        unsigned int cursor_clipping:2;     /* Cursor Clipping Select 0 = DISPLAY : 00= display  1 = WA : 01= window A  2 = WB : 10= window B  3 = WC : 11= window C */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} disp_cursor_start_addr_t;

#define DISP_CURSOR_START_ADDR_NS_OFFSET 0x43F
#define DISP_CURSOR_START_ADDR_NS_RESET  0x00000000
typedef union disp_cursor_start_addr_ns_u {
    struct {
        unsigned int cursor_start_addr_ns:22;/* Cursor Start Address bits 25:10 */
        unsigned int undefined_bits_22_23:2;
        unsigned int cursor_size_ns:1;      /* Cursor Size 0= 32x32 1= 64x64 0 = C32X32 1 = C64X64 */
        unsigned int undefined_bits_25_27:3;
        unsigned int cursor_clipping_ns:2;  /* Cursor Clipping Select 0 = DISPLAY : 00= display  1 = WA : 01= window A  2 = WB : 10= window B  3 = WC : 11= window C */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} disp_cursor_start_addr_ns_t;

#define DISP_CURSOR_POSITION_OFFSET 0x440
#define DISP_CURSOR_POSITION_RESET  0x00000000
typedef union disp_cursor_position_u {
    struct {
        unsigned int h_cursor_position:14;  /* H cursor position (signed) */
        unsigned int undefined_bits_14_15:2;
        unsigned int v_cursor_position:14;  /* V cursor position (signed) */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} disp_cursor_position_t;

#define DISP_CURSOR_POSITION_NS_OFFSET 0x441
#define DISP_CURSOR_POSITION_NS_RESET  0x00000000
typedef union disp_cursor_position_ns_u {
    struct {
        unsigned int h_cursor_position_ns:14;/* H cursor position (signed) */
        unsigned int undefined_bits_14_15:2;
        unsigned int v_cursor_position_ns:14;/* V cursor position (signed) */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} disp_cursor_position_ns_t;

#define DISP_INIT_SEQ_CONTROL_OFFSET 0x442
#define DISP_INIT_SEQ_CONTROL_RESET  0x00000000
typedef union disp_init_seq_control_u {
    struct {
        unsigned int send_init_sequence:1;  /* Send Initialization Sequence (IS)  0 = DISABLE 1 = ENABLE */
        unsigned int init_sequence_mode:1;  /* Initialization Sequence Mode 0= Send init sequence through parallel LCD interface 1= Send init sequence through SPI serial interface 0 = PLCD_INIT 1 = SPI_INIT */
        unsigned int undefined_bits_2_3:2;
        unsigned int init_seq_dc_signal:3;  /* Frame Initialization Sequence DC Pin This parameter is used only for parallel initialization sequence and it specifies which signal carries the data/command signal. 0= parallel IS DC signal is not needed 1= parallel IS DC on Vertical Sync 2= parallel IS DC on Vertical Pulse 0 3= parallel IS DC on Vertical Pulse 1 4= parallel IS DC on Vertical Pulse 2 5= parallel IS DC on Vertical Pulse 3 other= reserved 0 = NODC 1 = VSYNC 2 = VPULSE0 3 = VPULSE1 4 = VPULSE2 5 = VPULSE3 */
        unsigned int init_seq_dc_control:1; /* Initialization Sequence DC Pin This bit is used only for parallel initialization sequence and it controls how data/command is added to the vertical signal selected by -=PS_=-INIT_SEQ_DC_SIGNAL 0= parallel IS DC is inverted and then AND-ed to the vertical signal 1= parallel IS DC is OR-ed to the vertical signal */
        unsigned int frame_init_seq_cycles:4;/* Frame Initialization Sequence Cycles This parameter specifies the number of frame initialization sequence cycles to send. If programmed to 0, there is no frame initialization cycle generated */
        unsigned int undefined_bits_12_31:20;
    };

    uint32_t reg32;
} disp_init_seq_control_t;

#define DISP_SPI_INIT_SEQ_DATA_A_OFFSET 0x443
#define DISP_SPI_INIT_SEQ_DATA_A_RESET  0x00000000
typedef union disp_spi_init_seq_data_a_u {
    struct {
        unsigned int spi_init_seq_data_a:32;/* SPI Init Sequence Write Data bits 31-0 */
    };

    uint32_t reg32;
} disp_spi_init_seq_data_a_t;

#define DISP_SPI_INIT_SEQ_DATA_B_OFFSET 0x444
#define DISP_SPI_INIT_SEQ_DATA_B_RESET  0x00000000
typedef union disp_spi_init_seq_data_b_u {
    struct {
        unsigned int spi_init_seq_data_b:32;/* SPI Init Sequence Write Data bits 63-32 */
    };

    uint32_t reg32;
} disp_spi_init_seq_data_b_t;

#define DISP_SPI_INIT_SEQ_DATA_C_OFFSET 0x445
#define DISP_SPI_INIT_SEQ_DATA_C_RESET  0x00000000
typedef union disp_spi_init_seq_data_c_u {
    struct {
        unsigned int spi_init_seq_data_c:32;/* SPI Init Sequence Write Data bits 95-64 */
    };

    uint32_t reg32;
} disp_spi_init_seq_data_c_t;

#define DISP_SPI_INIT_SEQ_DATA_D_OFFSET 0x446
#define DISP_SPI_INIT_SEQ_DATA_D_RESET  0x00000000
typedef union disp_spi_init_seq_data_d_u {
    struct {
        unsigned int spi_init_seq_data_d:32;/* SPI Init Sequence Write Data bits 127-96 */
    };

    uint32_t reg32;
} disp_spi_init_seq_data_d_t;

#define DISP_DC_MCCIF_FIFOCTRL_OFFSET 0x480
#define DISP_DC_MCCIF_FIFOCTRL_RESET  0x00000000
typedef union disp_dc_mccif_fifoctrl_u {
    struct {
        unsigned int dc_mccif_wrcl_mcle2x:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int dc_mccif_rdmc_rdfast:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int dc_mccif_wrmc_clle2x:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int dc_mccif_rdcl_rdfast:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} disp_dc_mccif_fifoctrl_t;

#define DISP_MCCIF_DISPLAY0A_HYST_OFFSET 0x481
#define DISP_MCCIF_DISPLAY0A_HYST_RESET  0xCF401F1F
typedef union disp_mccif_display0a_hyst_u {
    struct {
        unsigned int cbr_display0a2mc_hyst_req_tm:8;
        unsigned int cbr_display0a2mc_dhyst_tm:8;
        unsigned int cbr_display0a2mc_dhyst_th:8;
        unsigned int cbr_display0a2mc_hyst_tm:4;
        unsigned int cbr_display0a2mc_hyst_req_th:3;
        unsigned int cbr_display0a2mc_hyst_en:1;/* 1 = ENABLE 0 = DISABLE */
    };

    uint32_t reg32;
} disp_mccif_display0a_hyst_t;

#define DISP_MCCIF_DISPLAY0B_HYST_OFFSET 0x482
#define DISP_MCCIF_DISPLAY0B_HYST_RESET  0xCF081F1F
typedef union disp_mccif_display0b_hyst_u {
    struct {
        unsigned int cbr_display0b2mc_hyst_req_tm:8;
        unsigned int cbr_display0b2mc_dhyst_tm:8;
        unsigned int cbr_display0b2mc_dhyst_th:8;
        unsigned int cbr_display0b2mc_hyst_tm:4;
        unsigned int cbr_display0b2mc_hyst_req_th:3;
        unsigned int cbr_display0b2mc_hyst_en:1;/* 1 = ENABLE 0 = DISABLE */
    };

    uint32_t reg32;
} disp_mccif_display0b_hyst_t;

#define DISP_MCCIF_DISPLAY0C_HYST_OFFSET 0x483
#define DISP_MCCIF_DISPLAY0C_HYST_RESET  0xCF081F1F
typedef union disp_mccif_display0c_hyst_u {
    struct {
        unsigned int cbr_display0c2mc_hyst_req_tm:8;
        unsigned int cbr_display0c2mc_dhyst_tm:8;
        unsigned int cbr_display0c2mc_dhyst_th:8;
        unsigned int cbr_display0c2mc_hyst_tm:4;
        unsigned int cbr_display0c2mc_hyst_req_th:3;
        unsigned int cbr_display0c2mc_hyst_en:1;/* 1 = ENABLE 0 = DISABLE */
    };

    uint32_t reg32;
} disp_mccif_display0c_hyst_t;

#define DISP_MCCIF_DISPLAY1B_HYST_OFFSET 0x484
#define DISP_MCCIF_DISPLAY1B_HYST_RESET  0xCF081F1F
typedef union disp_mccif_display1b_hyst_u {
    struct {
        unsigned int cbr_display1b2mc_hyst_req_tm:8;
        unsigned int cbr_display1b2mc_dhyst_tm:8;
        unsigned int cbr_display1b2mc_dhyst_th:8;
        unsigned int cbr_display1b2mc_hyst_tm:4;
        unsigned int cbr_display1b2mc_hyst_req_th:3;
        unsigned int cbr_display1b2mc_hyst_en:1;/* 1 = ENABLE 0 = DISABLE */
    };

    uint32_t reg32;
} disp_mccif_display1b_hyst_t;

#define DISP_DAC_CRT_CTRL_OFFSET 0x4C0
#define DISP_DAC_CRT_CTRL_RESET  0x00000000
typedef union disp_dac_crt_ctrl_u {
    struct {
        unsigned int override_notblank:1;   /* If enabled, output display2tvdac_NOTBLANK is tied to 1 0= disable 1= enable 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bit_1:1;
        unsigned int sync_select:1;         /* Selects the source for display2tvdac_[hv]sync 0 = VSYNC_HSYNC 1 = LVP0_LHP0 */
        unsigned int undefined_bit_3:1;
        unsigned int notblank_select:1;     /* Selects the source for display2tvdac_notblank 0: notblank = d_active[10] (i.e. data_enable) 1: notblank = (lvp[1] & lhp[1]) 0 = DE 1 = LVP1_LHP1 */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} disp_dac_crt_ctrl_t;

#define DISP_DISP_MISC_CONTROL_OFFSET 0x4C1
#define DISP_DISP_MISC_CONTROL_RESET  0x00000002
typedef union disp_disp_misc_control_u {
    struct {
        unsigned int phase_shift_2p1c18b:1; /* Enable phase shift for 2P1C format phase shift SC0/SC1 will be delayed for one pixel clock cycle. In 2P1C format, data will hold for 2 pixel clocks, so either choice should work 0 = DISABLE 1 = ENABLE */
        unsigned int uf_line_flush:1;       /* Enable underflow line flush, a.o.t end-of-frame flush. underflow line flush  0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} disp_disp_misc_control_t;

typedef struct dc_regs {
    DEFINE_REG32(cmd_cont_syncpt_vsync);
    DEFINE_REG32(cmd_ctxsw);
    DEFINE_REG32(cmd_display_command_option0);
    DEFINE_REG32(cmd_display_command);
    DEFINE_REG32(cmd_signal_raise);
    DEFINE_REG32(cmd_display_power_control);
    DEFINE_REG32(cmd_int_status);
    DEFINE_REG32(cmd_int_mask);
    DEFINE_REG32(cmd_int_enable);
    DEFINE_REG32(cmd_int_type);
    DEFINE_REG32(cmd_int_polarity);
    DEFINE_REG32(cmd_signal_raise1);
    DEFINE_REG32(cmd_signal_raise2);
    DEFINE_REG32(cmd_signal_raise3);
    DEFINE_REG32(cmd_state_access);
    DEFINE_REG32(cmd_state_control);
    DEFINE_REG32(cmd_display_window_header);
    DEFINE_REG32(cmd_reg_act_control);
    DEFINE_REG32(com_crc_control);
    DEFINE_REG32(com_crc_checksum);
    DEFINE_REG32(com_pin_output_enable0);
    DEFINE_REG32(com_pin_output_enable1);
    DEFINE_REG32(com_pin_output_enable2);
    DEFINE_REG32(com_pin_output_enable3);
    DEFINE_REG32(com_pin_output_polarity0);
    DEFINE_REG32(com_pin_output_polarity1);
    DEFINE_REG32(com_pin_output_polarity2);
    DEFINE_REG32(com_pin_output_polarity3);
    DEFINE_REG32(com_pin_output_data0);
    DEFINE_REG32(com_pin_output_data1);
    DEFINE_REG32(com_pin_output_data2);
    DEFINE_REG32(com_pin_output_data3);
    DEFINE_REG32(com_pin_input_enable0);
    DEFINE_REG32(com_pin_input_enable1);
    DEFINE_REG32(com_pin_input_enable2);
    DEFINE_REG32(com_pin_input_enable3);
    DEFINE_REG32(com_pin_input_data0);
    DEFINE_REG32(com_pin_input_data1);
    DEFINE_REG32(com_pin_output_select0);
    DEFINE_REG32(com_pin_output_select1);
    DEFINE_REG32(com_pin_output_select2);
    DEFINE_REG32(com_pin_output_select3);
    DEFINE_REG32(com_pin_output_select4);
    DEFINE_REG32(com_pin_output_select5);
    DEFINE_REG32(com_pin_output_select6);
    DEFINE_REG32(com_pin_misc_control);
    DEFINE_REG32(com_pm0_control);
    DEFINE_REG32(com_pm0_duty_cycle);
    DEFINE_REG32(com_pm1_control);
    DEFINE_REG32(com_pm1_duty_cycle);
    DEFINE_REG32(com_spi_control);
    DEFINE_REG32(com_spi_start_byte);
    DEFINE_REG32(com_hspi_write_data_ab);
    DEFINE_REG32(com_hspi_write_data_cd);
    DEFINE_REG32(com_hspi_cs_dc);
    DEFINE_REG32(com_scratch_register_a);
    DEFINE_REG32(com_scratch_register_b);
    DEFINE_REG32(com_gpio_ctrl);
    DEFINE_REG32(com_gpio_debounce_counter);
    DEFINE_REG32(com_crc_checksum_latched);
    DEFINE_REG32(disp_disp_signal_options0);
    DEFINE_REG32(disp_disp_signal_options1);
    DEFINE_REG32(disp_disp_win_options);
    DEFINE_REG32(disp_mem_high_priority);
    DEFINE_REG32(disp_mem_high_priority_timer);
    DEFINE_REG32(disp_disp_timing_options);
    DEFINE_REG32(disp_ref_to_sync);
    DEFINE_REG32(disp_sync_width);
    DEFINE_REG32(disp_back_porch);
    DEFINE_REG32(disp_disp_active);
    DEFINE_REG32(disp_front_porch);
    DEFINE_REG32(disp_h_pulse0_control);
    DEFINE_REG32(disp_h_pulse0_position_a);
    DEFINE_REG32(disp_h_pulse0_position_b);
    DEFINE_REG32(disp_h_pulse0_position_c);
    DEFINE_REG32(disp_h_pulse0_position_d);
    DEFINE_REG32(disp_h_pulse1_control);
    DEFINE_REG32(disp_h_pulse1_position_a);
    DEFINE_REG32(disp_h_pulse1_position_b);
    DEFINE_REG32(disp_h_pulse1_position_c);
    DEFINE_REG32(disp_h_pulse1_position_d);
    DEFINE_REG32(disp_h_pulse2_control);
    DEFINE_REG32(disp_h_pulse2_position_a);
    DEFINE_REG32(disp_h_pulse2_position_b);
    DEFINE_REG32(disp_h_pulse2_position_c);
    DEFINE_REG32(disp_h_pulse2_position_d);
    DEFINE_REG32(disp_v_pulse0_control);
    DEFINE_REG32(disp_v_pulse0_position_a);
    DEFINE_REG32(disp_v_pulse0_position_b);
    DEFINE_REG32(disp_v_pulse0_position_c);
    DEFINE_REG32(disp_v_pulse1_control);
    DEFINE_REG32(disp_v_pulse1_position_a);
    DEFINE_REG32(disp_v_pulse1_position_b);
    DEFINE_REG32(disp_v_pulse1_position_c);
    DEFINE_REG32(disp_v_pulse2_control);
    DEFINE_REG32(disp_v_pulse2_position_a);
    DEFINE_REG32(disp_v_pulse3_control);
    DEFINE_REG32(disp_v_pulse3_position_a);
    DEFINE_REG32(disp_m0_control);
    DEFINE_REG32(disp_m1_control);
    DEFINE_REG32(disp_di_control);
    DEFINE_REG32(disp_pp_control);
    DEFINE_REG32(disp_pp_select_a);
    DEFINE_REG32(disp_pp_select_b);
    DEFINE_REG32(disp_pp_select_c);
    DEFINE_REG32(disp_pp_select_d);
    DEFINE_REG32(disp_disp_clock_control);
    DEFINE_REG32(disp_disp_interface_control);
    DEFINE_REG32(disp_disp_color_control);
    DEFINE_REG32(disp_shift_clock_options);
    DEFINE_REG32(disp_data_enable_options);
    DEFINE_REG32(disp_serial_interface_options);
    DEFINE_REG32(disp_lcd_spi_options);
    DEFINE_REG32(disp_border_color);
    DEFINE_REG32(disp_color_key0_lower);
    DEFINE_REG32(disp_color_key0_upper);
    DEFINE_REG32(disp_color_key1_lower);
    DEFINE_REG32(disp_color_key1_upper);
    DEFINE_REG32(disp_cursor_foreground);
    DEFINE_REG32(disp_cursor_background);
    DEFINE_REG32(disp_cursor_start_addr);
    DEFINE_REG32(disp_cursor_start_addr_ns);
    DEFINE_REG32(disp_cursor_position);
    DEFINE_REG32(disp_cursor_position_ns);
    DEFINE_REG32(disp_init_seq_control);
    DEFINE_REG32(disp_spi_init_seq_data_a);
    DEFINE_REG32(disp_spi_init_seq_data_b);
    DEFINE_REG32(disp_spi_init_seq_data_c);
    DEFINE_REG32(disp_spi_init_seq_data_d);
    DEFINE_REG32(disp_dc_mccif_fifoctrl);
    DEFINE_REG32(disp_mccif_display0a_hyst);
    DEFINE_REG32(disp_mccif_display0b_hyst);
    DEFINE_REG32(disp_mccif_display0c_hyst);
    DEFINE_REG32(disp_mccif_display1b_hyst);
    DEFINE_REG32(disp_dac_crt_ctrl);
    DEFINE_REG32(disp_disp_misc_control);
} dc_regs;

extern regs_io_handler dc_handler;

#endif // TEGRA_DC_H
