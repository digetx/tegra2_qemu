/*
 * ARM NVIDIA Tegra2 emulation.
 *
 * Copyright (c) 2014-2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* Autogenerated from TRM v02p */

#ifndef NV_CLASS_HOST_H
#define NV_CLASS_HOST_H

#define UPDATE      0
#define NO_UPDATE   1

#define REG 0
#define FB  1

#define WRITE   0
#define READ    1

#define HOST1X      0
#define MPE         1
#define VI          2
#define EPP         3
#define ISP         4
#define GR2D        5
#define GR3D        6
#define DISPLAY     8
#define DISPLAYB    9
#define HDMI        10
#define TVO         11
#define DSI         12

static inline uint8_t decode_class_id(uint32_t module_id)
{
    switch (module_id) {
        case HOST1X:
            return 0x01;
        case MPE:
            return 0x20;
        case VI:
            return 0x30;
        case EPP:
            return 0x31;
        case ISP:
            return 0x32;
        case GR2D:
            return 0x51;
        case GR3D:
            return 0x60;
        case DISPLAY:
            return 0x70;
        case DISPLAYB:
            return 0x71;
        case HDMI:
            return 0x77;
        case TVO:
            return 0x78;
        case DSI:
            return 0x79;
        default:
            g_assert_not_reached();
    }
}

#define NV_CLASS_HOST_INCR_SYNCPT_OFFSET 0x0
#define NV_CLASS_HOST_INCR_SYNCPT_RESET  0x00000000
typedef union nv_class_host_incr_syncpt_u {
    struct {
        unsigned int indx:8;                /* syncpt index value */
        unsigned int cond:8;                /* Condition mapped from raise/wait 0 = IMMEDIATE 1 = OP_DONE 2 = RD_DONE 3 = REG_WR_SAFE 4 = COND_4 5 = COND_5 6 = COND_6 7 = COND_7 8 = COND_8 9 = COND_9 10 = COND_10 11 = COND_11 12 = COND_12 13 = COND_13 14 = COND_14 15 = COND_15 */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} nv_class_host_incr_syncpt;

#define NV_CLASS_HOST_INCR_SYNCPT_CNTRL_OFFSET 0x1
#define NV_CLASS_HOST_INCR_SYNCPT_CNTRL_RESET  0x00000000
typedef union nv_class_host_incr_syncpt_cntrl_u {
    struct {
        unsigned int incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs */
        unsigned int undefined_bits_1_7:7;
        unsigned int incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when FIFOs are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when FIFOs are full, the client host interface will be stalled */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} nv_class_host_incr_syncpt_cntrl;

#define NV_CLASS_HOST_INCR_SYNCPT_ERROR_OFFSET 0x2
#define NV_CLASS_HOST_INCR_SYNCPT_ERROR_RESET  0x00000000
typedef union nv_class_host_incr_syncpt_error_u {
    struct {
        unsigned int cond_status:32;        /* COND_STATUS[COND] is set if the FIFO for COND overflows. This bit is sticky and will remain set until cleared. Cleared by writing 1 */
    };

    uint32_t reg32;
} nv_class_host_incr_syncpt_error;

#define NV_CLASS_HOST_WAIT_SYNCPT_OFFSET 0x8
#define NV_CLASS_HOST_WAIT_SYNCPT_RESET  0x00000000
typedef union nv_class_host_wait_syncpt_u {
    struct {
        unsigned int thresh:24;
        unsigned int indx:8;
    };

    uint32_t reg32;
} nv_class_host_wait_syncpt;

#define NV_CLASS_HOST_WAIT_SYNCPT_BASE_OFFSET 0x9
#define NV_CLASS_HOST_WAIT_SYNCPT_BASE_RESET  0x00000000
typedef union nv_class_host_wait_syncpt_base_u {
    struct {
        unsigned int offset:16;
        unsigned int base_indx:8;
        unsigned int indx:8;
    };

    uint32_t reg32;
} nv_class_host_wait_syncpt_base;

#define NV_CLASS_HOST_WAIT_SYNCPT_INCR_OFFSET 0xA
#define NV_CLASS_HOST_WAIT_SYNCPT_INCR_RESET  0x00000000
typedef union nv_class_host_wait_syncpt_incr_u {
    struct {
        unsigned int undefined_bits_0_23:24;
        unsigned int indx:8;
    };

    uint32_t reg32;
} nv_class_host_wait_syncpt_incr;

#define NV_CLASS_HOST_LOAD_SYNCPT_BASE_OFFSET 0xB
#define NV_CLASS_HOST_LOAD_SYNCPT_BASE_RESET  0x00000000
typedef union nv_class_host_load_syncpt_base_u {
    struct {
        unsigned int value:24;
        unsigned int base_indx:8;
    };

    uint32_t reg32;
} nv_class_host_load_syncpt_base;

#define NV_CLASS_HOST_INCR_SYNCPT_BASE_OFFSET 0xC
#define NV_CLASS_HOST_INCR_SYNCPT_BASE_RESET  0x00000000
typedef union nv_class_host_incr_syncpt_base_u {
    struct {
        unsigned int offset:24;
        unsigned int base_indx:8;
    };

    uint32_t reg32;
} nv_class_host_incr_syncpt_base;

#define NV_CLASS_HOST_DELAY_USEC_OFFSET 0x10
#define NV_CLASS_HOST_DELAY_USEC_RESET  0x00000000
typedef union nv_class_host_delay_usec_u {
    struct {
        unsigned int nusec:20;              /* Enough for 1.05 seconds */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} nv_class_host_delay_usec;

#define NV_CLASS_HOST_TICKCOUNT_HI_OFFSET 0x11
#define NV_CLASS_HOST_TICKCOUNT_HI_RESET  0x00000000
typedef union nv_class_host_tickcount_hi_u {
    struct {
        unsigned int ticks_hi:32;           /* read or write tick count */
    };

    uint32_t reg32;
} nv_class_host_tickcount_hi;

#define NV_CLASS_HOST_TICKCOUNT_LO_OFFSET 0x12
#define NV_CLASS_HOST_TICKCOUNT_LO_RESET  0x00000000
typedef union nv_class_host_tickcount_lo_u {
    struct {
        unsigned int ticks_lo:32;           /* read or write tick count */
    };

    uint32_t reg32;
} nv_class_host_tickcount_lo;

#define NV_CLASS_HOST_TICKCTRL_OFFSET 0x13
#define NV_CLASS_HOST_TICKCTRL_RESET  0x00000000
typedef union nv_class_host_tickctrl_u {
    struct {
        unsigned int tickcnt_enable:1;      /* Enable or Disable tick counter 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_1_31:31;
    };

    uint32_t reg32;
} nv_class_host_tickctrl;

#define NV_CLASS_HOST_INDCTRL_OFFSET 0x2B
#define NV_CLASS_HOST_INDCTRL_RESET  0x00000000
typedef union nv_class_host_indctrl_u {
    struct {
        unsigned int rwn:1;                 /* Read/write 0 = WRITE 1 = READ */
        unsigned int acctype:1;             /* Access type: indirect register or indirect framebuffer 0 = REG 1 = FB */
        unsigned int undefined_bits_2_25:24;
        unsigned int spool:1;               /* Route return data to spool FIFO, only applicable to reads 0 = DISABLE 1 = ENABLE */
        unsigned int autoinc:1;             /* Auto increment of read/write address 0 = DISABLE 1 = ENABLE */
        unsigned int indbe1:1;              /* Byte enables. Will apply to all subsequent data transactions. Not applicable for reads */
        unsigned int indbe2:1;
        unsigned int indbe3:1;
        unsigned int indbe4:1;
    };

    uint32_t reg32;
} nv_class_host_indctrl;

#define NV_CLASS_HOST_INDOFF2_OFFSET 0x2C
#define NV_CLASS_HOST_INDOFF2_RESET  0x00000000
typedef union nv_class_host_indoff2_reg_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int indfboffset:30;        /* ACCTYPE=FB: framebuffer address */
    };

    struct {
        unsigned int undefined_bitsx_0_1:2;
        unsigned int indroffset:16;         /* ACCTYPE=REG: register offset ([15:0]) */
        unsigned int indmodid:8;            /* ACCTYPE=REG: register module ID 0 = HOST1X 1 = MPE 2 = VI 3 = EPP 4 = ISP 5 = GR2D 6 = GR3D 8 = DISPLAY 11 = TVO 9 = DISPLAYB 12 = DSI 10 = HDMI */
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} nv_class_host_indoff2_reg;

#define NV_CLASS_HOST_INDOFF_OFFSET 0x2D
#define NV_CLASS_HOST_INDOFF_RESET  0x00000000
typedef union nv_class_host_indoff_reg_u {
    struct {
        unsigned int rwn:1;                 /* Read/write 0 = WRITE 1 = READ */
        unsigned int acctype:1;             /* Access type: indirect register or indirect framebuffer 0 = REG 1 = FB */
        unsigned int indfboffset:24;        /* ACCTYPE=FB: framebuffer address */
        unsigned int spool:1;               /* Route return data to spool FIFO, only applicable to reads 0 = DISABLE 1 = ENABLE */
        unsigned int autoinc:1;             /* Auto increment of read/write address 0 = DISABLE 1 = ENABLE */
        unsigned int indbe:4;               /* Byte enables. Will apply to all subsequent data transactions. Not applicable for reads */
    };

    struct {
        unsigned int bits_0_1:2;
        unsigned int indroffset:16;         /* ACCTYPE=REG: register offset ([15:0]) */
        unsigned int indmodid:8;            /* ACCTYPE=REG: register module ID 0 = HOST1X 1 = MPE 2 = VI 3 = EPP 4 = ISP 5 = GR2D 6 = GR3D 8 = DISPLAY 11 = TVO 9 = DISPLAYB 12 = DSI 10 = HDMI */
        unsigned int bits_26_31:6;
    };

    uint32_t reg32;
} nv_class_host_indoff_reg;

#define NV_CLASS_HOST_INDDATA_OFFSET_BEGIN 0x2E
#define NV_CLASS_HOST_INDDATA_OFFSET_END   0x4C

struct host1x_regs {
    nv_class_host_indctrl indctrl;
    uint32_t indoffset;
    uint8_t class_id;
};

struct host1x_module;

void host1x_write(struct host1x_module *module, uint32_t offset, uint32_t data);
uint32_t host1x_read(struct host1x_module *module, uint32_t offset);

#endif // NV_CLASS_HOST_H
