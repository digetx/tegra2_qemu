/*
 * ARM NVIDIA Tegra2 emulation.
 *
 * Copyright (c) 2014-2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* Autogenerated from TRM v02p */

#ifndef TEGRA_GR2D_H
#define TEGRA_GR2D_H

#include "host1x_module.h"

#undef DEFINE_REG32
#define DEFINE_REG32(reg) reg reg

#define G2SB_INCR_SYNCPT_OFFSET 0x0
#define G2SB_INCR_SYNCPT_RESET  0x00000000
typedef union g2sb_incr_syncpt_u {
    struct {
        unsigned int indx:8;                /* syncpt index value */
        unsigned int cond:8;                /* Condition mapped from raise/wait */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} g2sb_incr_syncpt;

#define G2SB_INCR_SYNCPT_CNTRL_OFFSET 0x1
#define G2SB_INCR_SYNCPT_CNTRL_RESET  0x00000000
typedef union g2sb_incr_syncpt_cntrl_u {
    struct {
        unsigned int incr_syncpt_soft_reset:1;/* If SOFT_RESET is set, then all internal state of the client syncpt block will be reset. To do soft reset, first set SOFT_RESET of all host1x clients affected, then clear all SOFT_RESETs. */
        unsigned int undefined_bits_1_7:7;
        unsigned int incr_syncpt_no_stall:1;/* If NO_STALL is 1, then when fifos are full, INCR_SYNCPT methods will be dropped and the INCR_SYNCPT_ERROR[COND] bit will be set. If NO_STALL is 0, then when fifos are full, the client host interface will be stalled. */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} g2sb_incr_syncpt_cntrl;

#define G2SB_INCR_SYNCPT_ERROR_OFFSET 0x2
#define G2SB_INCR_SYNCPT_ERROR_RESET  0x00000000
typedef union g2sb_incr_syncpt_error_u {
    struct {
        unsigned int cond_status:32;        /* COND_STATUS[COND] is set if the fifo for COND overflows This bit is sticky and will remain set until overwritten with a zero */
    };

    uint32_t reg32;
} g2sb_incr_syncpt_error;

#define G2SB_G2CLASSCHANNEL_REGONLY_OFFSET 0x8
#define G2SB_G2CLASSCHANNEL_REGONLY_RESET  0x00000000
#define G2SB_G2CLASSCHANNEL_REGONLY_WRMASK 0xFFFFFC00
typedef union g2sb_g2classchannel_regonly_u {
    struct {
        unsigned int curr_class:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int curr_channel:4;
        unsigned int ctx_valid:1;
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} g2sb_g2classchannel_regonly;

#define G2SB_G2TRIGGER_OFFSET 0x9
#define G2SB_G2TRIGGER_RESET  0x00000000
typedef union g2sb_g2trigger_u {
    struct {
        unsigned int trigger:16;
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} g2sb_g2trigger;

#define G2SB_G2TRIGGER1_OFFSET 0xA
#define G2SB_G2TRIGGER1_RESET  0x00000000
typedef union g2sb_g2trigger1_u {
    struct {
        unsigned int trigger1:16;
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} g2sb_g2trigger1;

#define G2SB_G2TRIGGER2_OFFSET 0xB
#define G2SB_G2TRIGGER2_RESET  0x00000000
typedef union g2sb_g2trigger2_u {
    struct {
        unsigned int trigger2:16;
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} g2sb_g2trigger2;

#define G2SB_G2CMDSEL_OFFSET 0xC
#define G2SB_G2CMDSEL_RESET  0x00000000
#define G2SB_G2CMDSEL_WRMASK 0xFFFFFFFE
typedef union g2sb_g2cmdsel_u {
    struct {
        unsigned int sbor2d:1;
        unsigned int undefined_bits_1_3:3;
        unsigned int cbenable:1;            /* circular buffer feature enable    0= disable */
        unsigned int vitrigger:1;           /* VI trigger enable, can be circular buffer or full frame */
        unsigned int hosttrigger:1;         /* host trigger the command, host also need program cicular buffer related data */
        unsigned int cbsbdisable:1;
        unsigned int g2output:2;            /* 00: to memory 01: to EPP */
        unsigned int clip_source_top_bottom:1;/* Reserved for HW Test, SW should not use this bit. */
        unsigned int undefined_bit_11:1;
        unsigned int link_wait_buf_end:1;
        unsigned int undefined_bit_13:1;
        unsigned int frame_start:1;         /* host writes this bit to tell which buffer is ready */
        unsigned int frame_end:1;
        unsigned int buffer_index:8;
        unsigned int linken:1;              /* Test purpose */
        unsigned int linkval:3;
        unsigned int priority:1;            /* indicates priority of the context, note vi-triggered contexts take priority over HIGH */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} g2sb_g2cmdsel;

#define G2SB_G2RAISE_OFFSET 0xD
#define G2SB_G2RAISE_RESET  0x00000000
typedef union g2sb_g2raise_u {
    struct {
        unsigned int raise:5;               /* Push back to read fifo when all commands in the channel are done.           */
        unsigned int undefined_bits_5_15:11;
        unsigned int raisechannel:4;
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} g2sb_g2raise;

#define G2SB_G2HOSTSET_OFFSET 0xF
#define G2SB_G2HOSTSET_RESET  0x00000000
typedef union g2sb_g2hostset_u {
    struct {
        unsigned int hstlngap:4;            /*  specifies distance (in byte) from last pixel of a line to the first   pixel of next line.  In mono mode, the value is the nearest byte number.  E.G. if gap is 3 bits, HSTLNGAP should be 1 (byte),  if gap is 9 bits, HSTLNGAP should be 2 (byte) */
        unsigned int hstfpxl:4;             /* specifies the   first pixel location (in byte) in the first source data entry. In mono mode pixel should always start in byte boundary */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} g2sb_g2hostset;

#define G2SB_G2HOSTFIFO_OFFSET 0x10
#define G2SB_G2HOSTFIFO_RESET  0x00000000
typedef union g2sb_g2hostfifo_u {
    struct {
        unsigned int hostfifodata:32;
    };

    uint32_t reg32;
} g2sb_g2hostfifo;

#define G2SB_G2VDDA_OFFSET 0x11
#define G2SB_G2VDDA_RESET  0x00000000
typedef union g2sb_g2vdda_u {
    struct {
        unsigned int vdstep:32;             /* Vertical Scaling DDAReset value: xxxx-xxxxhVertical DDA Step (Increment) Value (VDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for vertical scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_height-1-VDTINI) / (Actual_destination_height-1) Truncate the rest bits to keep the 12bits fraction. Since we have to meet (Actual_source_height-1)*1.0 >= (Actual_destination_height - 1)*VDSTEP + VDTINI Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half line-spacing for up to approximately 2000 target lines.For example, image expansion from 240 lines to 400 lines   VDSTEP[17:0]  =  19'b00_0000_1001_1001_1010   andimage contraction from 240 lines to 150 lines    VDSTEP[17:0]  =  19'b00_0001_1001_1001_1010. */
    };

    uint32_t reg32;
} g2sb_g2vdda;

#define G2SB_G2VDDAINI_OFFSET 0x12
#define G2SB_G2VDDAINI_RESET  0x00000000
typedef union g2sb_g2vddaini_u {
    struct {
        unsigned int vdtini:8;              /* Vertical Scaling DDA Initial ValuesVertical DDA Initial Value for Top-Field (VDTINI[7:0])This parameter specifies the fraction part of initial  value of the DDA used for vertical scaling.Given a pair of consecutive source image lines representing  positions 0.0 and 1.0, a destination line-image will be created  at any position in [0.0, 1.0), that is specified by the fraction part of the vertical DDA. The 8-bit initial fraction value  specifies the position of the first output (destination) line-image located between the first and the second input (source) line-images,  respectively at position 0.0 and 1.0.This parameter provides a way to compensate relative displacement of  top and bottom fields of a source image. Suppose, 2-to-1 interlaced original video field images #1 and #2 are in the image buffer, to be  displayed in an overlay window. Assume that the #1 field image is the top-field. Using VDTINI = 8'hC0 for the top-field image and  VDBINI = 8'h40 for the 
bottom-field image, for example, the two images from #1 and #2 fields get mapped to identically positioned destination images in the overlay window. */
        unsigned int vdbini:8;              /* Vertical DDA Initial Value for Bottom-Field (VDBINI[7:0]) (see description above) */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} g2sb_g2vddaini;

#define G2SB_G2HDDA_OFFSET 0x13
#define G2SB_G2HDDA_RESET  0x00000000
typedef union g2sb_g2hdda_u {
    struct {
        unsigned int hdstep:32;             /* Horizontal Scaling DDAReset value: xxxx-xxxxhHorizontal DDA Step (Increment) Value (HDSTEP[18:0]) (upper 13 bits should be set to '0')This parameter specifies the increment value of the DDA used for horizontal scaling and it is in the form of 6-bit integer and 12-bit fraction.  This value is detemined by the equation: (Actual_source_width-1-HDINI) / (Actual_destination_width-1) Truncate the rest bits to keep the 12bits fraction. Refer to bug 353260 for more detail.The 6-bit integer allows maximum contraction ratio of 1/64, and  12-bit fraction assures the maximum limit of accumulated error less than half pixel-spacing for up to approximately 2000 destination pixels.For example, image expansion from 720 pixels to 800 pixels        HDSTEP[17:0]  =  19'b000_0000_1110_0110_0111   andimage contraction from 720 pixels to 250 pixels HDSTEP[17:0]  =  19'b000_0010_1110_0001_0101. */
    };

    uint32_t reg32;
} g2sb_g2hdda;

#define G2SB_G2HDDAINILS_OFFSET 0x14
#define G2SB_G2HDDAINILS_RESET  0x00000000
typedef union g2sb_g2hddainils_u {
    struct {
        unsigned int hdini:8;               /* Horizontal Scaling DDA Initial ValueHorizontal DDA Initial Value (HDINI[7:0])This parameter specifies the fraction part of initial value  of the DDA used for horizontal scaling.Given a group of six consecutive source pixels that  the two pixels at the center representing positions 0.0 and 1.0, a destination pixel will be created at any  position in [0.0, 1.0), that is specified by the fraction part of the horizontal DDA. The 8-bit initial fraction  value specifies the position of the first output (destination) pixel located between the first and the second input (source)  pixels, respectively at position 0.0 and 1.0.For horizontal scaling this value may normally be set to 0. */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} g2sb_g2hddainils;

#define G2SB_G2CSCFIRST_OFFSET 0x15
#define G2SB_G2CSCFIRST_RESET  0x00000000
typedef union g2sb_g2cscfirst_u {
    struct {
        unsigned int cub:10;                /* multiplier for U/B for Y or B generation. consists of a sign bit and 9-bit magnitude (s2.7).  For YUV->RGB, the recommended value is 2.0172 (decimal) or 0x102. If source data is in RGB format, this parameter  may be used as gain adjustment for B component. For SC20, this register changes precision when doing RGB to YUV  conversion (SIFMT=1xxx, DIFMT=0xxx).  CUB becomes s1.8 and the recommended value is +0.098 or 0x01911-10  Reserved  */
        unsigned int undefined_bits_10_11:2;
        unsigned int cvr:10;                /* multiplier for V/R for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7) For YUV->RGB the recommended value is 1.5960 (decimal) or 0x0CCIf source data is in RGB format, this parameter  may be used as gain adjustment for R component. For RGB->YUV the recommended value is +0.439 (decimal) or 0x03823-22  Reserved */
        unsigned int undefined_bits_22_23:2;
        unsigned int yos:8;                 /* Y-Offset (YOFFSET[7:0]) for YUV generationThis parameter consists of 8-bit 2's complement in the range [-128,127]. For YUV->RGB the recommended value is -16 (decimal) or 0xF0 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +16 (decimal) or 0x10 */
    };

    uint32_t reg32;
} g2sb_g2cscfirst;

#define G2SB_G2CSCSECOND_OFFSET 0x16
#define G2SB_G2CSCSECOND_RESET  0x00000000
typedef union g2sb_g2cscsecond_u {
    struct {
        unsigned int cug:9;                 /* multiplier for U/B for U or G generation. consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.3918 (decimal) or 0x132 For  RGB->RGB, this parameter should be set to 0 For  YUV->YUV, this parameter should be set to 1 (0x080) For RGB->YUV the recommended value is +0.439 (decimal) or 0x03811-9  Reserved */
        unsigned int undefined_bits_9_11:3;
        unsigned int cur:10;                /* multiplier for U/B for V or R generation.This parameter consists of a sign bit and 9-bit magnitude (s2.7)  For YUV->RGB normally this parameter is programmed to 0.0.   This parameter takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.071 (decimal) or 0x20923-22 Reserved  */
        unsigned int undefined_bits_22_23:2;
        unsigned int cyx:8;                 /* multiplier for Y/G (G gain)This positive-only parameter consists of 8-bit magnitude (1.7) For YUV->YUV the recommended value is 1.1644 (decimal) or 0x95 For YUV->YUV or RGB->RGB this may be used as gain adjustment for Y or G component. For RGB->YUV the recommended value is +0.504 (decimal) or 0x041 */
    };

    uint32_t reg32;
} g2sb_g2cscsecond;

#define G2SB_G2CSCTHIRD_OFFSET 0x17
#define G2SB_G2CSCTHIRD_RESET  0x00000000
typedef union g2sb_g2cscthird_u {
    struct {
        unsigned int cvg:9;                 /* multiplier for V/R for U or G generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For YUV->RGB the recommended value is -0.8130 (decimal) or 0x168 For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is -0.148 (decimal) or 0x113 */
        unsigned int undefined_bits_9_15:7;
        unsigned int cvb:10;                /* multiplier for V/R for Y or B generation. This parameter consists of a sign bit and 9-bit magnitude (s2.7)For YUV->RGB, normally this parameter is programmed to 0.0.   This coefficient takes non-zero value if hue is rotated.  For YUV->YUV &  RGB->RGB, this parameter should be set to 0 For RGB->YUV the recommended value is +0.257 (decimal) or 0x021 */
        unsigned int undefined_bits_26_31:6;
    };

    uint32_t reg32;
} g2sb_g2cscthird;

#define G2SB_G2CMKEYL_OFFSET 0x18
#define G2SB_G2CMKEYL_RESET  0x00000000
typedef union g2sb_g2cmkeyl_u {
    struct {
        unsigned int ckbl:8;                /* B or Y Color/Chroma Key Lower Limit (CKBL[7:0]) */
        unsigned int ckgl:8;                /* G or Cb Color Chroma Key Lower Limit (CKGL[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  from the minimum signal level to the maximum signal level. */
        unsigned int ckrl:8;                /* R or Cr Color Chroma Key Lower Limit (CKRL[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24 Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} g2sb_g2cmkeyl;

#define G2SB_G2CMKEYU_OFFSET 0x19
#define G2SB_G2CMKEYU_RESET  0x00000000
typedef union g2sb_g2cmkeyu_u {
    struct {
        unsigned int ckbu:8;                /* This is B or Y color/chroma key upper limit value. */
        unsigned int ckgu:8;                /* G or Cb Color/Chroma Key Upper Limit (CKGU[7:0]) Cb signal must be treated in offset binary format  so that the binary interpretation retains monotonicity  the minimum signal level to the maximum signal level. */
        unsigned int ckru:8;                /* R or Cr Color Chroma Key Upper Limit (CKRU[7:0]) Cr signal must be treated in offset binary format  so that the binary interpretation retains monotonicity from  the minimum signal level to the maximum signal level.31-24  Reserved  */
        unsigned int undefined_bits_24_31:8;
    };

    uint32_t reg32;
} g2sb_g2cmkeyu;

#define G2SB_G2UBA_A_OFFSET 0x1A
#define G2SB_G2UBA_A_RESET  0x00000000
typedef union g2sb_g2uba_a_u {
    struct {
        unsigned int su1sa:32;              /* Start Address of  Source U-image Area, 4:2:0 Format. This parameter specifies the start address of source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    uint32_t reg32;
} g2sb_g2uba_a;

#define G2SB_G2VBA_A_OFFSET 0x1B
#define G2SB_G2VBA_A_RESET  0x00000000
typedef union g2sb_g2vba_a_u {
    struct {
        unsigned int sv1sa:32;              /* Start Address of  Source V-image Area, 4:2:0 Format. This parameter specifies the start address of  source image stored in  the image buffer memory.   The [3:0] bits have to be 0, since memory client will assemble YUV into one 422 format. */
    };

    uint32_t reg32;
} g2sb_g2vba_a;

#define G2SB_G2SBFORMAT_OFFSET 0x1C
#define G2SB_G2SBFORMAT_RESET  0x00000000
typedef union g2sb_g2sbformat_u {
    struct {
        unsigned int sifmt:5;               /* This parameter defines the data format of source input.   There are two groups of data formats, RGB format and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 B5G6R5 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 B5G6R5 5-6-5 Byte-swapped {G[2:0], B[4:0], R[4:0], G[5:
3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED StretchBlit Inputs  ================== RGB    inputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV420 input  = {YUV420 is converted into 4:2:2 UYVY via memory client} YUV422 inputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Outputs =================== RGB    outputs = {B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8} YUV422 outputs = {U8Y8V8Y8_OB, Y8U8Y8V8_OB, V8Y8U8Y8_OB, U8Y8V8Y8_OB, U8Y8V8Y8_TC, Y8U8Y8V8_TC, Y8V8Y8U8_TC, V8Y8U8Y8_TC} StretchBlit Input/Output Rules ==============================+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|    src format                                                | internal sb format |      dst format                                           |+--------------------------------------------------------------+--------------------+-----------------------
------------------------------------+|  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                        |      R8G8B8A8      |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*           |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+|  U8Y8V8Y8_*, Y8U8Y8V8_*, V8Y8U8Y8_*, U8Y8V8Y8_*, YUV420      |      YUV 4:4:4     |  B5G6R5, B5G6R5BS, R8G8B8A8, B8G8R8A8                     |+--------------------------------------------------------------+--------------------+-----------------------------------------------------------+  StretchBlit color space converter supports YUV->RGB, YUV->YUV (gain) and RGB->RGB (gain).  There is no support for 
RGB->YUV. */
        unsigned int undefined_bits_5_7:3;
        unsigned int difmt:5;               /* Destination Image Data FormatThis parameter defines the data format of distination output.   There are two groups of data formats, RGB and YCbCr (YUV) format. CbCr (UV) components may be represented in either offset binary or 2's complement.00000 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00001 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00010 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00011 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V in offset binary format00100 U8Y8V8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00101 Y8U8Y8V8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00110 Y8V8Y8U8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement00111 V8Y8U8Y8, YUV 4:2:2, 8-bit for each component, U/V is 2's complement01000 bpp16 5-6-5 {R[4:0], G[5:0], B[4:0]} 01001 RESERVED01010 RESERVED01011 RESERVED01100 bpp16 5-6-5 Byte-swapped {G[
2:0], B[4:0], R[4:0], G[5:3]}01101 RESERVED01110 R8G8B8A801111 B8G8R8A81xxxx RESERVED */
        unsigned int undefined_bit_13:1;
        unsigned int raisebufferen:1;       /* ENABLE - SB needs to send a RAISE_BUFFER control bit to EPP DISABLE - do nothing.  */
        unsigned int raiseframeen:1;        /* ENABLE - SB needs to send a RAISE_FRAME control bit to EPP DISABLE - do nothing.  */
        unsigned int raisebuffervalue:8;    /* Raise buffer vector value. */
        unsigned int raiseframevalue:8;     /* Raise Fram vector value. */
    };

    uint32_t reg32;
} g2sb_g2sbformat;

#define G2SB_G2CONTROLSB_OFFSET 0x1D
#define G2SB_G2CONTROLSB_RESET  0x00000000
typedef union g2sb_g2controlsb_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int yuv422rotation:1;      /* yuv422 plannar rotated */
        unsigned int yuv422planar:1;        /* source data is yuv422 planar valid when imode==PLANAR */
        unsigned int imode:1;               /* Source (input) Data Mode  (IMODE) This parameter defines the data mode of source input.   0: Multiplexed Mode (data format is specified by SIFMT[2:0]) One block of source data in the Image Buffer memory contains  multiplexed component signals.  1: Planar mode, 4:2:0 YUV (SIFMT[2] specifies data format of U/V components) Three blocks of source data in the Image Buffer memory contain separate Y, U, and V component signals.   For circular buffer input to gr2d, the input format can not be planar.  It must be multiplex.    i.e. no YUV420 planar circular buffer input to gr2d. */
        unsigned int enavf:1;               /* enable alpha vertical filter     */
        unsigned int enahf:1;               /* enable horizontal alpha filtering if disabled, use the alpha value of third tap for output pixelU,V line stride in 4:2:0  Format, */
        unsigned int uvst:2;                /*   00= 1/2 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this case       Luma Buffer Stride should be multiple       of 4 bytes.   11= use uvstride. Note: Use care when using a tiled surface, since 1/2 or 1/4   of luma stride may yield an invalid pitch (stride). */
        unsigned int sl:1;                  /* Source (input) Data Line Pairing  (SL)  This parameter specifies one of two cases of Y vs. U/V line-pairing  in the source data in 4:2:0 format. In the 4:2:0 format, there is one pair of U and V image-lines for  every two Y image-lines. 0 The first two Y image-lines share common pair of U and V image-lines. 1 The first two Y image-lines are paired with two different  pairs of U and V image-lines. */
        unsigned int undefined_bits_11_12:2;
        unsigned int sisel:1;               /* StretchBLT Source Provider Selection (SISEL) This bit indicates where the source images come from,  either the  image buffer memory or system memory of the host CPU.  If source images come from host CPU, they come via CPU Read-FIFO. 0 Image buffer memory. 1 System memory of host CPU.14 Reserved  */
        unsigned int undefined_bit_14:1;
        unsigned int sbltsrc:1;             /* StretchBLT Source Selection  (SBLTSRC) CPU and VIP module can initiate StretchBLT operation. This bit indicates  which one initiates current StretchBLT command. Depending on the initiator,  appropriate source for the command execution request is selected. Whichever  the initiator is, all the command parameters are supplied from the CPU (driver)  through the G2 command-FIFO and shadow registers.0 CPU is the command initiator.1 VIP module is the command initiator. */
        unsigned int vftype:2;              /* StretchBLT Vertical Filter Mode (VFTYPE[1:0]) This bit is effective when the Vertical Filter is enabled. (bit 18) The two-tap vertical interpolation filter can be operated in various modes.  For the image expansion, it should be programmed as a pure 2-tap  interpolator. For the image contraction, it can work as partly averager  and partly interpolator with varying degree depending on the contraction ratio. For StretchBLT, this parameter is used as an index (selection) to  an internal lookup table that stores the group of filter-coefficients for  the different modes of vertical filtering.00 Pure interpolation filter.01 25% averager, 75% interpolator.10 50% averager, 50% interpolator.11 100% averager. */
        unsigned int vfen:1;                /* StretchBLT Vertical Filter Enable (VFEN) Vertical filter shall be disabled if source images come from host CPU  via CPU Read-FIFO. (SISEL) Vertical filter may be disabled to save some memory bandwidth but  this will likely result in degradation of image quality.   This option may also be used in the case where source image is progressive  scanning and there is no vertical scaling. 0 Vertical filter is disabled.1 Vertical filter is enabled. */
        unsigned int discsc:1;              /* enabled color space converter by default */
        unsigned int hftype:3;              /* StretchBLT Horizontal Filter Mode (HFTYPE[2:0]) The six-tap horizontal interpolation filter can be operated in  various operation modes. For the image expansion, it should be programmed  as a pure 6-tap interpolator.  For the image contraction, it can work as  partly lowpass filter and partly interpolater with varying degree depending  the contraction ratio. For StretchBLT, this parameter is used as an index (selection)  to an internal lookup table that stores the group of filter-coefficients for the different modes of horizontal filtering.  000: Pure interpolation filter. 001: 010 011 100 101 110: mix of interpolation and low pass filters 111: DISABLE. */
        unsigned int rangeredfrm:1;         /* In the VC-1 specification, when the value of RANGEREDFRM variable (1-bit)  for a picture is equal to 1, the picture shall be scaled up according  to the following equation:Y = clip( (( Y-128)*2) + 128);Cb = clip( ((Cb-128)*2) + 128);Cr = clip( ((Cr-128)*2) + 128);The clip operator limits the output to [0, 255].The input is also limited to [0, 255].In the VC-1 nomenclature, the output (Y, Cb, Cr) tuple corresponds to  the 'decoded' picture. The input (Y, Cb, Cr) tuple corresponds to  the 'reconstructed' picture.  The above equations create the decoded picture while keeping  the reconstructed picture intact.Only YUV _OB formats are supported with range reducation enabled, not the YUV _TC or RGB formats.----------------------------------------------------At PortalPlayer this functionality was implemented in the DVO module.  The YUV data coming from the video frame buffers (reconstructed picture)  in the SDRAM was scaled up using the above equations and given to the 
display.  the value of 1-bit wide RANGEREDFRM variable was configured in the DVO per frame  and the frame was scaled whenever RANGEREDFRM == 1.  */
        unsigned int sitype:1;              /* StretchBLT Source Type (SITYPE) This bit identifies two types of source images. If source image is 2-to-1  interlaced and StretchBLT processes either one of the two interlaced  field-images, physical (positional) displacement between the two  interlaced fields must be taken into account.  One field-image that is  placed higher in position than the other field-image is called top-field  and the other is called bottom-field. StretchBLT processing has to  lower the top-field (or raise the bottom-field) to match the corresponding two target images in the overlay window (that is progressively scanned) right at the same position.   If source image is full frame-image  obtained from two interlaced field-images, its type is ?top-field?.   If source images are progressively scanned, the type identification is not  significant and they may be designated either one of the two types 0 Source image is ?top-field?.1 Source image is ?bottom-field?. */
        unsigned int sbsel:1;               /* StretchBLT Source Buffer Selection (SBSEL) StretchBLT processing involves frame-rate conversion from a  series of source images to another series of destination images  (field-rate of the source video to frame-rate of the PC display). In order to avoid image tearing, it is preferred to use two buffer  sections in the source video area. This bit selects one of the two  buffering blocks from which this StretchBLT command receives the source image.  The two buffering memory blocks are called source-A and source-B. 0 Source image comes from ?source-A? buffer.1 Source image comes from ?source-B? buffer. */
        unsigned int dbsel:1;               /* StretchBLT Destination Buffer Selection (DBSEL) StretchBLT processing involves frame-rate conversion from a series of source images to another series of destination images (field-rate of  the source video to frame-rate of the PC display). In order to avoid  image tearing, it is preferred to use two buffer sections in the destination video area.  This bit selects one of the two buffering blocks to which this  StretchBLT command delivers the destination image.  The two buffering memory blocks are called A and B. 0 Destination image goes to ?A? buffer.1 Destination image goes to ?B? buffer. */
        unsigned int keyen:1;               /* Key Signal Generator Enable (KEYEN) Key signal generator generates either chroma key signal (from YCbCr signal) or color key signal (from RGB signal)0 Key signal generator is disabled.1 Key signal generator is enabled. */
        unsigned int kpol:1;                /* Key Signal Polarity (KPOL) Color/Chroma key signal is generated by comparing source input pixel  color to a range of a color specified by lower and upper limit values. The key signal is interpreted in two ways, depending on which one of  video and graphics images is foreground (and the other is background).   This is effective only if Key signal generator is enabled. (see G2CMKEYL, G2CMKEYU)  0 Key signal is set to 1 when source pixel is within the lower and upper  limit color range. 1 Key signal is set to 1 when source pixel is outside the lower and upper  limit color range. */
        unsigned int undefined_bit_29:1;
        unsigned int endith:1;              /* Enable Dithering (ENDITH) For 16 bit RGB output modes, the LSB of the color components can be modified by adding a variable residual value that will reduce the banding artifacts that can appear on the display. 0 Normal operation 1 Enable Dithering */
        unsigned int disdw:1;               /* output destination writes (dw) go either to image memory or epp0 Output data is sent to memory1 YUV or RGB data is passed directly to EPP module and no destination writes  will take place. */
    };

    uint32_t reg32;
} g2sb_g2controlsb;

#define G2SB_G2CONTROLSECOND_OFFSET 0x1E
#define G2SB_G2CONTROLSECOND_RESET  0x00000000
typedef union g2sb_g2controlsecond_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int bitswap:1;             /* Host port bit swap 1=enable   0= disable   1= enable */
        unsigned int bebswap:1;             /* Host port byte swap 1=enable   0= disable   1= enable */
        unsigned int bewswap:1;             /* Host port word swap 1=enable   0= disable */
        unsigned int alptype:5;             /* Alpha blending method FIX:        ALPHA blending:  Fixed alpha,  ALPHA is the value, B5G6R5 * B5G6R5   VCAA:            B5G6R5->B5G6R5 PL1BPP:     ALPHA blending:  Alpha 1bit/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 PL2BPP:       ALPHA blending:  Alpha 2bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 PL4BPP:       ALPHA blending:  Alpha 4bits/pixel from memory plane, B5G6R5 * B5G6R5      NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 PL8BPP:       ALPHA blending:  Alpha 8bits/pixel from memory plane, B5G6R5 * B5G6R5 PL44BPP:      ALPHA blending:  Alpha 8bits/pixel from memory plane src*4bits+dst*4bits, B5G6R5 * B5G6R5 PLS1BPP:      ALPHA blending:  Alpha 1bit from source B5G5R5A1, alpha(MSB). Dest: B5G6R5.    VCAA:            reserved PLS4BPPAL:    ALPHA blending:  Alpha 4bits from source A4B4G4R4,
 alpha(LSB). Dest: B5G6R5. PLS4BPP:      ALPHA blending:  Alpha 4bits from source B4G4R4A4, alpha(MSB). Dest: B5G6R5.   VCAA:            R8G8B8A8->B5G6R5 without reading VCAA plane                     (surface blit with bpp down convert - implemented in hw by vcaa engine; not really a vcaa resolve) PLS8BPP:      ALPHA blending:  Alpha 8bits from source/destination(decided by ALPSRCORDST),                     R8G8B8A8, alpha(MSB). DST: R8G8B8A8   VCAA:            R8G8B8A8->R8G8B8A8, alpha has same blending method as RGB PLS8BX:       ALPHA blending:  Alpha 8bits from source B8G8R8A8, alpha(MSB). Dest: B5G6R5. (**Restrictions)   VCAA:            R8G8B8A8->B5G6R5 PLS1BPPAL:    ALPHA blending:  Alpha 1 bit from source A1B5G5R5, alpha(LSB). Dest: B5G6R5   VCAA:            A1B5G5R5->A1B5G5R5 **Restriction PLS8BX alpha blending has the following restrictions 1. Source/destination addresses have to be in 128bit boundary. 2. Destination width has to be multiple of 4 pixels. 3. Source/Destination strides have to be 
multiple of 128bits. */
        unsigned int alpsrcordst:1;         /* 32bits blending mode, output alpha selection 0:source alpha, 1:destination alpha */
        unsigned int undefined_bits_10_13:4;
        unsigned int pxlrep:1;              /* Pixel replication for Palm OS. */
        unsigned int swapblt:1;             /* Used by Palm OS to highlight a selected icon by swapping  Background and Foreground colors in a rectangle area */
        unsigned int vcaa_safe_mode:1;      /* VCAA safe mode, if turned on, all up/bottom color data will be read in. This is a debug/cya incase the top/bottom color  fetch is broken. */
        unsigned int undefined_bits_17_19:3;
        unsigned int g2nostop:1;
        unsigned int clipc:2;               /* Clipping rectangle control,  if clip enable, bit 57 XYTDW should be cleared.  0x=clipping disabled,  10=draw only inside clipping rectangle,  11=draw only outside clipping rectangle */
        unsigned int undefined_bit_23:1;
        unsigned int fr_mode:2;             /* Fast Rotate mode sel------------------------------------------------------------------ G2 Fast Rotate Transforms a surface via FR_TYPE transformation. Works in either 2-buffer (copy)  or 1-buffer mode (in place) mode. The engine breaks down a larger surface into a grid of smaller FR_BLOCKs. Works on the granularity of an FR_BLOCK.  An FR_BLOCK is:   16x16 pixel block (DSTCD = bpp8)    8x8  pixel block (DSTCD = bpp16)    4x4  pixel block (DSTCD = bpp32) Max surface size is 4096x4096  Key information  - source and destination base address must be 128-bit word aligned  - engine works on FR_BLOCK granularity:      transformed surface width  in multiples of 16-bytes**      transformed surface height in multiples of 16/8/4 lines for bpp8/bpp16/bpp32 FR_BLOCK      if surface dimension is not a multiple, sw can program FR engine to transform larger surface          (round up to next FR_BLOCK in width and height-->transform-->calculate relative memory pointer address)  - 
during a rotational transformation (TRANS_LR, TRANS_RL, ROT_90, ROT_270):      the stride of the output surface != the stride of the input surface when working on non-square input      input:                        output:      *^----------------------           *$----------------------      $ 0  1  2  3  4  5  6  7           ^ 24 16 8  0  ^  ^  ^  ^      | 8  9 10 11 12 13 14 15           | 25 17 9  1  ^  ^  ^  ^      |16 17 18 19 20 21 22 23           | 26 18 10 2  ^  ^  ^  ^      |24 25 26 27 28 29 30 31           | 27 19 11 3  ^  ^  ^  ^       | -  -  -  -  *  *  *  *           | 28 20 12 4  *  *  *  *      | -  -  -  -  *  *  *  *           | 29 21 13 5  *  *  *  *      | -  -  -  -  *  *  *  *           | 30 22 14 6  *  *  *  *      | -  -  -  -  *  *  *  *           | 31 23 15 7  *  *  *  *  - Tiling alignment restrictions subsume FR restrictions because the     FR surface base address is the same as the start address.  Register Programming  ====================   FR_MODE - inplace or copy   FR_TYPE - 
type of transformation   DSTCD - bpp8, bpp16, bpp32   SRCBA - source base address   SRCWIDTH - (width in pixels-1)   SRCHEIGHT - (height in lines-1)   SRCS - source stride    DSTBA - dest base address   DSTS - dest stride   FR_READWAIT - always set to enable FR inefficency in the following setup : 1. FR_MODE==SQUARE 2. if(FR_TYPE==YFLIP && SRCHEIGHT==m*n && n==odd number) where m=8bpp?16:16bpp?8:4    Or if(FR_TYPE==XFLIP && SRCWIDTH==m*n && n==odd number) where m=8bpp?16:16bpp?8:4 3. Then, the middle 8 lines/pixels, E.G. YFLIP/16bpp/n==3, line8 to line15 will be processed twice. 00 = disable fast rotate - this turns off the 2nd level clock to fr_rotate engine.  Please remember to do so! 01 = src/dst copy mode - two separate buffers 10 = square in place - one buffer 11 = blank */
        unsigned int fr_type:3;             /*  Fast Rotate type     000 = FLIP_X  001 = FLIP_Y  010 = TRANS_LR (mirrors about diagonal. Diagonal runs from upper left to lower right) 011 = TRANS_RL (mirrors about diagonal. Diagonal runs from upper right to lower left) 100 = ROT_90 (counter clock wise by 90 degrees) 101 = ROT_180  110 = ROT_270 (clock wise by 90 degrees) 111 = IDENTITY */
        unsigned int fr_readwait:1;         /*  Fast Rotate wait for read 0 = disable 1 = enable Enabling this bit forces FR to wait for the reads to be stored in the data return fifo before started to send writes out to  the same block. Always set to ENABLE.  This is debug only. */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} g2sb_g2controlsecond;

#define G2SB_G2CONTROLMAIN_OFFSET 0x1F
#define G2SB_G2CONTROLMAIN_RESET  0x00000000
typedef union g2sb_g2controlmain_u {
    struct {
        unsigned int cmdt:2;                /* Command Type:  00=BitBlt 01=Line Draw  10=VCAA 11=reserved  When the raise command is in executing    (there are no other outstanding commands with same channel being executed) */
        unsigned int turbofill:1;           /* fast fill rectangle in 128bit/clockSome limitaions with this mode:srcsld==1 rop==0xcc, no clipping, no transparencyxdir==0, ydir==0, flip==0, xytdw==0Results are undefined if the above limitations are not satified. */
        unsigned int test0bit:1;            /* Command finish timing bit 0: 2D command finishs when last data has been pushed to memory write client. 1: 2D command waits memory write client to be idle to finish. */
        unsigned int faden:1;               /* BitBlt Source Copy Fade enable, 1=enable (share with mltln), only support  16bpp mode */
        unsigned int alpen:1;               /* BitBlt Alpha Blending, 1=enable. 0=disable,when both Faden and alpen are 1, output=Source*alpha_v + fadoff,  alpha_v is decided by alptype */
        unsigned int srcsld:1;              /* BitBlt Solid Source Color Fill: 1=enable. FGC will be used as  the color value. */
        unsigned int patsld:1;              /* BitBlt Solid Pattern Fill: 1=enable. BGC will be used as  the color value. */
        unsigned int patfl:1;               /* When mono pattern is set, we use mono tile pattern fill.  current pattern client can support a 16x16 bit tile which can be used  to generate a larger surface (i.e. tile this surface in the x and y direction)  The tile is stored in memory.  Currently, PATXO and PATYO tell you where  to start in the 16x16 tile when expanding the monochrome data.    See patxo and patyo comments below for programming (hw bid 247332)   When xdir==1     Patxo = pattern width - (patxo+destination width)&0xF   -- For xoffsets  y offsets PATYO remains the same when xdir/ydir change.  How the tile replication pattern looks based on xdir/ydir (without programming patxo above):  xdir=0 ydir=0              xdir=1 ydir=0      +---+--+                  +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+                                      +---+--+       
           +--+---+   |^|^|^||                  ||^|^|^|   |~~~|~~|                  |~~|~~~|   +---+--|                  |--+---+   |^|^|^||                  ||^|^|^|   +------+                  +------+    //  xdir=0 ydir=1              xdir=1 ydir=1   Mono tile is       +---+      |^|^|      |~~~|      +---+ */
        unsigned int xdir:1;                /*  0=incrementing, 1=decrementing.  xdir should not be set when source surface has different color depth as destination surface.  e.g. ALPTYPE=PLS8BX (32bpp blending with 16bpp), xdir has to be 0  SRCCD==0 (mono src) OR PATCD==0 (mono pat), xdir has to be 0 */
        unsigned int ydir:1;                /*  0=incrementing, 1=decrementing.  ydir should not be set when source surface has different color depth as destination surface.  SRCCD==0 (mono src) OR PATCD==0 (mono pat), ydir has to be 0 */
        unsigned int xytdw:1;               /* xy transpose, Line stride DSTS has to be 16bytes aligned if enabled.   If XYTDW==1, ROP can not include destination. */
        unsigned int srcpack:1;             /* Source Data is in Pack Mode.   SRCLNGAP in G2SRCPACK is the line gap for source packed mode.  If(SRCPACK && ~SRCSEL), source data is packed and from screen, SRCMONOW/SRCMONOH   should be programmed properly to fetch data from   frame buffer.  Note, PACK is not offically supported when the surface is tiled. */
        unsigned int patpack:1;             /* Pattern Data is in Pack Mode.   PATLNGAP in G2PATPACK is the line gap for pattern packed mode   If(PATPACK && ~PATSEl), pattern data is packed and from screen, PATMONOW/PATMONOH   should be programmed properly to fetch pattern data from   frame buffer.   Note, PACK is not offically supported when the surface is tiled. */
        unsigned int yflip:1;               /* flip y direction to make image upside down or the other way. If YFLIP==1, ROP can not include destination. */
        unsigned int srcsel:1;              /* Source Data Select: */
        unsigned int dstcd:2;               /* Destination color depth:   00=8-bpp, 01=16-bpp, 10=32-bpp. 11=reserved */
        unsigned int dstt:2;                /* Destination read transparency enable:   0x=destination read transparency disabled   10=color destination read transparency   11=inverse color destination read transparency. 20 rw INIC                    Initiate Command (1=initiate command immediately, 0=wait for launch write) */
        unsigned int srccd:1;               /* 0 Source mono1 Source has same color depth as destination  SRCCD==0 xdir/ydir has to be 0 */
        unsigned int hlmono:1;              /* Start from Msb or lsb in byte when mono expansion If HLMONO is 1, bit 0 (the lsb) is the first bit If HLMONO is 0, bit 7 (the msb) is the first bit */
        unsigned int srct:2;                /* Source transparency enable: 0x=source transparency disabled,  10=mono source background transparency     or color source transparency,  11=mono source foreground transparency     or inverse color source transparency.  NOTE: When source transparency is enabled and SRCCD==0(mono)       SRCBGC!=SRCFGC should be satisfied. */
        unsigned int srcbas:1;              /* Source base address select:   0=srcba, 1=dstba. This is not used for Line Draw and  if source data comes from host memory. */
        unsigned int gcsw:2;                /* Display Switching Window Control (GCSW[1:0])This parameter controls multi-buffering for Display.x0 At end of current command, don't send signal to Display to switch buffer.01 two buffers, dstba and dstba_b are used11 three buffers, dstba, dstba_b dstba_c are used */
        unsigned int srcdir:1;              /* source direct addressing */
        unsigned int dstdir:1;              /* destination direct addressing */
        unsigned int dst_rd_wr_sep:1;       /* This feature is not offically supported.seperate destination read/write surface address0: read/write use DSTBA1: read uses SRCBA_B, write uses DSTBA */
        unsigned int patsel:1;              /* pattern Data Select: SRCSEL and PATSEL can't be both enabled. */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} g2sb_g2controlmain;

#define G2SB_G2ROPFADE_OFFSET 0x20
#define G2SB_G2ROPFADE_RESET  0x00000000
typedef union g2sb_g2ropfade_u {
    struct {
        unsigned int rop:8;                 /* If YFLIP==1 or XYTDW==1, ROP can not include destination.Since destination may have been corrupted before reading out. */
        unsigned int undefined_bits_8_15:8;
        unsigned int fadcoe:8;
        unsigned int fadoff:8;
    };

    uint32_t reg32;
} g2sb_g2ropfade;

#define G2SB_G2ALPHABLEND_OFFSET 0x21
#define G2SB_G2ALPHABLEND_RESET  0x00000000
typedef union g2sb_g2alphablend_u {
    struct {
        unsigned int alpha:8;
        unsigned int alphainv:1;
        unsigned int undefined_bits_9_15:7;
        unsigned int alpha0v:8;
        unsigned int alpha1v:8;
    };

    uint32_t reg32;
} g2sb_g2alphablend;

#define G2SB_G2CLIPLEFTTOP_OFFSET 0x22
#define G2SB_G2CLIPLEFTTOP_RESET  0x00000000
typedef union g2sb_g2cliplefttop_u {
    struct {
        unsigned int clipl:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipt:15;
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} g2sb_g2cliplefttop;

#define G2SB_G2CLIPRIGHTBOT_OFFSET 0x23
#define G2SB_G2CLIPRIGHTBOT_RESET  0x00000000
typedef union g2sb_g2cliprightbot_u {
    struct {
        unsigned int clipr:15;
        unsigned int undefined_bit_15:1;
        unsigned int clipb:15;
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} g2sb_g2cliprightbot;

#define G2SB_G2PATPACK_OFFSET 0x24
#define G2SB_G2PATPACK_RESET  0x00000000
typedef union g2sb_g2patpack_u {
    struct {
        unsigned int patlngap:4;            /* Packed mode, pattern data line gap. byte */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} g2sb_g2patpack;

#define G2SB_G2PATPACK_SIZE_OFFSET 0x25
#define G2SB_G2PATPACK_SIZE_RESET  0x00000000
typedef union g2sb_g2patpack_size_u {
    struct {
        unsigned int patmonow:16;           /* Mono data width in packed mode, byte  */
        unsigned int patmonoh:16;           /*  Pattern mono data height in packed mode, byte  */
    };

    uint32_t reg32;
} g2sb_g2patpack_size;

#define G2SB_G2PATBA_OFFSET 0x26
#define G2SB_G2PATBA_RESET  0x00000000
typedef union g2sb_g2patba_u {
    struct {
        unsigned int patba:32;              /* If(PATFL==1){   It has to be 16bytes aligned. }else{   Point to the first byte of the first pixel of pattern plane. } */
    };

    uint32_t reg32;
} g2sb_g2patba;

#define G2SB_G2PATOS_OFFSET 0x27
#define G2SB_G2PATOS_RESET  0x00000000
typedef union g2sb_g2patos_u {
    struct {
        unsigned int patst:16;              /* stride */
        unsigned int patcd:1;               /* 0 mono1 same as dstcd  PATCD==0 xdir/ydir has to be 0 */
        unsigned int undefined_bits_17_20:4;
        unsigned int patt:2;                /* Mono pattern transparency enable:  0x=pattern transparency disabled,  10=mono pattern background transparency    or color pattern transparency,  11=mono pattern foreground transparency    or inverse color pattern transparency. NOTE: When pattern transparency is enabled and PATCD==0(mono)       PATBGC!=PATFGC should be satisfied. */
        unsigned int undefined_bit_23:1;
        unsigned int patxo:4;               /* x offset for mono tile pattern fill.  see PATFL */
        unsigned int patyo:4;               /* y offset for mono tile pattern fill.  see PATFL */
    };

    uint32_t reg32;
} g2sb_g2patos;

#define G2SB_G2PATBGC_OFFSET 0x28
#define G2SB_G2PATBGC_RESET  0x00000000
typedef union g2sb_g2patbgc_u {
    struct {
        unsigned int patbgc:32;
    };

    uint32_t reg32;
} g2sb_g2patbgc;

#define G2SB_G2PATFGC_OFFSET 0x29
#define G2SB_G2PATFGC_RESET  0x00000000
typedef union g2sb_g2patfgc_u {
    struct {
        unsigned int patfgc:32;
    };

    uint32_t reg32;
} g2sb_g2patfgc;

#define G2SB_G2PATKEY_OFFSET 0x2A
#define G2SB_G2PATKEY_RESET  0x00000000
typedef union g2sb_g2patkey_u {
    struct {
        unsigned int patkey:32;
    };

    uint32_t reg32;
} g2sb_g2patkey;

#define G2SB_G2DSTBA_OFFSET 0x2B
#define G2SB_G2DSTBA_RESET  0x00000000
typedef union g2sb_g2dstba_u {
    struct {
        unsigned int dstba:32;              /* Destination base address (byte address)  */
    };

    uint32_t reg32;
} g2sb_g2dstba;

#define G2SB_G2DSTBA_B_OFFSET 0x2C
#define G2SB_G2DSTBA_B_RESET  0x00000000
typedef union g2sb_g2dstba_b_u {
    struct {
        unsigned int dstba_b:32;            /* Destination base address (byte address) only usable in hardware trigger mode by enable gcsw */
    };

    uint32_t reg32;
} g2sb_g2dstba_b;

#define G2SB_G2DSTBA_C_OFFSET 0x2D
#define G2SB_G2DSTBA_C_RESET  0x00000000
typedef union g2sb_g2dstba_c_u {
    struct {
        unsigned int dstba_c:32;            /* Destination base address (byte address)  */
    };

    uint32_t reg32;
} g2sb_g2dstba_c;

#define G2SB_G2DSTST_OFFSET 0x2E
#define G2SB_G2DSTST_RESET  0x00000000
typedef union g2sb_g2dstst_u {
    struct {
        unsigned int dsts:16;               /* Destination Stride coordinate(bytes) with respect to DSTBA. */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} g2sb_g2dstst;

#define G2SB_G2SRCPACK_OFFSET 0x2F
#define G2SB_G2SRCPACK_RESET  0x00000000
typedef union g2sb_g2srcpack_u {
    struct {
        unsigned int srclngap:4;            /* Packed mode - source mono data line gap */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} g2sb_g2srcpack;

#define G2SB_G2SRCPACK_SIZE_OFFSET 0x30
#define G2SB_G2SRCPACK_SIZE_RESET  0x00000000
typedef union g2sb_g2srcpack_size_u {
    struct {
        unsigned int srcmonow:16;           /* Packed mode - source mono data width in bytes */
        unsigned int srcmonoh:16;           /* Packed mode - source mono data height in bytes  */
    };

    uint32_t reg32;
} g2sb_g2srcpack_size;

#define G2SB_G2SRCBA_OFFSET 0x31
#define G2SB_G2SRCBA_RESET  0x00000000
typedef union g2sb_g2srcba_u {
    struct {
        unsigned int srcba:32;              /* Source base address (byte address)  */
    };

    uint32_t reg32;
} g2sb_g2srcba;

#define G2SB_G2SRCBA_B_OFFSET 0x32
#define G2SB_G2SRCBA_B_RESET  0x00000000
typedef union g2sb_g2srcba_b_u {
    struct {
        unsigned int srcba_b:32;            /* This parameter specifies the start address of source image  stored in the image buffer memory. In 4:2:0 format mode, this image block accommodates for Y-image.This address specifies byte-position, however, bits [2:0]  are restricted with respect to the data formats to fit multiple pixels in one memory word (8 bytes),. For example,  {0, 4} for any YcrCb formats, {0, 2, 4, 6} for RGB 16-bit format.  Since one Y pixel takes 8-bit, all  8 byte-positions are valid in 4:2:0 mode. (Unlike multiplexed pixels format, there is no restrictions on this value.) */
    };

    uint32_t reg32;
} g2sb_g2srcba_b;

#define G2SB_G2SRCST_OFFSET 0x33
#define G2SB_G2SRCST_RESET  0x00000000
typedef union g2sb_g2srcst_u {
    struct {
        unsigned int srcs:16;               /* Source Stride coordinate(bytes) with respect to SRCBA.In order to fit multiple pixels in one memory word (8 bytes),  bits [2:0] are restricted with respect to the data formats. For example, {0, 4} for any YcrCb formats,  {0, 2, 4, 6} for RGB 16-bit format.  */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} g2sb_g2srcst;

#define G2SB_G2SRCBGC_OFFSET 0x34
#define G2SB_G2SRCBGC_RESET  0x00000000
typedef union g2sb_g2srcbgc_u {
    struct {
        unsigned int srcbgc:32;
    };

    uint32_t reg32;
} g2sb_g2srcbgc;

#define G2SB_G2SRCFGC_OFFSET 0x35
#define G2SB_G2SRCFGC_RESET  0x00000000
typedef union g2sb_g2srcfgc_u {
    struct {
        unsigned int srcfgc:32;
    };

    uint32_t reg32;
} g2sb_g2srcfgc;

#define G2SB_G2SRCKEY_OFFSET 0x36
#define G2SB_G2SRCKEY_RESET  0x00000000
typedef union g2sb_g2srckey_u {
    struct {
        unsigned int srckey:32;
    };

    uint32_t reg32;
} g2sb_g2srckey;

#define G2SB_G2SRCSIZE_OFFSET 0x37
#define G2SB_G2SRCSIZE_RESET  0x00000000
typedef union g2sb_g2srcsize_u {
    struct {
        unsigned int srcwidth:15;
        unsigned int undefined_bit_15:1;
        unsigned int srcheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} g2sb_g2srcsize;

#define G2SB_G2DSTSIZE_OFFSET 0x38
#define G2SB_G2DSTSIZE_RESET  0x00000000
typedef union g2sb_g2dstsize_u {
    struct {
        unsigned int dstwidth:15;           /* In 2D mode, the largest number can be programmed is 0x7fef */
        unsigned int undefined_bit_15:1;
        unsigned int dstheight:15;          /* In SB mode, number of lines - 1 In 2D mode, actual lines */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} g2sb_g2dstsize;

#define G2SB_G2SRCPS_OFFSET 0x39
#define G2SB_G2SRCPS_RESET  0x00000000
typedef union g2sb_g2srcps_u {
    struct {
        unsigned int srcx:16;               /* SRCX[2:0] are ignored in SRCCD==0 (mono expansion), The first bit of the first byte (bit7 if HLMONO==0, or bit0 if HLMONO==1) alwaysexpand to DSTX,DSTY   */
        unsigned int srcy:16;
    };

    uint32_t reg32;
} g2sb_g2srcps;

#define G2SB_G2DSTPS_OFFSET 0x3A
#define G2SB_G2DSTPS_RESET  0x00000000
typedef union g2sb_g2dstps_u {
    struct {
        unsigned int dstx:16;               /* NOTE: when ALPTYPE is PL1BPP, DSTX[2:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL2BPP, DSTX[1:0] must be zero, see bug 344489 NOTE: when ALPTYPE is PL4BPP, DSTX[0:0] must be zero, see bug 344489 */
        unsigned int dsty:16;
    };

    uint32_t reg32;
} g2sb_g2dstps;

#define G2SB_G2CBDES_OFFSET 0x3B
#define G2SB_G2CBDES_RESET  0x00000000
typedef union g2sb_g2cbdes_u {
    struct {
        unsigned int cbcount:8;             /* This specifies the number of buffers incircular buffer feature                    */
        unsigned int undefined_bits_8_15:8;
        unsigned int cbline:15;             /* vertical line number in one buffer */
        unsigned int topclip:1;             /* top clipping at the first buffer, (buffer start)  refer to TOP_CBLINE in G2CBDES2 0= disable  */
    };

    uint32_t reg32;
} g2sb_g2cbdes;

#define G2SB_G2CBSTRIDE_OFFSET 0x3C
#define G2SB_G2CBSTRIDE_RESET  0x00000000
typedef union g2sb_g2cbstride_u {
    struct {
        unsigned int cbstride:24;           /* Video Buffer Luma(or RGB) Buffer Stride  This is luma buffer stride (in bytes) */
        unsigned int undefined_bits_24_29:6;
        unsigned int cbuvstride:2;          /* Chroma Buffer Stride default is half of luma   00= 1/2 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 2 bytes.   01= Equal to Luma Buffer Stride   10= 1/4 of Luma Buffer Stride; in this       case, Luma Buffer Stride should be       multiple of 4 bytes.   1x= Reserved */
    };

    uint32_t reg32;
} g2sb_g2cbstride;

#define G2SB_G2LINESETTING_OFFSET 0x3D
#define G2SB_G2LINESETTING_RESET  0x00000000
typedef union g2sb_g2linesetting_u {
    struct {
        unsigned int gamma:21;
        unsigned int undefined_bits_21_23:3;
        unsigned int major:1;               /* 0:xmajor 1: y major */
        unsigned int linexdir:1;
        unsigned int lineydir:1;
        unsigned int droplastp:1;           /* draw last pixel or not */
        unsigned int lineuseoctant:1;       /* use OCTANTS in G2LINEDELTAN register instead of MAJOR LINEXDIR LINEYDIR */
        unsigned int octants:3;             /* 000 octant 0001 octant 1010 octant 2011 octant 3100 octant 4101 octant 5110 octant 6111 octant 7 */
    };

    uint32_t reg32;
} g2sb_g2linesetting;

#define G2SB_G2LINEDELTAN_OFFSET 0x3E
#define G2SB_G2LINEDELTAN_RESET  0x00000000
typedef union g2sb_g2linedeltan_u {
    struct {
        unsigned int deltan:21;
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} g2sb_g2linedeltan;

#define G2SB_G2LINEDELTAM_OFFSET 0x3F
#define G2SB_G2LINEDELTAM_RESET  0x00000000
typedef union g2sb_g2linedeltam_u {
    struct {
        unsigned int deltam:21;
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} g2sb_g2linedeltam;

#define G2SB_G2LINEPOS_OFFSET 0x40
#define G2SB_G2LINEPOS_RESET  0x00000000
typedef union g2sb_g2linepos_u {
    struct {
        unsigned int linexpos:16;
        unsigned int lineypos:16;
    };

    uint32_t reg32;
} g2sb_g2linepos;

#define G2SB_G2LINELEN_OFFSET 0x41
#define G2SB_G2LINELEN_RESET  0x00000000
typedef union g2sb_g2linelen_u {
    struct {
        unsigned int linelen:15;
        unsigned int undefined_bits_15_31:17;
    };

    uint32_t reg32;
} g2sb_g2linelen;

#define G2SB_G2CSCFOURTH_OFFSET 0x42
#define G2SB_G2CSCFOURTH_RESET  0x00000000
typedef union g2sb_g2cscfourth_u {
    struct {
        unsigned int g2u:9;                 /* multiplier for G for U generation.This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.291 (decimal) or 0x125 For any other combination this parameter is ignored */
        unsigned int undefined_bits_9_15:7;
        unsigned int g2v:9;                 /* multiplier for G for V generation. This parameter consists of a sign bit and 8-bit magnitude (s1.7) For RGB->YUV the recommended value is -0.368 (decimal) or 0x12F For any other combination this parameter is ignored */
        unsigned int undefined_bits_25_31:7;
    };

    uint32_t reg32;
} g2sb_g2cscfourth;

#define G2SB_G2SRCST_B_OFFSET 0x43
#define G2SB_G2SRCST_B_RESET  0x00000000
typedef union g2sb_g2srcst_b_u {
    struct {
        unsigned int srcs_b:16;             /* Source Stride B */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} g2sb_g2srcst_b;

#define G2SB_G2UVSTRIDE_OFFSET 0x44
#define G2SB_G2UVSTRIDE_RESET  0x00000000
typedef union g2sb_g2uvstride_u {
    struct {
        unsigned int uvstride:16;
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} g2sb_g2uvstride;

#define G2SB_G2CBDES2_OFFSET 0x45
#define G2SB_G2CBDES2_RESET  0x00000000
typedef union g2sb_g2cbdes2_u {
    struct {
        unsigned int top_cbline:15;         /* Circular buffer top clipping enabled, the first buffer line num */
        unsigned int undefined_bits_15_31:17;
    };

    uint32_t reg32;
} g2sb_g2cbdes2;

#define G2SB_G2TILEMODE_OFFSET 0x46
#define G2SB_G2TILEMODE_RESET  0x00000000
typedef union g2sb_g2tilemode_u {
    struct {
        unsigned int src_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_1_3:3;
        unsigned int src_uv_tile_mode:1;    /* UV surface, ignored in RGB mode */
        unsigned int undefined_bits_5_7:3;
        unsigned int pat_y_tile_mode:1;     /* Y or RGB surface */
        unsigned int undefined_bits_9_11:3;
        unsigned int pat_uv_tile_mode:1;    /* UNUSED */
        unsigned int undefined_bits_13_15:3;
        unsigned int dst_rd_tile_mode:1;    /* Same as destination write unless DST_RD_WR_SEP (not supported) */
        unsigned int undefined_bits_17_19:3;
        unsigned int dst_wr_tile_mode:1;    /* destination surface */
        unsigned int undefined_bits_21_31:11;
    };

    uint32_t reg32;
} g2sb_g2tilemode;

#define G2SB_G2PATBASE_OFFSET 0x47
#define G2SB_G2PATBASE_RESET  0x00000000
typedef union g2sb_g2patbase_u {
    struct {
        unsigned int pat_base:32;           /* pattern base address in tile mode,  PATBA is the linear address where pixel start */
    };

    uint32_t reg32;
} g2sb_g2patbase;

#define G2SB_G2SRCBA_SB_SURFBASE_OFFSET 0x48
#define G2SB_G2SRCBA_SB_SURFBASE_RESET  0x00000000
typedef union g2sb_g2srcba_sb_surfbase_u {
    struct {
        unsigned int src_addr:32;           /* surface address corresponding to G2SRCBA:    -base of interleaved sources (RGB, YUV)    -base of Y plane Only used by the StretchBlit Engine */
    };

    uint32_t reg32;
} g2sb_g2srcba_sb_surfbase;

#define G2SB_G2DSTBA_SB_SURFBASE_OFFSET 0x49
#define G2SB_G2DSTBA_SB_SURFBASE_RESET  0x00000000
typedef union g2sb_g2dstba_sb_surfbase_u {
    struct {
        unsigned int dst_addr:32;           /* surface address corresponding to G2DSTBA Only used by the StretchBlit Engine */
    };

    uint32_t reg32;
} g2sb_g2dstba_sb_surfbase;

#define G2SB_G2DSTBA_B_SB_SURFBASE_OFFSET 0x4A
#define G2SB_G2DSTBA_B_SB_SURFBASE_RESET  0x00000000
typedef union g2sb_g2dstba_b_sb_surfbase_u {
    struct {
        unsigned int dst_b_addr:32;         /* surface address corresponding to G2DSTBA_B Only used by the StretchBlit Engine, and G2CONTROLSB.DBSEL() is enabled */
    };

    uint32_t reg32;
} g2sb_g2dstba_b_sb_surfbase;

#define G2SB_G2VBA_A_SB_SURFBASE_OFFSET 0x4B
#define G2SB_G2VBA_A_SB_SURFBASE_RESET  0x00000000
typedef union g2sb_g2vba_a_sb_surfbase_u {
    struct {
        unsigned int v_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of V plane Only used by the StretchBlit Engine */
    };

    uint32_t reg32;
} g2sb_g2vba_a_sb_surfbase;

#define G2SB_G2UBA_A_SB_SURFBASE_OFFSET 0x4C
#define G2SB_G2UBA_A_SB_SURFBASE_RESET  0x00000000
typedef union g2sb_g2uba_a_sb_surfbase_u {
    struct {
        unsigned int u_addr:32;             /* surface address corresponding to G2VBA     used for YUV 4:2:0 planar, base of U plane Only used by the StretchBlit Engine */
    };

    uint32_t reg32;
} g2sb_g2uba_a_sb_surfbase;

#define G2SB_SWITCH_G2INTERRUPT_OFFSET 0xF000
#define G2SB_SWITCH_G2INTERRUPT_RESET  0x00000000
typedef union g2sb_switch_g2interrupt_u {
    struct {
        unsigned int ctxsw_int:1;
        unsigned int vi_done:1;
        unsigned int gr2d_idle:1;
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} g2sb_switch_g2interrupt;

#define G2SB_SWITCH_G2INTENABLE_OFFSET 0xF001
#define G2SB_SWITCH_G2INTENABLE_RESET  0x00000000
typedef union g2sb_switch_g2intenable_u {
    struct {
        unsigned int ctxsw_int_enable:1;
        unsigned int vi_done_enable:1;
        unsigned int gr2d_idle_enable:1;
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} g2sb_switch_g2intenable;

#define G2SB_SWITCH_G2CURRENTCONTEXT_OFFSET 0xF002
#define G2SB_SWITCH_G2CURRENTCONTEXT_RESET  0x00000000
#define G2SB_SWITCH_G2CURRENTCONTEXT_WRMASK 0xFFFFFF00
typedef union g2sb_switch_g2currentcontext_u {
    struct {
        unsigned int curr_context:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} g2sb_switch_g2currentcontext;

#define G2SB_SWITCH_G2NXTCXTSWITCH_OFFSET 0xF003
#define G2SB_SWITCH_G2NXTCXTSWITCH_RESET  0x00000000
#define G2SB_SWITCH_G2NXTCXTSWITCH_WRMASK 0xFFF0FC00
typedef union g2sb_switch_g2nxtcxtswitch_u {
    struct {
        unsigned int next_class:10;
        unsigned int undefined_bits_10_15:6;
        unsigned int next_channel:4;
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} g2sb_switch_g2nxtcxtswitch;

#define G2SB_SWITCH_G2GLOBALCONTROL_OFFSET 0xF004
#define G2SB_SWITCH_G2GLOBALCONTROL_RESET  0x00000000
typedef union g2sb_switch_g2globalcontrol_u {
    struct {
        unsigned int dst_addr_idx_ini:2;    /* 31:8 rw CLOCKFREEON init = 0 */
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} g2sb_switch_g2globalcontrol;

#define G2SB_SWITCH_G2GLOBALCONTROLB_OFFSET 0xF005
#define G2SB_SWITCH_G2GLOBALCONTROLB_RESET  0x000000E1
typedef union g2sb_switch_g2globalcontrolb_u {
    struct {
        unsigned int octan_bias:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} g2sb_switch_g2globalcontrolb;

#define G2SB_SWITCH_G2WORKINGSTAT_OFFSET 0xF006
#define G2SB_SWITCH_G2WORKINGSTAT_RESET  0x00000000
#define G2SB_SWITCH_G2WORKINGSTAT_WRMASK 0xFFFFF000
typedef union g2sb_switch_g2workingstat_u {
    struct {
        unsigned int working_channel:4;
        unsigned int working_ctx:8;
        unsigned int undefined_bits_12_31:20;
    };

    uint32_t reg32;
} g2sb_switch_g2workingstat;

#define G2SB_SWITCH_G2BUFTHRESHOLD_OFFSET 0xF007
#define G2SB_SWITCH_G2BUFTHRESHOLD_RESET  0x00000000
typedef union g2sb_switch_g2bufthreshold_u {
    struct {
        unsigned int buffer_count_threshold:4;
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} g2sb_switch_g2bufthreshold;

#define G2SB_SWITCH_CLKEN_OVERIDE_OFFSET 0xF008
#define G2SB_SWITCH_CLKEN_OVERIDE_RESET  0x00000000
typedef union g2sb_switch_clken_overide_u {
    struct {
        unsigned int context0_clken_ovr:1;
        unsigned int context1_clken_ovr:1;
        unsigned int context2_clken_ovr:1;
        unsigned int context3_clken_ovr:1;
        unsigned int context4_clken_ovr:1;
        unsigned int context5_clken_ovr:1;
        unsigned int context6_clken_ovr:1;
        unsigned int context7_clken_ovr:1;
        unsigned int con_clken_ovr:1;
        unsigned int dstw_clken_ovr:1;      /* It forces ccw_g2dw2mc_clk on too */
        unsigned int bblt_clken_ovr:1;
        unsigned int src_clken_ovr:1;
        unsigned int srcr_clken_ovr:1;      /* It forces cbr_g2sr2mc_clk on too */
        unsigned int patr_clken_ovr:1;      /* It forces cbr_g2pr2mc_clk on too */
        unsigned int dstr_clken_ovr:1;
        unsigned int fr_clken_ovr:1;
        unsigned int line_clken_ovr:1;
        unsigned int liner_clken_ovr:1;
        unsigned int vcaa_clken_ovr:1;
        unsigned int g2sr2mc_clken_ovr:1;
        unsigned int g2dr2mc_clken_ovr:1;
        unsigned int g2pr2mc_clken_ovr:1;
        unsigned int sb_clken_ovr:1;
        unsigned int undefined_bits_23_31:9;
    };

    uint32_t reg32;
} g2sb_switch_clken_overide;

#define G2SB_SWITCH_G2_MCCIF_FIFOCTRL_OFFSET 0xF009
#define G2SB_SWITCH_G2_MCCIF_FIFOCTRL_RESET  0x00000000
typedef union g2sb_switch_g2_mccif_fifoctrl_u {
    struct {
        unsigned int g2_mccif_wrcl_mcle2x:1;
        unsigned int g2_mccif_rdmc_rdfast:1;
        unsigned int g2_mccif_wrmc_clle2x:1;
        unsigned int g2_mccif_rdcl_rdfast:1;
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} g2sb_switch_g2_mccif_fifoctrl;

#define G2SB_SWITCH_TIMEOUT_WCOAL_G2_OFFSET 0xF00A
#define G2SB_SWITCH_TIMEOUT_WCOAL_G2_RESET  0x00000000
typedef union g2sb_switch_timeout_wcoal_g2_u {
    struct {
        unsigned int g2dw_wcoal_tmval:4;
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} g2sb_switch_timeout_wcoal_g2;

typedef struct gr2d_ctx_state {
    DEFINE_REG32(g2sb_incr_syncpt_cntrl);
    DEFINE_REG32(g2sb_incr_syncpt_error);
    DEFINE_REG32(g2sb_g2classchannel_regonly);
    DEFINE_REG32(g2sb_g2trigger);
    DEFINE_REG32(g2sb_g2trigger1);
    DEFINE_REG32(g2sb_g2trigger2);
    DEFINE_REG32(g2sb_g2cmdsel);
    DEFINE_REG32(g2sb_g2raise);
    DEFINE_REG32(g2sb_g2hostset);
    DEFINE_REG32(g2sb_g2hostfifo);
    DEFINE_REG32(g2sb_g2vdda);
    DEFINE_REG32(g2sb_g2vddaini);
    DEFINE_REG32(g2sb_g2hdda);
    DEFINE_REG32(g2sb_g2hddainils);
    DEFINE_REG32(g2sb_g2cscfirst);
    DEFINE_REG32(g2sb_g2cscsecond);
    DEFINE_REG32(g2sb_g2cscthird);
    DEFINE_REG32(g2sb_g2cmkeyl);
    DEFINE_REG32(g2sb_g2cmkeyu);
    DEFINE_REG32(g2sb_g2uba_a);
    DEFINE_REG32(g2sb_g2vba_a);
    DEFINE_REG32(g2sb_g2sbformat);
    DEFINE_REG32(g2sb_g2controlsb);
    DEFINE_REG32(g2sb_g2controlsecond);
    DEFINE_REG32(g2sb_g2controlmain);
    DEFINE_REG32(g2sb_g2ropfade);
    DEFINE_REG32(g2sb_g2alphablend);
    DEFINE_REG32(g2sb_g2cliplefttop);
    DEFINE_REG32(g2sb_g2cliprightbot);
    DEFINE_REG32(g2sb_g2patpack);
    DEFINE_REG32(g2sb_g2patpack_size);
    DEFINE_REG32(g2sb_g2patba);
    DEFINE_REG32(g2sb_g2patos);
    DEFINE_REG32(g2sb_g2patbgc);
    DEFINE_REG32(g2sb_g2patfgc);
    DEFINE_REG32(g2sb_g2patkey);
    DEFINE_REG32(g2sb_g2dstba);
    DEFINE_REG32(g2sb_g2dstba_b);
    DEFINE_REG32(g2sb_g2dstba_c);
    DEFINE_REG32(g2sb_g2dstst);
    DEFINE_REG32(g2sb_g2srcpack);
    DEFINE_REG32(g2sb_g2srcpack_size);
    DEFINE_REG32(g2sb_g2srcba);
    DEFINE_REG32(g2sb_g2srcba_b);
    DEFINE_REG32(g2sb_g2srcst);
    DEFINE_REG32(g2sb_g2srcbgc);
    DEFINE_REG32(g2sb_g2srcfgc);
    DEFINE_REG32(g2sb_g2srckey);
    DEFINE_REG32(g2sb_g2srcsize);
    DEFINE_REG32(g2sb_g2dstsize);
    DEFINE_REG32(g2sb_g2srcps);
    DEFINE_REG32(g2sb_g2dstps);
    DEFINE_REG32(g2sb_g2cbdes);
    DEFINE_REG32(g2sb_g2cbstride);
    DEFINE_REG32(g2sb_g2linesetting);
    DEFINE_REG32(g2sb_g2linedeltan);
    DEFINE_REG32(g2sb_g2linedeltam);
    DEFINE_REG32(g2sb_g2linepos);
    DEFINE_REG32(g2sb_g2linelen);
    DEFINE_REG32(g2sb_g2cscfourth);
    DEFINE_REG32(g2sb_g2srcst_b);
    DEFINE_REG32(g2sb_g2uvstride);
    DEFINE_REG32(g2sb_g2cbdes2);
    DEFINE_REG32(g2sb_g2tilemode);
    DEFINE_REG32(g2sb_g2patbase);
    DEFINE_REG32(g2sb_g2srcba_sb_surfbase);
    DEFINE_REG32(g2sb_g2dstba_sb_surfbase);
    DEFINE_REG32(g2sb_g2dstba_b_sb_surfbase);
    DEFINE_REG32(g2sb_g2vba_a_sb_surfbase);
    DEFINE_REG32(g2sb_g2uba_a_sb_surfbase);
} gr2d_ctx;

typedef struct gr2d_regs_state {
    gr2d_ctx ctx[7];
    DEFINE_REG32(g2sb_switch_g2interrupt);
    DEFINE_REG32(g2sb_switch_g2intenable);
    DEFINE_REG32(g2sb_switch_g2currentcontext);
    DEFINE_REG32(g2sb_switch_g2nxtcxtswitch);
    DEFINE_REG32(g2sb_switch_g2globalcontrol);
    DEFINE_REG32(g2sb_switch_g2globalcontrolb);
    DEFINE_REG32(g2sb_switch_g2workingstat);
    DEFINE_REG32(g2sb_switch_g2bufthreshold);
    DEFINE_REG32(g2sb_switch_clken_overide);
    DEFINE_REG32(g2sb_switch_g2_mccif_fifoctrl);
    DEFINE_REG32(g2sb_switch_timeout_wcoal_g2);
} gr2d_regs;

typedef struct tegra_gr2d_state {
    SysBusDevice parent_obj;

    MemoryRegion iomem;
    gr2d_regs regs;
    struct host1x_module gr2d_module[5];
    struct host1x_module gr2d_sb_module[3];
} tegra_gr2d;

void gr2d_write(struct host1x_module *module, uint32_t offset, uint32_t data);
uint32_t gr2d_read(struct host1x_module *module, uint32_t offset);
void process_2d(gr2d_ctx *ctx, int sb_g2);

#endif // TEGRA_GR2D_H
