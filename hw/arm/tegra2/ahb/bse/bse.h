/*
 * ARM NVIDIA Tegra2 emulation.
 *
 * Copyright (c) 2014-2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* Autogenerated from TRM v02p */

#ifndef TEGRA_BSE_H
#define TEGRA_BSE_H

#define ICMDQUE_WR_OFFSET 0x0
#define ICMDQUE_WR_RESET  0x00000000
typedef union icmdque_wr_u {
    struct {
        unsigned int icmdque_wdata:32;
    };

    uint32_t reg32;
} icmdque_wr_t;

typedef union bse_cmd_setup_table {
    struct {
        unsigned int key_table_phy_addr:17;
        unsigned int cmd1:4;
        unsigned int undefined_bits:2;
        unsigned int cmd2:1;
        unsigned int cmd3:2;
        unsigned int opcode:6;
    };

    uint32_t reg32;
} bse_cmd_setup_table_t;

typedef union bse_cmd_block_count {
    struct {
        unsigned int block_count:26;
        unsigned int opcode:6;
    };

    uint32_t reg32;
} bse_cmd_block_count_t;

#define CMDQUE_CONTROL_OFFSET 0x8
#define CMDQUE_CONTROL_RESET  0x00000703
typedef union cmdque_control_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int src_stm_sel:1;         /* Source Stream interface select 0: through CIF (SDRAM only), 1: through AHB (SDRAM/IRAM) */
        unsigned int dst_stm_sel:1;         /* Destination Stream interface select 0: through CIF (SDRAM only), 1: through AHB (SDRAM/IRAM) */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} cmdque_control_t;

#define INTR_STATUS_OFFSET 0x18
#define INTR_STATUS_RESET  0x00000158
#define INTR_STATUS_WRMASK 0xFFFFFDF6
typedef union intr_status_u {
    struct {
        unsigned int engine_busy:1;         /* AES busy (RO) */
        unsigned int undefined_bits_1_2:2;
        unsigned int icq_empty:1;           /* Interactive command queue is empty (RO) */
        unsigned int undefined_bits_4_8:5;
        unsigned int dma_busy:1;            /* DMA engine is still busy (asserted by DMASetup and de-asserted by DMAFinish) (RO) */
        unsigned int undefined_bits_10_31:22;
    };

    uint32_t reg32;
} intr_status_t;

#define BSE_CONFIG_OFFSET 0x44
#define BSE_CONFIG_RESET  0xFFFF0D28
typedef union bse_config_u {
    struct {
        unsigned int bse_mode_sel:5;        /* 00000: CRYPTO mode */
        unsigned int undefined_bits_5_9:5;
        unsigned int endian_enb:1;          /* Must be set to 1. */
        unsigned int undefined_bits_11_31:21;
    };

    uint32_t reg32;
} bse_config_t;

#define SECURE_DEST_ADDR_OFFSET 0x100
#define SECURE_DEST_ADDR_RESET  0x00000000
typedef union secure_dest_addr_u {
    struct {
        unsigned int secure_dest_addr:32;   /* SECURE engine: write back destination write address */
    };

    uint32_t reg32;
} secure_dest_addr_t;

#define SECURE_INPUT_SELECT_OFFSET 0x104
#define SECURE_INPUT_SELECT_RESET  0x10800000
typedef union secure_input_select_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int secure_hash_dest:1;    /* CYRPTO hash destination, this is valid only when SECURE_HASH_ENB = 1 0: Do not write output to memory pointed by destination address.    Data can be read from HASH_RESULT 1: Write final 128-bit output to memory pointed by destination address */
        unsigned int secure_hash_enb:1;     /* CYRPTO hash enable */
        unsigned int secure_xor_pos:2;      /* CRYPTO XOR position 0x: Bypass 10: top, before CRYPTO 11: bottom, after CRYPTO */
        unsigned int secure_input_sel:2;    /* CRYPTO input select 00: From AHB input vector 01: reserved 10: Init Vector for first round and CRYPTO output for the rest rounds 11: Counter */
        unsigned int secure_vctram_sel:2;   /* Vector RAM select 00: From AHB input vector 01: reserved 10: Init Vector for first round and CRYPTO output for the rest rounds 11: Init Vector for the first round and previous AHB input for the rest rounds */
        unsigned int secure_core_sel:1;     /* CRYPTO/inv-CRYPTO core selection (use for shiftrow direction) */
        unsigned int secure_iv_select:1;    /* SECURE engine: Init vector select */
        unsigned int secure_rng_enb:1;      /* SECURE engine: random number generator enable */
        unsigned int undefined_bits_12_16:4;
        unsigned int input_key_len:12;
        unsigned int input_alg_sel:1;
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} secure_input_select_t;

#define SECURE_CONFIG_OFFSET 0x108
#define SECURE_CONFIG_RESET  0x00000000
typedef union secure_config_u {
    struct {
        unsigned int undefined_bits_0_19:20;
        unsigned int secure_key_index:5;    /* 5-bit index to select between the 8-keys(value greater than 7 is reserved) */
        unsigned int undefined_bits_25_31:7;
    };

    uint32_t reg32;
} secure_config_t;

#define SECURE_CONFIG_EXT_OFFSET 0x10C
#define SECURE_CONFIG_EXT_RESET  0x00010000
typedef union secure_config_ext_u {
    struct {
        unsigned int undefined_bits_0_14:15;
        unsigned int secure_key_sch_dis:1;  /* Must be set to 0. Anything else is illegal. */
        unsigned int undefined_bits_16_23:8;
        unsigned int secure_offset_cnt:8;   /* CRYPTO encryption/decryption with 16B*N offset. 0: every 16B is encrypted/decrypted N: first 16B is encrypted/decrypted and N*16B is not */
    };

    uint32_t reg32;
} secure_config_ext_t;

#define SECURE_SECURITY_OFFSET 0x110
#define SECURE_SECURITY_RESET  0x00000006
typedef union secure_security_u {
    struct {
        unsigned int secure_eng_dis:1;      /* Sticky bit. When this value is "1", crypto engine will be disabled. Software will not be able to use the crypto engine until the next system reset. */
        unsigned int key_sched_read:1;      /* Sticky bit. Must be set to 0. */
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} secure_security_t;

#define SECURE_HASH_RESULT0_OFFSET 0x120
#define SECURE_HASH_RESULT_RESET  0x00000000
typedef union secure_hash_result_u {
    struct {
        unsigned int secure_hash_result:32;/* CRYPTO Hash result */
    };

    uint32_t reg32;
} secure_hash_result_t;

#define SECURE_HASH_RESULT1_OFFSET 0x124

#define SECURE_HASH_RESULT2_OFFSET 0x128

#define SECURE_HASH_RESULT3_OFFSET 0x12C

#define SECURE_SEC_SEL0_OFFSET 0x140
#define SECURE_SEC_SEL_RESET  0x0000001F
typedef union secure_sec_sel_u {
    struct {
        unsigned int keyread_enb:1;        /* Sticky bit, When set to "0", it will not be possible to change the value of this bit until the next system reset. When this value is "0", software will not be able to read back key 0 and original initialization vector 0 */
        unsigned int keyupdate_enb:1;      /* Sticky bit, When set to "0", it will not be possible to change the value of this bit until the next system reset. When this value is "0", software will not be able to update key 0 and original initialization vector 0. */
        unsigned int ivread_enb:1;         /* Sticky bit, When set to "0", it will not be possible to change the value of this bit until the next system reset. When this value is "0", software will not be able to read back the current and updated initialization vector 0. */
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} secure_sec_sel_t;

#define SECURE_SEC_SEL1_OFFSET 0x144

#define SECURE_SEC_SEL2_OFFSET 0x148

#define SECURE_SEC_SEL3_OFFSET 0x14C

#define SECURE_SEC_SEL4_OFFSET 0x150

#define SECURE_SEC_SEL5_OFFSET 0x154

#define SECURE_SEC_SEL6_OFFSET 0x158

#define SECURE_SEC_SEL7_OFFSET 0x15C

#define CMD_BLKSTARTENGINE  0x0E
#define CMD_DMASETUP        0x10
#define CMD_DMACOMPLETE     0x11
#define CMD_SETTABLE        0x15
#define CMD_MEMDMAVD        0x22

#define SUBCMD_VRAM_SEL             0x1
#define SUBCMD_CRYPTO_TABLE_SEL     0x3
#define SUBCMD_KEY_SCHED_TABLE_SEL  0x4
#define SUBCMD_KEY_TABLE_SEL        0x8

#define XOR_DISABLED    0
#define XOR_TOP         2
#define XOR_BOTTOM      3

#define TABLE_IV_OFFSET 240
#define TABLE_SIZE      256

#define SLOTS_MAX_NB    8

#define DEFINE_REG32(reg) reg##_t reg

typedef struct tegra_bse_state {
    SysBusDevice parent_obj;

    qemu_irq irq;

    uint32_t state;
    uint8_t aes_key[SLOTS_MAX_NB][32];
    uint8_t aes_iv[SLOTS_MAX_NB][AES_BLOCK_SIZE];
    uint32_t src_addr;
    bool has_key_sched_gen;
    uint8_t hw_key_sched_length;

    MemoryRegion iomem;
    DEFINE_REG32(cmdque_control);
    DEFINE_REG32(intr_status);
    DEFINE_REG32(bse_config);
    DEFINE_REG32(secure_dest_addr);
    DEFINE_REG32(secure_input_select);
    DEFINE_REG32(secure_config);
    DEFINE_REG32(secure_config_ext);
    DEFINE_REG32(secure_security);
    DEFINE_REG32(secure_hash_result)[4];
    DEFINE_REG32(secure_sec_sel)[SLOTS_MAX_NB];
} tegra_bse;

#endif // TEGRA_BSE_H
