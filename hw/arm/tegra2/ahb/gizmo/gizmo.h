/*
 * ARM NVIDIA Tegra2 emulation.
 *
 * Copyright (c) 2014-2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* Autogenerated from TRM v02p */

#ifndef TEGRA_AHB_GIZMO_H
#define TEGRA_AHB_GIZMO_H

#define AHB_MEM_OFFSET 0xC
#define AHB_MEM_RESET  0x000200C1
typedef union ahb_mem_u {
    struct {
        unsigned int enable_split:1;        /* AHB slave gizmo (memory controller) - Enable splitting AHB transaction. 1 = enable 0 = disable; 0 = DISABLE; 1 = ENABLE */
        unsigned int force_to_ahb_single:1; /* AHB slave gizmo (memory controller) - Force all AHB transaction to single data request transaction 1 = force to single data transaction always. 0 = don’t force to single data transaction. 0 = NOT_SINGLE_DATA; 1 = SINGLE_DATA */
        unsigned int enb_fast_rearbitrate:1;/* AHB slave gizmo - Enable fast re-arbitration. 1 = allow AHB master re-arbitration as soon as the device returns one read data into the gizmos queue. 0 = allow AHB master re-arbitration only when the device returns all read data into the gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_3_5:3;
        unsigned int accept_ahb_wr_always:1;/* AHB slave gizmo (memory controller) - Accept AHB write request always. 1= always accept AHB write request without checking whether there is room in the queue to store the write data. Bypass Memory Controller AHB slave gizmo write queue. 0 = accept AHB write request only when there’s enough room in the queue to store all the write data. Memory controller AHB slave gizmos write queue is used in this case; 0 = ACCEPT_ON_CHECK; 1 = ACCEPT_ON_NOCHECK */
        unsigned int dont_split_ahb_wr:1;   /* AHB slave gizmo (memory controller) - don’t split AHB write transaction 1 =  don’t split AHB write transaction ever. 0 (and enable_split=1) = allow AHB write transaction to be split; 0 = ENABLE; 1 = DISABLE */
        unsigned int undefined_bits_8_15:8;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo (AHB-DMA) - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8 11 = burst-of-16; 0 = DMA_BURST_1WORDS; 1 = DMA_BURST_4WORDS; 2 = DMA_BURST_8WORDS; 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo (AHB-DMA) - Start AHB write request immediately 1 = start the AHB write request immediately as soon as the device has put one write data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_19_23:5;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter used to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} ahb_mem_t;

#define APB_DMA_OFFSET 0x10
#define APB_DMA_RESET  0x0000000A
typedef union apb_dma_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16; 0 = DMA_BURST_1WORDS; 1 = DMA_BURST_4WORDS; 2 = DMA_BURST_8WORDS; 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo (AHB-DMA) - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device has put one write data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int rd_data:1;             /* AHB master gizmo - Pack all AHB read data. 1 = wait for all requested read data to be in the AHB gizmos queue before returning the data back to the IP. 0 = transfer each read data from the AHB to the IP immediately; 0 = NO_WAIT; 1 = WAIT */
        unsigned int undefined_bits_20_23:4;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter used to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} apb_dma_t;

#define IDE_OFFSET 0x18
#define IDE_RESET  0x000200BF
typedef union ide_u {
    struct {
        unsigned int enable_split:1;        /* AHB slave gizmo - Enable splitting AHB transactions. 1 = enable, 0 = disable; 0 = DISABLE; 1 = ENABLE */
        unsigned int force_to_ahb_single:1; /* AHB slave gizmo - Force all AHB transaction to single data request transaction. 1 = force to single data transaction always. 0 = don’t force to single data transaction; 0 = NOT_SINGLE_DATA; 1 = SINGLE_DATA */
        unsigned int enb_fast_rearbitrate:1;/* AHB slave gizmo - Enable fast re-arbitration. 1 = allow AHB master re-arbitration as soon as the device returns one read data into the gizmos queue.0 = allow AHB master re-arbitration only when the device returns all read data into the gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int ip_wr_req_immediate:1; /* AHB slave gizmo Start write request to device immediately. 1 = start write request on the device side as soon as the AHB master puts data into the gizmos queue. 0 = start the device write request only when the AHB master has placed all write data into the gizmos queue */
        unsigned int max_ip_burstsize:2;    /* AHB slave gizmo Maximum allowed IP burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8.11 = burst-of-16; 0 = DMA_BURST_1WORDS; 1 = DMA_BURST_4WORDS; 2 = DMA_BURST_8WORDS; 3 = DMA_BURST_16WORDS */
        unsigned int accept_ahb_wr_always:1;/* AHB slave gizmo - Accept AHB write request always. 1 = always accept AHB write request without checking whether there is room in the queue to store the write data. 0 = accept AHB write request only when there’s enough room in the queue to store all the write data; 0 = ACCEPT_ON_CHECK; 1 = ACCEPT_ON_NOCHECK */
        unsigned int dont_split_ahb_wr:1;   /* AHB slave gizmo - Dont split AHB write transaction.  1 = dont split AHB write transaction  ever. 0 (and enable_split=1) = allow AHB write  transaction to be split. */
        unsigned int undefined_bits_8_15:8;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16; 0 = DMA_BURST_1WORDS; 1 = DMA_BURST_4WORDS; 2 = DMA_BURST_8WORDS; 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo (AHB-DMA) - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device has put one write data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int rd_data:1;             /* AHB master gizmo - Pack all AHB read data. 1 = wait for all requested read data to be in the AHB gizmos queue before returning the data back to the IP. 0 = transfer each read data from the AHB to the IP immediately; 0 = NO_WAIT; 1 = WAIT */
        unsigned int undefined_bits_20_23:4;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter use to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} ide_t;

#define USB_OFFSET 0x1C
#define USB_RESET  0x00020083
typedef union usb_u {
    struct {
        unsigned int enable_split:1;        /* AHB slave gizmo - Enable splitting AHB transactions. 1 = enable 0 = disable; 0 = DISABLE; 1 = ENABLE */
        unsigned int force_to_ahb_single:1; /* AHB slave gizmo - Force all AHB transaction to single data request transaction. 1 = force to single data transaction always. 0 =  don’t force to single data transaction; 0 = NOT_SINGLE_DATA; 1 = SINGLE_DATA */
        unsigned int enb_fast_rearbitrate:1;/* AHB slave gizmo - Enable fast re-arbitration. 1 = allow AHB master re-arbitration as soon as the device returns one read data into the gizmos queue. 0 = allow AHB master re-arbitration only when the device returns all read data into the gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int ip_wr_req_immediate:1; /* AHB slave gizmo Start write request to device immediately. 1 = start write request on the device side as soon as the AHB master puts data into the gizmos queue. 0 = start the device write request only when the AHB master has placed all write data into the gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_4_5:2;
        unsigned int accept_ahb_wr_always:1;/* AHB slave gizmo - Accept AHB write request always. 1 = always accept AHB write request without checking whether there is room in the queue to store the write data. 0 = accept AHB write request only when there’s enough room in the queue to store all the write data; 0 = ACCEPT_ON_CHECK; 1 = ACCEPT_ON_NOCHECK */
        unsigned int dont_split_ahb_wr:1;   /* AHB slave gizmo - Dont split AHB write transaction.  1 = dont split AHB write transaction  ever. 0 (and enable_split=1) = allow AHB write  transaction to be split. */
        unsigned int undefined_bits_8_15:8;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16; 0 = DMA_BURST_1WORDS; 1 = DMA_BURST_4WORDS; 2 = DMA_BURST_8WORDS; 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo (AHB-DMA) - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device has put one write data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int rd_data:1;             /* AHB master gizmo - Pack all AHB read data. 1 = wait for all requested read data to be in the AHB gizmos queue before returning the data back to the IP. 0 = transfer each read data from the AHB to the IP immediately; 0 = NO_WAIT; 1 = WAIT */
        unsigned int undefined_bits_20_23:4;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter used to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} usb_t;

#define AHB_XBAR_BRIDGE_OFFSET 0x20
#define AHB_XBAR_BRIDGE_RESET  0x0000008D
typedef union ahb_xbar_bridge_u {
    struct {
        unsigned int enable_split:1;        /* AHB slave gizmo - Enable splitting AHB transactions. 1 = enable 0 = disable; 0 = DISABLE; 1 = ENABLE */
        unsigned int force_to_ahb_single:1; /* AHB slave gizmo - Force all AHB transaction to single data request transaction. 1 = force to single data transaction always. 0 = don’t force to single data transaction; 0 = NOT_SINGLE_DATA; 1 = SINGLE_DATA */
        unsigned int enb_fast_rearbitrate:1;/* AHB slave gizmo - Enable fast re-arbitration. 1 = allow AHB master re-arbitration as soon as the device returns one read data into the gizmos queue. 0 = allow AHB master re-arbitration only when the device returns all read data into the gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int immediate:1;           /* AHB slave gizmo - Start write request to device immediately. 1 = start write request on the device side as soon as the AHB master puts data into the gizmos queue. 0 = start the device write request only when the AHB master has placed all write data into the gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int max_ip_burstsize:2;    /* AHB slave gizmo - Maximum allowed IP burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16; 0 = DMA_BURST_1WORDS; 1 = DMA_BURST_4WORDS; 2 = DMA_BURST_8WORDS; 3 = DMA_BURST_16WORDS */
        unsigned int accept_ahb_wr_always:1;/* AHB slave gizmo - Accept AHB write request always. 1 = always accept AHB write request without checking whether there is room in the queue to store the write data. 0 = accept AHB write request only when there’s enough room in the queue to store all the write data; 0 = ACCEPT_ON_CHECK; 1 = ACCEPT_ON_NOCHECK */
        unsigned int dont_split_ahb_wr:1;   /* AHB slave gizmo - Dont split AHB write transaction.  1 = dont split AHB write transaction ever.  0 (and enable_split=1) = allow AHB write  transaction to be split. */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} ahb_xbar_bridge_t;

#define CPU_AHB_BRIDGE_OFFSET 0x24
#define CPU_AHB_BRIDGE_RESET  0x00000006
typedef union cpu_ahb_bridge_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16; 0 = DMA_BURST_1WORDS; 1 = DMA_BURST_4WORDS; 2 = DMA_BURST_8WORDS; 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo (AHB-DMA) - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device has put one write data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int rd_data:1;             /* AHB master gizmo - Pack all AHB read data. 1 = wait for all requested read data to be in the AHB gizmos queue before returning the data back to the IP. 0 = transfer each read data from the AHB to the IP immediately; 0 = NO_WAIT; 1 = WAIT */
        unsigned int undefined_bits_20_23:4;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter use to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} cpu_ahb_bridge_t;

#define COP_AHB_BRIDGE_OFFSET 0x28
#define COP_AHB_BRIDGE_RESET  0x00000006
typedef union cop_ahb_bridge_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16; 0 = DMA_BURST_1WORDS; 1 = DMA_BURST_4WORDS; 2 = DMA_BURST_8WORDS; 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo (AHB-DMA) - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device has put one write data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int rd_data:1;             /* AHB master gizmo - Pack all AHB read data. 1 = wait for all requested read data to be in the AHB gizmos queue before returning the data back to the IP. 0 = transfer each read data from the AHB to the IP immediately; 0 = NO_WAIT; 1 = WAIT */
        unsigned int undefined_bits_20_23:4;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter use to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} cop_ahb_bridge_t;

#define XBAR_APB_CTLR_OFFSET 0x2C
#define XBAR_APB_CTLR_RESET  0x00000001
typedef union xbar_apb_ctlr_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int immediate:1;           /* AHB slave gizmo - Start write request to device immediately. 1 = start write request on the device side as soon as the AHB master puts data into the gizmos queue. 0 = start the device write request only when the AHB master has placed all write data into the gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int max_ip_burstsize:2;    /* AHB slave gizmo - Maximum allowed IP burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16; 0 = DMA_BURST_1WORDS; 1 = DMA_BURST_4WORDS; 2 = DMA_BURST_8WORDS; 3 = DMA_BURST_16WORDS */
        unsigned int undefined_bits_6_31:26;
    };

    uint32_t reg32;
} xbar_apb_ctlr_t;

#define VCP_AHB_BRIDGE_OFFSET 0x30
#define VCP_AHB_BRIDGE_RESET  0x00000006
typedef union vcp_ahb_bridge_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16. 0 = DMA_BURST_1WORDS 1 = DMA_BURST_4WORDS 2 = DMA_BURST_8WORDS 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo (AHB-DMA) - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device has put one write data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue. 0 = DISABLE 1 = ENABLE */
        unsigned int rd_data:1;             /* AHB master gizmo - Pack all AHB read data. 1 = wait for all requested read data to be in the AHB gizmos queue before returning the data back to the IP. 0 = transfer each read data from the AHB to the IP immediately. 0 = NO_WAIT 1 = WAIT */
        unsigned int undefined_bits_20_23:4;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter use to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} vcp_ahb_bridge_t;

#define NAND_OFFSET 0x3C
#define NAND_RESET  0x0000000A
typedef union nand_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16; 0 = DMA_BURST_1WORDS; 1 = DMA_BURST_4WORDS; 2 = DMA_BURST_8WORDS; 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo (AHB-DMA) - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device has put one write data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int rd_data:1;             /* AHB master gizmo - Pack all AHB read data. 1 = wait for all requested read data to be in the AHB gizmos queue before returning the data back to the IP. 0 = transfer each read data from the AHB to the IP immediately; 0 = NO_WAIT; 1 = WAIT */
        unsigned int undefined_bits_20_23:4;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter use to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} nand_t;

#define SDMMC4_OFFSET 0x44
#define SDMMC4_RESET  0x00020087
typedef union sdmmc4_u {
    struct {
        unsigned int enable_split:1;        /* AHB slave gizmo - Enable splitting AHB transactions. 1 = enable 0 = disable 0 = DISABLE 1 = ENABLE */
        unsigned int force_to_ahb_single:1; /* AHB slave gizmo - Force all AHB transaction to single data request transaction. 1 = force to single data transaction always. 0 = don’t force to single data transaction. 0 = NOT_SINGLE_DATA 1 = SINGLE_DATA */
        unsigned int enb_fast_rearbitrate:1;/* AHB slave gizmo - Enable fast re-arbitration. 1 = allow AHB master re-arbitration as soon as the device returns one read data into the gizmos queue. 0 = allow AHB master re-arbitration only when the device returns all read data into the gizmos queue. 0 = DISABLE; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_3_5:3;
        unsigned int accept_ahb_wr_always:1;/* AHB slave gizmo - Accept AHB write request always. 1 = always accept AHB write request without checking whether there is room in the queue to store the write data. 0 = accept AHB write request only when there’s enough room in the queue to store all the write data. 0 = ACCEPT_ON_CHECK 1 = ACCEPT_ON_NOCHECK */
        unsigned int dont_split_ahb_wr:1;   /* AHB slave gizmo - Dont split AHB write transaction. 1 = dont split AHB write transaction ever. 0 (and enable_split=1) = allow AHB write transaction to be split. 0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_8_15:8;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16. 0 = DMA_BURST_1WORDS 1 = DMA_BURST_4WORDS 2 = DMA_BURST_8WORDS 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device puts data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_19_23:5;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter use to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} sdmmc4_t;

#define XIO_OFFSET 0x48
#define XIO_RESET  0x00000004
typedef union xio_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16. 0 = DMA_BURST_1WORDS 1 = DMA_BURST_4WORDS 2 = DMA_BURST_8WORDS 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo (AHB-DMA) - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device has put one write data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue. 0 = DISABLE 1 = ENABLE */
        unsigned int rd_data:1;             /* AHB master gizmo - Pack all AHB read data. 1 = wait for all requested read data to be in the AHB gizmos queue before returning the data back to the IP. 0 = transfer each read data from the AHB to the IP immediately. 0 = NO_WAIT 1 = WAIT */
        unsigned int undefined_bits_20_23:4;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter use to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} xio_t;

#define BSEV_OFFSET 0x60
#define BSEV_RESET  0x00000002
typedef union bsev_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8 11 = burst-of-16; 0 = DMA_BURST_1WORDS; 1 = DMA_BURST_4WORDS; 2 = DMA_BURST_8WORDS; 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo (AHB-DMA) - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device has put one write data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue. NOTE: THIS SHOULD NEVER BE SET TO ENABLE (BSEV requires this bit to be 0); 0 = DISABLE; 1 = ENABLE */
        unsigned int rd_data:1;             /* AHB master gizmo - Pack all AHB read data. 1 = wait for all requested read data to be in the AHB gizmos queue before returning the data back to the IP. 0 = transfer each read data from the AHB to the IP immediately; 0 = NO_WAIT; 1 = WAIT */
        unsigned int undefined_bits_20_23:4;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter use to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} bsev_t;

#define BSEA_OFFSET 0x70
#define BSEA_RESET  0x00000002
typedef union bsea_u {
    struct {
        unsigned int undefined_bits_0_15:16;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16; 0 = DMA_BURST_1WORDS; 1 = DMA_BURST_4WORDS; 2 = DMA_BURST_8WORDS; 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device puts data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue. NOTE: THIS SHOULD NEVER BE SET TO ENABLE (BSEV requires this bit to be 0); 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_19_23:5;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter use to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} bsea_t;

#define NOR_OFFSET 0x74
#define NOR_RESET  0x00000085
typedef union nor_u {
    struct {
        unsigned int enable_split:1;        /* AHB slave gizmo - Enable splitting AHB transactions. 1 = enable 0 = disable; 0 = DISABLE; 1 = ENABLE */
        unsigned int force_to_ahb_single:1; /* AHB slave gizmo - Force all AHB transaction to single data request transaction. 1 = force to single data transaction always. 0 = don’t force to single data transaction; 0 = NOT_SINGLE_DATA; 1 = SINGLE_DATA */
        unsigned int enb_fast_rearbitrate:1;/* AHB slave gizmo - Enable fast re-arbitration. 1 = allow AHB master re-arbitration as soon as the device returns one read data into the gizmos queue. 0 = allow AHB master re-arbitration only when the device returns all read data into the gizmos queue; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_3_5:3;
        unsigned int accept_ahb_wr_always:1;/* AHB slave gizmo - Accept AHB write request always. 1 = always accept AHB write request without checking whether there is room in the queue to store the write data. 0 = accept AHB write request only when there’s enough room in the queue to store all the write data; 0 = ACCEPT_ON_CHECK; 1 = ACCEPT_ON_NOCHECK */
        unsigned int dont_split_ahb_wr:1;   /* AHB slave gizmo - Dont split AHB write transaction.  1 = dont split AHB  write transaction ever. 0 (and enable_split=1) = allow AHB write   transaction to be split. */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} nor_t;

#define USB2_OFFSET 0x78
#define USB2_RESET  0x00020087
typedef union usb2_u {
    struct {
        unsigned int enable_split:1;        /* AHB slave gizmo - Enable splitting AHB transactions. 1 = enable 0 = disable 0 = DISABLE 1 = ENABLE */
        unsigned int force_to_ahb_single:1; /* AHB slave gizmo - Force all AHB transaction to single data request transaction. 1 = force to single data transaction always. 0 = dont force to single data transaction. 0 = NOT_SINGLE_DATA 1 = SINGLE_DATA */
        unsigned int enb_fast_rearbitrate:1;/* AHB slave gizmo - Enable fast re-arbitration. 1 = allow AHB master re-arbitration as soon as the device returns one read data into the gizmos queue. 0 = allow AHB master re-arbitration only when the device returns all read data into the gizmos queue. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_3_5:3;
        unsigned int accept_ahb_wr_always:1;/* AHB slave gizmo - Accept AHB write request always.  1 = always accept AHB write request without checking whether there is room in the queue to store the write data. 0 = accept AHB write request only when theres  enough room in the queue to store all the write data. */
        unsigned int dont_split_ahb_wr:1;   /* AHB slave gizmo - Dont split AHB write transaction. 1 = dont split AHB write transaction ever. 0 (and enable_split=1) = allow AHB write transaction to be split. 0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_8_15:8;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16. 0 = DMA_BURST_1WORDS 1 = DMA_BURST_4WORDS 2 = DMA_BURST_8WORDS 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device puts data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_19_23:5;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter use to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} usb2_t;

#define USB3_OFFSET 0x7C
#define USB3_RESET  0x00020087
typedef union usb3_u {
    struct {
        unsigned int enable_split:1;        /* AHB slave gizmo - Enable splitting AHB transactions. 1 = enable 0 = disable 0 = DISABLE 1 = ENABLE */
        unsigned int force_to_ahb_single:1; /* AHB slave gizmo - Force all AHB transaction to single data request transaction. 1 = force to single data transaction always. 0 = dont force to single data transaction. 0 = NOT_SINGLE_DATA 1 = SINGLE_DATA */
        unsigned int enb_fast_rearbitrate:1;/* AHB slave gizmo - Enable fast re-arbitration. 1 = allow AHB master re-arbitration as soon as the device returns one read data into the gizmos queue. 0 = allow AHB master re-arbitration only when the device returns all read data into the gizmos queue. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_3_5:3;
        unsigned int accept_ahb_wr_always:1;/* AHB slave gizmo - Accept AHB write request always. 1 = always accept AHB write request without checking whether there is room in the queue to store the write data. 0 = accept AHB write request only when theres enough room in the queue to store all the write data. 0 = ACCEPT_ON_CHECK 1 = ACCEPT_ON_NOCHECK */
        unsigned int dont_split_ahb_wr:1;   /* AHB slave gizmo – Don’t split AHB write transaction. 1 = don’t split AHB write transaction ever. 0 (and enable_split=1) = allow AHB write transaction to be split. 0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_8_15:8;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16. 0 = DMA_BURST_1WORDS 1 = DMA_BURST_4WORDS 2 = DMA_BURST_8WORDS 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device puts data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_19_23:5;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter use to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} usb3_t;

#define SDMMC1_OFFSET 0x80
#define SDMMC1_RESET  0x00020087
typedef union sdmmc1_u {
    struct {
        unsigned int enable_split:1;        /* AHB slave gizmo - Enable splitting AHB transactions. 1 = enable 0 = disable 0 = DISABLE 1 = ENABLE */
        unsigned int force_to_ahb_single:1; /* AHB slave gizmo - Force all AHB transaction to single data request transaction. 1 = force to single data transaction always. 0 = dont force to single data transaction. 0 = NOT_SINGLE_DATA; 1 = SINGLE_DATA */
        unsigned int enb_fast_rearbitrate:1;/* AHB slave gizmo - Enable fast re-arbitration. 1 = allow AHB master re-arbitration as soon as the device returns one read data into the gizmos queue. 0 = allow AHB master re-arbitration only when the device returns all read data into the gizmos queue. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_3_5:3;
        unsigned int accept_ahb_wr_always:1;/* AHB slave gizmo - Accept AHB write request always. 1 = always accept AHB write request without checking whether there is room in the queue to store the write data. 0 = accept AHB write request only when theres enough room in the queue to store all the write data. 0 = ACCEPT_ON_CHECK 1 = ACCEPT_ON_NOCHECK */
        unsigned int dont_split_ahb_wr:1;   /* AHB slave gizmo - Dont split AHB write transaction. 1 = dont split AHB write transaction ever. 0 (and enable_split=1) = allow AHB write transaction to be split. 0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_8_15:8;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16. 0 = DMA_BURST_1WORDS 1 = DMA_BURST_4WORDS 2 = DMA_BURST_8WORDS 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device puts data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_19_23:5;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter use to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} sdmmc1_t;

#define SDMMC2_OFFSET 0x84
#define SDMMC2_RESET  0x00020087
typedef union sdmmc2_u {
    struct {
        unsigned int enable_split:1;        /* AHB slave gizmo - Enable splitting AHB transactions. 1 = enable 0 = disable 0 = DISABLE 1 = ENABLE */
        unsigned int force_to_ahb_single:1; /* AHB slave gizmo - Force all AHB transaction to single data request transaction. 1 = force to single data transaction always. 0 = dont force to single data transaction. 0 = NOT_SINGLE_DATA 1 = SINGLE_DATA */
        unsigned int enb_fast_rearbitrate:1;/* AHB slave gizmo - Enable fast re-arbitration. 1 = allow AHB master re-arbitration as soon as the device returns one read data into the gizmos queue. 0 = allow AHB master re-arbitration only when the device returns all read data into the gizmos queue. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_3_5:3;
        unsigned int accept_ahb_wr_always:1;/* AHB slave gizmo - Accept AHB write request always. 1 = always accept AHB write request without checking whether there is room in the queue to store the write data. 0 = accept AHB write request only when theres enough room in the queue to store all the write data. 0 = ACCEPT_ON_CHECK 1 = ACCEPT_ON_NOCHECK */
        unsigned int dont_split_ahb_wr:1;   /* AHB slave gizmo - Dont split AHB write transaction. 1 = dont split AHB write transaction ever. 0 (and enable_split=1) = allow AHB write transaction to be split. 0 = ENABLE;  1 = DISABLE */
        unsigned int undefined_bits_8_15:8;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16. 0 = DMA_BURST_1WORDS 1 = DMA_BURST_4WORDS 2 = DMA_BURST_8WORDS 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device puts data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue. 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_19_23:5;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter use to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} sdmmc2_t;

#define SDMMC3_OFFSET 0x88
#define SDMMC3_RESET  0x00020087
typedef union sdmmc3_u {
    struct {
        unsigned int enable_split:1;        /* AHB slave gizmo - Enable splitting AHB transactions. 1 = enable 0 = disable 0 = DISABLE; 1 = ENABLE */
        unsigned int force_to_ahb_single:1; /* AHB slave gizmo - Force all AHB transaction to single data request transaction. 1 = force to single data transaction always. 0 = dont force to single data transaction. 0 = NOT_SINGLE_DATA 1 = SINGLE_DATA */
        unsigned int enb_fast_rearbitrate:1;/* AHB slave gizmo - Enable fast re-arbitration. 1 = allow AHB master re-arbitration as soon as the device returns one read data into the gizmos queue. 0 = allow AHB master re-arbitration only when the device returns all read data into the gizmos queue. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_3_5:3;
        unsigned int accept_ahb_wr_always:1;/* AHB slave gizmo - Accept AHB write request always. 1 = always accept AHB write request without checking whether there is room in the queue to store the write data. 0 = accept AHB write request only when theres enough room in the queue to store all the write data. 0 = ACCEPT_ON_CHECK 1 = ACCEPT_ON_NOCHECK */
        unsigned int dont_split_ahb_wr:1;   /* AHB slave gizmo - Dont split AHB write transaction. 1 = dont split AHB write transaction ever. 0 (and enable_split=1) = allow AHB write transaction to be split. 0 = ENABLE; 1 = DISABLE */
        unsigned int undefined_bits_8_15:8;
        unsigned int max_ahb_burstsize:2;   /* AHB master gizmo - Maximum allowed AHB burst size. 00 = single transfer. 01 = burst-of-4. 10 = burst-of-8. 11 = burst-of-16. 0 = DMA_BURST_1WORDS 1 = DMA_BURST_4WORDS 2 = DMA_BURST_8WORDS 3 = DMA_BURST_16WORDS */
        unsigned int immediate:1;           /* AHB master gizmo - Start AHB write request immediately. 1 = start the AHB write request immediately as soon as the device puts data in the AHB gizmos queue. 0 = start the AHB write request only when all the write data has transferred from the device to the AHB gizmos queue. 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_19_23:5;
        unsigned int req_neg_cnt:8;         /* AHB master request negate count. This is an 8-bit counter use to indicate the minimum number of clk count between requests from this AHB master */
    };

    uint32_t reg32;
} sdmmc3_t;

#define MEM_PREFETCH_CFG_X_OFFSET 0xD8
#define MEM_PREFETCH_CFG_X_RESET  0x00000000
typedef union mem_prefetch_cfg_x_u {
    struct {
        unsigned int disable_check_size_master1:1;/*  */
        unsigned int disable_check_size_master2:1;/*  */
        unsigned int disable_check_size_master3:1;/*  */
        unsigned int disable_check_size_master4:1;/*  */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} mem_prefetch_cfg_x_t;

#define AHB_ARBITRATION_XBAR_CTRL_OFFSET 0xDC
#define AHB_ARBITRATION_XBAR_CTRL_RESET  0x00000000
typedef union ahb_arbitration_xbar_ctrl_u {
    struct {
        unsigned int post_dis:1;            /* SW writes to modify 0 = ENABLE 1 = DISABLE */
        unsigned int hold_dis:1;            /* By default CPU accesses to IRAMs will be held if there are any pending requests from the AHB to the IRAMs. This is done to avoid data coherency issues. If SW handles coherency then this can be turned off to improve performance.SW writes to modify 0 = ENABLE 1 = DISABLE */
        unsigned int undefined_bits_2_15:14;
        unsigned int mem_init_done:1;       /* SW should set this bit when memory has been initialized 0 = NOT_DONE 1 = DONE */
        unsigned int undefined_bits_17_31:15;
    };

    uint32_t reg32;
} ahb_arbitration_xbar_ctrl_t;

#define MEM_PREFETCH_CFG3_OFFSET 0xE0
#define MEM_PREFETCH_CFG3_RESET  0x14800800
#define MEM_PREFETCH_CFG3_WRMASK 0xFFE0FFFF
typedef union mem_prefetch_cfg3_u {
    struct {
        unsigned int inactivity_timeout:16; /* 2048 cycles */
        unsigned int spec_throttle:5;       /* not used for AP20 and beyond */
        unsigned int addr_bndry:5;          /* 2^(n+4) byte boundary. any value >16 will use n=16 */
        unsigned int ahb_mst_id:5;          /* AHBDMA master 0 = CPU 1 = COP 2 = VCP 3 = UNUSED_03 4 = IDE 5 = AHBDMA 6 = USB 7 = APBDMA 8 = XIO 9 = SDMMC1 10 = NAND_FLASH 11 = SNOR 12 = SDMMC4 13 = BSEV 14 = UNUSED_0E 15 = UNUSED_0F 12 = SDMMC4 16 = BSEA 17 = USB3 18 = USB2 19 = SDMMC2 20 = SDMMC3 21 = UNUSED_15 22 = UNUSED_16 23 = UNUSED_17 24 = UNUSED_18 25 = UNUSED_19 26 = UNUSED_1A 27 = UNUSED_1B 28 = UNUSED_1C 29 = UNUSED_1D 30 = UNUSED_1E 31 = UNUSED_1F */
        unsigned int enable:1;              /* 1=enable 0=disable */
    };

    uint32_t reg32;
} mem_prefetch_cfg3_t;

#define MEM_PREFETCH_CFG4_OFFSET 0xE4
#define MEM_PREFETCH_CFG4_RESET  0x14800800
#define MEM_PREFETCH_CFG4_WRMASK 0xFFE0FFFF
typedef union mem_prefetch_cfg4_u {
    struct {
        unsigned int inactivity_timeout:16; /* 2048 cycles */
        unsigned int spec_throttle:5;       /* not used for AP20 and beyond */
        unsigned int addr_bndry:5;          /* 2^(n+4) byte boundary. any value >16 will use n=16 */
        unsigned int ahb_mst_id:5;          /* AHBDMA master 0 = CPU 1 = COP 2 = VCP 3 = UNUSED_03 4 = IDE 5 = AHBDMA 6 = USB 7 = APBDMA; 8 = XIO 9 = SDMMC1 10 = NAND_FLASH 11 = SNOR 12 = SDMMC4 13 = BSEV 14 = UNUSED_0E 15 = UNUSED_0F 12 = SDMMC4 16 = BSEA 17 = USB3 18 = USB2 19 = SDMMC2 20 = SDMMC3 21 = UNUSED_15 22 = UNUSED_16 23 = UNUSED_17 24 = UNUSED_18 25 = UNUSED_19 26 = UNUSED_1A 27 = UNUSED_1B 28 = UNUSED_1C 29 = UNUSED_1D 30 = UNUSED_1E 31 = UNUSED_1F */
        unsigned int enable:1;              /* 1=enable 0=disable */
    };

    uint32_t reg32;
} mem_prefetch_cfg4_t;

#define AHB_AVP_PPCS_RD_COH_STATUS_OFFSET 0xE8
#define AHB_AVP_PPCS_RD_COH_STATUS_RESET  0x00000000
typedef union ahb_avp_ppcs_rd_coh_status_u {
    struct {
        unsigned int wrs_outstanding:1;
        unsigned int undefined_bits_1_15:15;
        unsigned int rds_outstanding:1;
        unsigned int undefined_bits_17_31:15;
    };

    uint32_t reg32;
} ahb_avp_ppcs_rd_coh_status_t;

#define MEM_PREFETCH_CFG1_OFFSET 0xEC
#define MEM_PREFETCH_CFG1_RESET  0x14800800
#define MEM_PREFETCH_CFG1_WRMASK 0xFFE0FFFF
typedef union mem_prefetch_cfg1_u {
    struct {
        unsigned int inactivity_timeout:16; /* 2048 cycles */
        unsigned int spec_throttle:5;       /* not used for Tegra 200 Series and beyond */
        unsigned int addr_bndry:5;          /* 2^(n+4) byte boundary. any value >16 will use n=16 */
        unsigned int ahb_mst_id:5;          /* AHBDMA master 0 = CPU 1 = COP 2 = VCP 3 = UNUSED_03 4 = IDE 5 = AHBDMA 6 = USB 7 = APBDMA 8 = XIO 9 = SDMMC1 10 = NAND_FLASH 11 = SNOR 12 = SDMMC4 13 = BSEV 14 = UNUSED_0E 15 = UNUSED_0F 12 = SDMMC4 16 = BSEA 17 = USB3 18 = USB2 19 = SDMMC2 20 = SDMMC3 21 = UNUSED_15 22 = UNUSED_16 23 = UNUSED_17 24 = UNUSED_18 25 = UNUSED_19 26 = UNUSED_1A 27 = UNUSED_1B 28 = UNUSED_1C 29 = UNUSED_1D 30 = UNUSED_1E 31 = UNUSED_1F */
        unsigned int enable:1;              /* 1=enable 0=disable */
    };

    uint32_t reg32;
} mem_prefetch_cfg1_t;

#define MEM_PREFETCH_CFG2_OFFSET 0xF0
#define MEM_PREFETCH_CFG2_RESET  0x18800800
#define MEM_PREFETCH_CFG2_WRMASK 0xFFE0FFFF
typedef union mem_prefetch_cfg2_u {
    struct {
        unsigned int inactivity_timeout:16; /*  */
        unsigned int spec_throttle:5;       /* not used for Tegra 200 Series and beyond */
        unsigned int addr_bndry:5;          /* 2^(n+4) byte boundary. any value >16 will use n=16 */
        unsigned int ahb_mst_id:5;          /* AHBDMA master 0 = CPU 1 = COP 2 = VCP 3 = UNUSED_03 4 = IDE 5 = AHBDMA 6 = USB 7 = APBDMA 8 = XIO 9 = SDMMC1 10 = NAND_FLASH 11 = SNOR 12 = SDMMC4 13 = BSEV 14 = UNUSED_0E 15 = UNUSED_0F 12 = SDMMC4 16 = BSEA 17 = USB3 18 = USB2 19 = SDMMC2 20 = SDMMC3 21 = UNUSED_15 22 = UNUSED_16 23 = UNUSED_17 24 = UNUSED_18 25 = UNUSED_19 26 = UNUSED_1A 27 = UNUSED_1B 28 = UNUSED_1C 29 = UNUSED_1D 30 = UNUSED_1E 31 = UNUSED_1F */
        unsigned int enable:1;              /* 1=enable 0=disable */
    };

    uint32_t reg32;
} mem_prefetch_cfg2_t;

#define AHB_AHBSLVMEM_STATUS_OFFSET 0xF4
#define AHB_AHBSLVMEM_STATUS_RESET  0x00000000
typedef union ahb_ahbslvmem_status_u {
    struct {
        unsigned int gizmo_ip_rdque_empty:1;
        unsigned int ppcs_rds_outstanding:1;
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} ahb_ahbslvmem_status_t;

#define AHB_ARBITRATION_AHB_MEM_WRQUE_MST_ID_OFFSET 0xF8
#define AHB_ARBITRATION_AHB_MEM_WRQUE_MST_ID_RESET  0x00000000
typedef union ahb_arbitration_ahb_mem_wrque_mst_id_u {
    struct {
        unsigned int ahb_master_id:31;      /* 0 = there is no write data in the write queue from that AHB master */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} ahb_arbitration_ahb_mem_wrque_mst_id_t;

#define AHB_ARBITRATION_CPU_ABORT_INFO_OFFSET 0xFC
#define AHB_ARBITRATION_CPU_ABORT_INFO_RESET  0x00000000
typedef union ahb_arbitration_cpu_abort_info_u {
    struct {
        unsigned int size:2;                /* Aborted transaction Request Size 00=byte, 01=hword, 10=word; 0 = BYTE_ABT; 1 = HWORD_ABT; 2 = WORD_ABT */
        unsigned int data:1;                /* Aborted transaction was a Data access; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int write:1;               /* Aborted transaction was a Write; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int badsize:1;             /* TRUE for abort caused by Bad Size (i.e. word access at odd byte address); 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int align:1;               /* TRUE for abort caused by Misalignment (i.e. word access at odd byte address); 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int protection:1;          /* TRUE for any protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int cache:1;               /* Abort occurred due to a Cache protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int ahb:1;                 /* Abort occurred due to an AHB protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int apb:1;                 /* Abort occurred due to an APB protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int ppsb:1;                /* Abort occurred due to a PPSB protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int inv_iram:1;            /* Abort occurred due to an access to invalid iRAM address space; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int iramd:1;               /* Abort occurred due to an iRAMd protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int iramc:1;               /* Abort occurred due to an iRAMc protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int iramb:1;               /* Abort occurred due to an iRAMb protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int irama:1;               /* Abort occurred due to an iRAMa protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} ahb_arbitration_cpu_abort_info_t;

#define AHB_ARBITRATION_CPU_ABORT_ADDR_OFFSET 0x100
#define AHB_ARBITRATION_CPU_ABORT_ADDR_RESET  0x00000000
typedef union ahb_arbitration_cpu_abort_addr_u {
    struct {
        unsigned int addr:32;               /* Instruction Address which caused the abort */
    };

    uint32_t reg32;
} ahb_arbitration_cpu_abort_addr_t;

#define AHB_ARBITRATION_COP_ABORT_INFO_OFFSET 0x104
#define AHB_ARBITRATION_COP_ABORT_INFO_RESET  0x00000000
typedef union ahb_arbitration_cop_abort_info_u {
    struct {
        unsigned int size:2;                /* Aborted transaction Request Size 00=byte, 01=hword, 10=word; 0 = BYTE_ABT; 1 = HWORD_ABT; 2 = WORD_ABT */
        unsigned int data:1;                /* Aborted transaction was a Data access; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int write:1;               /* Aborted transaction was a Write; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int badsize:1;             /* TRUE for abort caused by Bad Size (i.e. word access at odd byte address); 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int align:1;               /* TRUE for abort caused by Misalignment (i.e. word access at odd byte address); 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int protection:1;          /* TRUE for any protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int cache:1;               /* Abort occurred due to a Cache protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int ahb:1;                 /* Abort occurred due to an AHB protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int apb:1;                 /* Abort occurred due to an APB protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int ppsb:1;                /* Abort occurred due to a PPSB protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int undefined_bits_11_12:2;
        unsigned int iramc:1;               /* Abort occurred due to an iRAMc protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int iramb:1;               /* Abort occurred due to an iRAMb protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int irama:1;               /* Abort occurred due to an iRAMa protection violation; 0 = ABT_DIS; 1 = ABT_EN */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} ahb_arbitration_cop_abort_info_t;

#define AHB_ARBITRATION_COP_ABORT_ADDR_OFFSET 0x108
#define AHB_ARBITRATION_COP_ABORT_ADDR_RESET  0x00000000
typedef union ahb_arbitration_cop_abort_addr_u {
    struct {
        unsigned int addr:32;               /* Instruction Address which caused the abort */
    };

    uint32_t reg32;
} ahb_arbitration_cop_abort_addr_t;

#define AHB_AVPC_MCCIF_FIFOCTRL_OFFSET 0x23C
#define AHB_AVPC_MCCIF_FIFOCTRL_RESET  0x00000000
typedef union ahb_avpc_mccif_fifoctrl_u {
    struct {
        unsigned int avpc_mccif_wrcl_mcle2x:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int avpc_mccif_rdmc_rdfast:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int avpc_mccif_wrmc_clle2x:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int avpc_mccif_rdcl_rdfast:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} ahb_avpc_mccif_fifoctrl_t;

#define AHB_TIMEOUT_WCOAL_AVPC_OFFSET 0x240
#define AHB_TIMEOUT_WCOAL_AVPC_RESET  0x00000032
typedef union ahb_timeout_wcoal_avpc_u {
    struct {
        unsigned int avpcarm7w_wcoal_tmval:8;
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} ahb_timeout_wcoal_avpc_t;

#define AHB_ARBITRATION_DISABLE_OFFSET 0x0
#define AHB_ARBITRATION_DISABLE_RESET  0x00000000
typedef union ahb_arbitration_disable_u {
    struct {
        unsigned int cpu:1;                 /*  1 = disable CPU from arbitration. */
        unsigned int cop:1;                 /*  1 = disable COP from arbitration. */
        unsigned int vcp:1;                 /*  1 = disable VCP from arbitration. */
        unsigned int csite:1;               /*  1 = disable CoreSight from arbitration. */
        unsigned int eide:1;                /*  1 = disable EIDE from arbitration. */
        unsigned int ahbdma:1;              /*  1 = disable AHB-DMA from arbitration. */
        unsigned int usb:1;                 /*  1 = disable USB from arbitration. */
        unsigned int apbdma:1;              /*  1 = disable APB-DMA from arbitration. */
        unsigned int xio:1;                 /*  1 = disable XIO from arbitration. */
        unsigned int sdmmc1:1;              /*  1 = disable SDMMC1 from arbitration. */
        unsigned int nand:1;                /*  1 = disable NAND from arbitration. */
        unsigned int snor:1;                /*  1 = disable SNOR from arbitration. */
        unsigned int sdmmc4:1;              /*  1 = disable SDMMC4 from arbitration. */
        unsigned int bsev:1;                /*  1 = disable BSEV from arbitration. */
        unsigned int undefined_bits_14_15:2;
        unsigned int bsea:1;                /*  1 = disable BSEA from arbitration. */
        unsigned int usb3:1;                /*  1 = disable USB3 from arbitration. */
        unsigned int usb2:1;                /*  1 = disable USB2 from arbitration. */
        unsigned int sdmmc2:1;              /*  1 = disable SDMMC2 from arbitration. */
        unsigned int sdmmc3:1;              /*  1 = disable SDMMC3 from arbitration. */
        unsigned int undefined_bits_21_30:10;
        unsigned int dis_bus_park:1;        /*  1 = disable bus parking. */
    };

    uint32_t reg32;
} ahb_arbitration_disable_t;

#define AHB_ARBITRATION_PRIORITY_CTRL_OFFSET 0x4
#define AHB_ARBITRATION_PRIORITY_CTRL_RESET  0x00000000
typedef union ahb_arbitration_priority_ctrl_u {
    struct {
        unsigned int ahb_priority_select:29;/*  0 = low priority */
        unsigned int ahb_priority_weight:3; /* AHB priority weight count. This 3-bit field is  use to control  the amount of attention (weight) giving to the high priority  group before switching to the low priority group. */
    };

    uint32_t reg32;
} ahb_arbitration_priority_ctrl_t;

#define AHB_ARBITRATION_USR_PROTECT_OFFSET 0x8
#define AHB_ARBITRATION_USR_PROTECT_RESET  0x00000000
#define AHB_ARBITRATION_USR_PROTECT_WRMASK 0xFFFFFE00
typedef union ahb_arbitration_usr_protect_u {
    struct {
        unsigned int irama:1;               /* Abort on USR mode access to iRAMa memory space */
        unsigned int iramb:1;               /* Abort on USR mode access to iRAMb memory space */
        unsigned int iramc:1;               /* Abort on USR mode access to iRAMc memory space */
        unsigned int iramd:1;               /* Abort on USR mode access to iRAMd memory space */
        unsigned int ppsb:1;                /* Abort on USR mode access to PPSB memory space */
        unsigned int ahb:1;                 /* Abort on USR mode access to AHB memory space */
        unsigned int apb:1;                 /* Abort on USR mode access to APB memory space */
        unsigned int rom:1;                 /* Abort on USR mode access to internal ROM memory  space */
        unsigned int cache:1;               /* Abort on USR mode access to Cache memory space */
        unsigned int undefined_bits_9_31:23;
    };

    uint32_t reg32;
} ahb_arbitration_usr_protect_t;

#endif // TEGRA_AHB_GIZMO_H
