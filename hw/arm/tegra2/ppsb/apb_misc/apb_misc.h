/*
 * ARM NVIDIA Tegra2 emulation.
 *
 * Copyright (c) 2014-2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* Autogenerated from TRM v02p */

#ifndef TEGRA_APB_MISC_H
#define TEGRA_APB_MISC_H

#define PP_STRAPPING_OPT_A_OFFSET 0x8
#define PP_STRAPPING_OPT_A_RESET  0x00000000
typedef union pp_strapping_opt_a_u {
    struct {
        unsigned int nor_width:1;           /* 0 = IS16BIT; 1 = IS8BIT */
        unsigned int undefined_bits_1_3:3;
        unsigned int ram_code:4;            /* read at power-on reset time from GMI_AD[7:4] strap pads. In emulation (HIDREV_MAJORREV==0), this field indicates the RAM type connected. For QT (HIDREV_MINORREV==0): 0=SIM, 1=DDR, 2=DDR2, 3=LPDDR2 For FPGA (HIDREV_MINORREV==1): 0=SIM, 1=DDR, 2=DDR2, 3=LPDDR2 */
        unsigned int mio_width:1;           /* 0 = RSVD1 1 = RSVD2 */
        unsigned int undefined_bits_9_21:13;
        unsigned int arm_jtag:2;            /* read at power-on reset time from {GMI_CLK, GMI_ADV_N} strap pads 00=Serial_JTAG, 01=CPU_only, 10=COP_only, 11=Serial_JTAG (same as 00 case); 0 = SERIAL; 1 = CPU; 2 = COP; 3 = SERIAL_ALT */
        unsigned int boot_src_nor_boot:1;   /* read at power-on reset time from GMI_HIOW strap pad; 0 = IROM; 1 = NOR */
        unsigned int boot_src_usb_recovery_mode:1;/* read at power-on reset time from GMI_HIOR strap pad 0 = DISABLED 1 = ENABLED */
        unsigned int boot_select:4;         /* read at power-on reset time from GMI_AD[15:12] strap pads */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} pp_strapping_opt_a_t;

#define PP_TRISTATE_REG_A_OFFSET 0x14
#define PP_TRISTATE_REG_A_RESET  0xC01BFFF0
typedef union pp_tristate_reg_a_u {
    struct {
        unsigned int z_ata:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_atb:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_atc:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_atd:1;               /* 0 = NORMAL; 1 = TRI TATE */
        unsigned int z_cdev1:1;             /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_cdev2:1;             /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_csus:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_dap1:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_dap2:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_dap3:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_dap4:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_dta:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_dtb:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_dtc:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_dtd:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_dte:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_gpu:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_gpv:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_i2cp:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_irtx:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_irrx:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_kbcb:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_kbca:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_pmc:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_pta:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_rm:1;                /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_kbce:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_kbcf:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_gma:1;               /* 0 = NORMAL 1 = TRISTATE */
        unsigned int z_gmc:1;               /* 0 = NORMAL 1 = TRISTATE */
        unsigned int z_sdio1:1;             /* 0 = NORMAL 1 = TRISTATE */
        unsigned int z_owc:1;               /* 0 = NORMAL 1 = TRISTATE */
    };

    uint32_t reg32;
} pp_tristate_reg_a_t;

#define PP_TRISTATE_REG_B_OFFSET 0x18
#define PP_TRISTATE_REG_B_RESET  0x00FFEFEE
typedef union pp_tristate_reg_b_u {
    struct {
        unsigned int z_gme:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_sdc:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_sdd:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_slxa:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int undefined_bit_4:1;
        unsigned int z_slxc:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_slxd:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_slxk:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_spdi:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_spdo:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_spia:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_spib:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_spic:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_spid:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_spie:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_spif:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_spig:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_spih:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_uaa:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_uab:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_uac:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_uad:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_uca:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ucb:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int undefined_bit_24:1;
        unsigned int z_ate:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_kbcc:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int undefined_bits_27_28:2;
        unsigned int z_gmb:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_gmd:1;               /* 0 = NORMAL 1 = TRISTATE */
        unsigned int z_ddc:1;               /* 0 = NORMAL 1 = TRISTATE */
    };

    uint32_t reg32;
} pp_tristate_reg_b_t;

#define PP_TRISTATE_REG_C_OFFSET 0x1C
#define PP_TRISTATE_REG_C_RESET  0xFFFFFFFF
typedef union pp_tristate_reg_c_u {
    struct {
        unsigned int z_ld0:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld1:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld2:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld3:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld4:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld5:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld6:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld7:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld8:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld9:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld10:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld11:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld12:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld13:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld14:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld15:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld16:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ld17:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lhp0:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lhp1:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lhp2:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lvp0:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lvp1:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_hdint:1;             /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lm0:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lm1:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lvs:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lsc0:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lsc1:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lsck:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ldc:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lcsn:1;              /* 0 = NORMAL; 1 = TRISTATE */
    };

    uint32_t reg32;
} pp_tristate_reg_c_t;

#define PP_TRISTATE_REG_D_OFFSET 0x20
#define PP_TRISTATE_REG_D_RESET  0x0000F1FF
typedef union pp_tristate_reg_d_u {
    struct {
        unsigned int z_lspi:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lsda:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lsdi:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lpw0:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lpw1:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lpw2:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_ldi:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lhs:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_lpp:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int undefined_bit_9:1;
        unsigned int z_kbcd:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_gpu7:1;              /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_dtf:1;               /* 0 = NORMAL; 1 = TRISTATE */
        unsigned int z_uda:1;               /* 0 = NORMAL 1 = TRISTATE */
        unsigned int z_crtp:1;              /* 0 = NORMAL 1 = TRISTATE */
        unsigned int z_sdb:1;               /* 0 = NORMAL 1 = TRISTATE */
        unsigned int undefined_bits_16_31:16;
    };

    uint32_t reg32;
} pp_tristate_reg_d_t;

#define PP_CONFIG_CTL_OFFSET 0x24
#define PP_CONFIG_CTL_RESET  0x00000001
typedef union pp_config_ctl_u {
    struct {
        unsigned int undefined_bits_0_5:6;
        unsigned int jtag:1;                /* 0 = Disable Debug ; 1 = Enable JTAG DBGEN; 0 = DISABLE; 1 = ENABLE */
        unsigned int tbe:1;                 /* 0 = Disable ; 1 = Enable RTCK Daisy chaining; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} pp_config_ctl_t;

#define PP_MISC_USB_OTG_OFFSET 0x28
#define PP_MISC_USB_OTG_RESET  0x00001000
#define PP_MISC_USB_OTG_WRMASK 0xFC7FFF29
typedef union pp_misc_usb_otg_u {
    struct {
        unsigned int sus_pol:1;             /* Polarity of the suspend signal going to USB PHY Software should not change this. 0 = ACTIVE_LOW 1 = ACTIVE_HIGH */
        unsigned int staticgpi:1;           /* Static General purpose input coming from ID pin 0 = UNSET 1 = SET */
        unsigned int suspended:1;           /* USB PHY suspend status This bit is set to 1 whenever USB is suspended and the PHY clock isn’t available. NOTE: Software should not access any registers in USB controller when this bit is set. 0 = UNSET 1 = SET */
        unsigned int sw_otg_id_en:1;        /* Enable Software Controlled OTG_ID If using a GPIO for OTG_ID signal, then software can set this to 1 and write the value from the GPIO to the SW_OTG_ID bit in this register. This field is the same as the field ID_SW_EN in register USB_PHY_VBUS_WAKEUP_ID. 0 = DISABLE 1 = ENABLE */
        unsigned int otg_id:1;              /* Real OTG_ID status from the USB PHY. This field is the same as the field ID_STS in register USB_PHY_VBUS_WAKEUP_ID. 0 = UNSET 1 = SET */
        unsigned int lpbk_en:1;             /* Loopback enable Not for normal software use 0 = DISABLE 1 = ENABLE */
        unsigned int vbus_chg_det:1;        /* VBUS change detect. This bit is set whenever a change in A_SESS_VLD is detected. Software can read the status of A_SESS_VLD from A_SESS_VLD_STS2 bit. This field is the same as the field A_SESS_VLD_CHG_DET in register USB_PHY_VBUS_SENSORS. 0 = UNSET 1 = SET */
        unsigned int pclkvld:1;             /* PHY clock valid status. This bit is set whenever PHY clock becomes valid. It is cleared whenever PHY clock stops. 0 = UNSET 1 = SET */
        unsigned int wk_rsm_en:1;           /* Wake on resume enable. If this bit is enabled, USB PHY will wake up from suspend whenever resume/reset signaling is detected on USB. 0 = DISABLE 1 = ENABLE */
        unsigned int rsm_ie:1;              /* Resume/Clock valid interrupt enable. If this bit is enabled, interrupt is generated whenever PHY clock becomes valid. 0 = DISABLE 1 = ENABLE */
        unsigned int rsm_vbus_chg:1;        /* Wake/resume on VBUS change detect. If enabled, the USB PHY will wake up whenever a change in A_SESS_VLD is detected. This should be set only when USB PHY is already suspended. 0 = DISABLE 1 = ENABLE */
        unsigned int susp_clr:1;            /* Suspend Clear Software must write a 1 to this bit to bring the PHY out of suspend mode. This is used when the software stops the PHY clock during suspend and then wants to initiate a resume. Software should also write 0 to clear it. NOTE: It is required that software generate a positive pulse on this bit to */
        unsigned int id_pu:1;               /* ID pullup enable. This field controls the internal pull-up to OTG_ID pin. Software should set this to 1 if using internal OTG_ID. If software is using a GPIO for OTG_ID, then it can write this to 0. 0 = DISABLE 1 = ENABLE */
        unsigned int rsvd13:1;              /* Reserved */
        unsigned int sw_otg_id:1;           /* Software controlled OTG_ID. If SW_OTG_ID_EN = 1, then software needs to monitor actual OTG_ID bit used as a GPIO and based on the value of OTG_ID, it can set this bit. This field is the same as the field ID_SW_VALUE in register USB_PHY_VBUS_WAKEUP_ID. 0 = UNSET 1 = SET */
        unsigned int vbus_chg_int_en:1;     /* VBUS Change Interrupt Enable If set, an interrupt will be generated whenever A_SESS_VLD changes value. Software can read the value of A_SESS_VLD from A_SESS_VLD_STS2 bit. This field is the same as the field A_SESS_VLD_INT_EN in register USB_PHY_VBUS_SENSORS. 0 = DISABLE 1 = ENABLE */
        unsigned int susp_set:1;            /* Suspend Set Software must write a 1 to this bit to put the USB PHY in suspend mode. Software should do this only after making sure that the USB is indeed in suspend mode. Setting this bit will stop the PHY clock. Software should write a 0 to clear it. NOTE: It is required that software generate a positive pulse on this bit to guarantee proper operation. 0 = UNSET 1 = SET */
        unsigned int sw_a_sess_vld_en:1;    /* Enable Software Controlled A_SESS_VLD. Software sets this bit to drive the value in SW_A_SESS_VLD to the USB controller. This field is the same as the field A_SESS_VLD_SW_EN in register USB_PHY_VBUS_SENSORS. 0 = DISABLE 1 = ENABLE */
        unsigned int sw_a_sess_vld:1;       /* Software_A_SESS_VLD status. Software should write the appropriate value (1/0) to set/unset the A_SESS_VLD status. This field is the same as the field A_SESS_VLD_SW_VALUE in register USB_PHY_VBUS_SENSORS. 0 = UNSET 1 = SET */
        unsigned int sw_a_vbus_vld_en:1;    /* Enable Software Controlled A_VBUS_VLD. Software sets this bit to drive the value in SW_A_VBUS_VLD to the USB controller. This field is the same as the field A_VBUS_VLD_SW_EN in register USB_PHY_VBUS_SENSORS. 0 = DISABLE 1 = ENABLE */
        unsigned int sw_a_vbus_vld:1;       /* Software_A_VBUS_VLD status. Software should write the appropriate value (1/0) to set/unset the A_VBUS_VLD status. This field is the same as the field A_VBUS_VLD_SW_VALUE in register USB_PHY_VBUS_SENSORS. 0 = UNSET 1 = SET */
        unsigned int sw_b_sess_end_en:1;    /* Enable Software Controlled B_SESS_END. Software sets this bit to drive the value in SW_B_SESS_END to the USB controller This field is the same as the field B_SESS_END_SW_EN in register USB_PHY_VBUS_SENSORS. 0 = DISABLE 1 = ENABLE */
        unsigned int sw_b_sess_end:1;       /* Software_B_SESS_END status. Software should write the appropriate value (1/0) to set/unset the B_SESS_END status. This field is the same as the field B_SESS_END_SW_VALUE in register USB_PHY_VBUS_SENSORS. 0 = UNSET 1 = SET */
        unsigned int a_sess_vld_sts2:1;     /* A_SESS_VLD status from USB PHY. This field is the same as the field A_SESS_VLD_STS in register USB_PHY_VBUS_SENSORS. 0 = UNSET 1 = SET */
        unsigned int a_vbus_vld_sts2:1;     /* A_VBUS_VLD status from USB PHY. This field is the same as the field A_VBUS_VLD_STS in register USB_PHY_VBUS_SENSORS. 0 = UNSET 1 = SET */
        unsigned int b_sess_end_sts2:1;     /* B_SESS_END status from USB PHY. This field is the same as the field B_SESS_END_STS in register USB_PHY_VBUS_SENSORS. 0 = UNSET 1 = SET */
        unsigned int undefined_bits_26_29:4;
        unsigned int wake_on_cnnt_en:1;     /* Wake on Connect Enable (device mode) When enabled (1), USB PHY will wake up from suspend on a connect event. 0 = DISABLE 1 = ENABLE */
        unsigned int wake_on_discon_en:1;   /* Wake on Disconnect Enable (device mode). When enabled (1), USB PHY will wake up from suspend on a disconnect event. 0 = DISABLE 1 = ENABLE */
    };

    uint32_t reg32;
} pp_misc_usb_otg_t;

#define PP_USB_PHY_PARAM_OFFSET 0x64
#define PP_USB_PHY_PARAM_RESET  0x00000000
typedef union pp_usb_phy_param_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int vs_ctl:2;              /* Vbus_sense control Controls which VBUS sensor input is driven to the controller. 00: Use VBUS_WAKEUP. 01: Use (A_SESS_VLD || B_SESS_VLD) output from the PHY if the PHY clock is available. Otherwise, use VBUS_WAKEUP. 10: Use (A_SESS_VLD || B_SESS_VLD) output from the PHY 11: Use A_SESS_VLD output from the PHY 0 = VBUS_WAKEUP 1 = AB_SESS_VLD_OR_VBUS_WAKEUP 2 = AB_SESS_VLD 3 = A_SESS_VLD */
        unsigned int undefined_bits_5_31:27;
    };

    uint32_t reg32;
} pp_usb_phy_param_t;

#define PP_USB_PHY_VBUS_SENSORS_OFFSET 0x70
#define PP_USB_PHY_VBUS_SENSORS_RESET  0x00000000
#define PP_USB_PHY_VBUS_SENSORS_WRMASK 0xF9F9F9F9
typedef union pp_usb_phy_vbus_sensors_u {
    struct {
        unsigned int b_sess_end_int_en:1;   /* B_SESS_END interrupt enable If this field is set to 1, an interrupt is generated whenever B_SESS_END_CHG_DET is set to 1. 0 = DISABLE 1 = ENABLE */
        unsigned int b_sess_end_chg_det:1;  /* B_SESS_END change detect. This field is set by hardware whenever a change is detected in the value of B_SESS_END. software writes a 1 to clear it 0 = UNSET 1 = SET */
        unsigned int b_sess_end_sts:1;      /* B_SESS_END status. This is set to 1 whenever B_SESS_END sensor output is 1. 0 = UNSET 1 = SET */
        unsigned int b_sess_end_sw_en:1;    /* B_SESS_END software enable. Enable Software Controlled B_SESS_END Software sets this bit to drive the value in B_SESS_END_SW_VALUE to the USB controller. 0 = DISABLE 1 = ENABLE */
        unsigned int b_sess_end_sw_value:1; /* B_SESS_END software value Software should write the appropriate value (1/0) to set/unset the B_SESS_END status. This is only valid when B_SESS_END_SW_EN is set. 0 = UNSET 1 = SET */
        unsigned int b_sess_end_deb_sel_b:1;/* B_SESS_END debounce A/B select Selects between the two debounce values UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. 0 = SEL_A 1 = SEL_B */
        unsigned int undefined_bits_6_7:2;
        unsigned int b_sess_vld_int_en:1;   /* B_SESS_VLD interrupt enable. If this field is set to 1, an interrupt is generated whenever B_SESS_VLD_CHG_DET is set to 1. 0 = DISABLE 1 = ENABLE */
        unsigned int b_sess_vld_chg_det:1;  /* B_SESS_VLD change detect. This field is set by hardware whenever a change is detected in the value of B_SESS_VLD. software writes a 1 to clear it 0 = UNSET 1 = SET */
        unsigned int b_sess_vld_sts:1;      /* B_SESS_VLD status. This is set to 1 whenever B_SESS_VLD sensor output is 1. 0 = UNSET 1 = SET */
        unsigned int b_sess_vld_sw_en:1;    /* B_SESS_VLD software enable. Enable Software Controlled B_SESS_VLD. Software sets this bit to drive the value in B_SESS_VLD_SW_VALUE to the USB controller. 0 = DISABLE 1 = ENABLE */
        unsigned int b_sess_vld_sw_value:1; /* B_SESS_VLD software value. Software should write the appropriate value (1/0) to set/unset the B_SESS_VLD status. This is only valid when B_SESS_VLD_SW_EN is set. 0 = UNSET 1 = SET */
        unsigned int b_sess_vld_deb_sel_b:1;/* B_SESS_VLD debounce A/B select. Selects between the two debounce values UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. 0 = SEL_A */
        unsigned int undefined_bits_14_15:2;
        unsigned int a_sess_vld_int_en:1;   /* A_SESS_VLD interrupt enable. If this field is set to 1, an interrupt is generated whenever A_SESS_VLD_CHG_DET is set to 1. 0 = DISABLE 1 = ENABLE */
        unsigned int a_sess_vld_chg_det:1;  /* A_SESS_VLD change detect. This field is set by hardware whenever a change is detected in the value of A_SESS_VLD. software writes a 1 to clear it 0 = UNSET 1 = SET */
        unsigned int a_sess_vld_sts:1;      /* A_SESS_VLD status. This is set to 1 whenever A_SESS_VLD sensor output is 1. 0 = UNSET 1 = SET */
        unsigned int a_sess_vld_sw_en:1;    /* A_SESS_VLD software enable. Enable Software Controlled A_SESS_VLD. Software sets this bit to drive the value in A_SESS_VLD_SW_VALUE to the USB controller. 0 = DISABLE 1 = ENABLE */
        unsigned int a_sess_vld_sw_value:1; /* A_SESS_VLD software value. Software should write the appropriate value (1/0) to set/unset the A_SESS_VLD status. This is only valid when A_SESS_VLD_SW_EN is set. 0 = UNSET 1 = SET */
        unsigned int a_sess_vld_deb_sel_b:1;/* A_SESS_VLD debounce A/B select. Selects between the two debounce values UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. 0 = SEL_A 1 = SEL_B */
        unsigned int undefined_bits_22_23:2;
        unsigned int a_vbus_vld_int_en:1;   /* A_VBUS_VLD interrupt enable. If this field is set to 1, an interrupt is generated whenever A_VBUS_VLD_CHG_DET is set to 1. 0 = DISABLE 1 = ENABLE */
        unsigned int a_vbus_vld_chg_det:1;  /* A_VBUS_VLD change detect. This field is set by hardware whenever a change is detected in the value of A_VBUS_VLD. software writes a 1 to clear it 0 = UNSET 1 = SET */
        unsigned int a_vbus_vld_sts:1;      /* A_VBUS_VLD status. This is set to 1 whenever A_VBUS_VLD sensor output is 1. 0 = UNSET 1 = SET */
        unsigned int a_vbus_vld_sw_en:1;    /* A_VBUS_VLD software enable. Enable Software Controlled A_VBUS_VLD. Software sets this bit to drive the value in A_VBUS_VLD_SW_VALUE to the USB controller. 0 = DISABLE 1 = ENABLE */
        unsigned int a_vbus_vld_sw_value:1; /* A_VBUS_VLD software value. Software should write the appropriate value (1/0) to set/unset the A_VBUS_VLD status. This is only valid when A_VBUS_VLD_SW_EN is set; 0 = UNSET 1 = SET */
        unsigned int a_vbus_vld_deb_sel_b:1;/* A_VBUS_VLD debounce A/B select. Selects between the two debounce values UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. 0 = SEL_A 1 = SEL_B */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} pp_usb_phy_vbus_sensors_t;

#define PP_USB_PHY_VBUS_WAKEUP_ID_OFFSET 0x74
#define PP_USB_PHY_VBUS_WAKEUP_ID_RESET  0x06000000
#define PP_USB_PHY_VBUS_WAKEUP_ID_WRMASK 0xFFF9F9F9
typedef union pp_usb_phy_vbus_wakeup_id_u {
    struct {
        unsigned int id_int_en:1;           /* ID interrupt enable. If this field is set to 1, an interrupt is generated whenever ID_CHG_DET is set to 1. 0 = DISABLE 1 = ENABLE */
        unsigned int id_chg_det:1;          /* ID change detect. This field is set by hardware whenever a change is detected in the value of ID. software writes a 1 to clear it; 0 = UNSET 1 = SET */
        unsigned int id_sts:1;              /* ID status. This is set to 1 whenever ID sensor output is 1. 0 = UNSET 1 = SET */
        unsigned int id_sw_en:1;            /* ID software enable. Enable Software Controlled ID. Software sets this bit to drive the value in ID_SW_VALUE to the USB controller 0 = DISABLE 1 = ENABLE */
        unsigned int id_sw_value:1;         /* ID software value. Software should write the appropriate value (1/0) to set/unset the ID status. This is only valid when ID_SW_EN is set. 0 = UNSET 1 = SET */
        unsigned int id_deb_sel_b:1;        /* ID debounce A/B select. Selects between the two debounce values UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. 0 = SEL_A 1 = SEL_B */
        unsigned int undefined_bits_6_7:2;
        unsigned int vbus_wakeup_int_en:1;  /* VBUS_WAKEUP interrupt enable If this field is set to 1, an interrupt is generated whenever VBUS_WAKEUP_CHG_DET is set to 1. 0 = DISABLE 1 = ENABLE */
        unsigned int vbus_wakeup_chg_det:1; /* VBUS_WAKEUP change detect. This field is set by hardware whenever a change is detected in the value of VBUS_WAKEUP. software writes a 1 to clear it 0 = UNSET 1 = SET */
        unsigned int vbus_wakeup_sts:1;     /* VBUS_WAKEUP status. This is set to 1 whenever VBUS_WAKEUP sensor output is 1. 0 = UNSET 1 = SET */
        unsigned int vbus_wakeup_sw_en:1;   /* VBUS_WAKEUP software enable. Enable Software Controlled VBUS_WAKEUP. Software sets this bit to drive the value in VBUS_WAKEUP_SW_VALUE to the USB controller. 0 = DISABLE 1 = ENABLE */
        unsigned int vbus_wakeup_sw_value:1;/* VBUS_WAKEUP software value. Software should write the appropriate value (1/0) to set/unset the VBUS_WAKEUP status. This is only valid when VBUS_WAKEUP_SW_EN is set. 0 = UNSET 1 = SET */
        unsigned int vbus_wakeup_deb_sel_b:1;/* VBUS_WAKEUP debounce A/B select. Selects between the two debounce values UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. 0 = SEL_A 1 = SEL_B */
        unsigned int undefined_bits_14_15:2;
        unsigned int vdat_det_int_en:1;     /* VDAT_DET interrupt enable. If this field is set to 1, an interrupt is generated whenever VDAT_DET_CHG_DET is set to 1. 0 = DISABLE 1 = ENABLE */
        unsigned int vdat_det_chg_det:1;    /* VDAT_DET change detect. This field is set by hardware whenever a change is detected in the value of VDAT_DET. software writes a 1 to clear it; 0 = UNSET 1 = SET */
        unsigned int vdat_det_sts:1;        /* VDAT_DET status. This is set to 1 whenever VDAT_DET sensor output is 1. 0 = UNSET 1 = SET */
        unsigned int vdat_det_sw_en:1;      /* VDAT_DET software enable. Enable Software Controlled VDAT_DET. Software sets this bit to drive the value in VDAT_DET_SW_VALUE to the USB controller 0 = DISABLE 1 = ENABLE */
        unsigned int vdat_det_sw_value:1;   /* VDAT_DET software value. Software should write the appropriate value (1/0) to set/unset the VDAT_DET status. This is only valid when VDAT_DET_SW_EN is set. 0 = UNSET 1 = SET */
        unsigned int vdat_det_deb_sel_b:1;  /* VDAT_DET debounce A/B select. Selects between the two debounce values UTMIP_BIAS_DEBOUNCE_A or UTMIP_BIAS_DEBOUNCE_B from the register UTMIP_DEBOUNCE_CFG0. 0 = SEL_A 1 = SEL_B */
        unsigned int undefined_bits_22_23:2;
        unsigned int ip_delay_tx2tx_hs:6;   /* HS Tx to Tx inter-packet delay counter. Software should not change this */
        unsigned int undefined_bits_30_31:2;
    };

    uint32_t reg32;
} pp_usb_phy_vbus_wakeup_id_t;

#define PP_USB_PHY_ALT_VBUS_STS_OFFSET 0x78
#define PP_USB_PHY_ALT_VBUS_STS_RESET  0x00000000
typedef union pp_usb_phy_alt_vbus_sts_u {
    struct {
        unsigned int vbus_wakeup_alt:1;     /* Vbus wakeup alternate status 0 = UNSET 1 = SET */
        unsigned int a_vbus_vld_alt:1;      /* A_VBUS_VLD alternate status 0 = UNSET 1 = SET */
        unsigned int static_gpi_alt:1;      /* Static GPI alternate status 0 = UNSET 1 = SET */
        unsigned int b_sess_end_alt:1;      /* B_SESS_END alternate status 0 = UNSET 1 = SET */
        unsigned int id_dig_alt:1;          /* ID alternate status 0 = UNSET 1 = SET */
        unsigned int b_sess_vld_alt:1;      /* B_SESS_VLD alternate status 0 = UNSET 1 = SET */
        unsigned int a_sess_vld_alt:1;      /* A_SESS_VLD alternate status 0 = UNSET 1 = SET */
        unsigned int undefined_bits_7_31:25;
    };

    uint32_t reg32;
} pp_usb_phy_alt_vbus_sts_t;

#define PP_PIN_MUX_CTL_A_OFFSET 0x80
#define PP_PIN_MUX_CTL_A_RESET  0x02A22000
typedef union pp_pin_mux_ctl_a_u {
    struct {
        unsigned int uaa_sel:2;             /* 0 = SPI3; 1 = MIPI_HS; 2 = UART1; 3 = ULPI */
        unsigned int uab_sel:2;             /* 0 = SPI2; 1 = MIPI_HS; 2 = UART1; 3 = ULPI */
        unsigned int uac_sel:2;             /* 0 = OWR; 1 = RSVD2; 2 = RSVD3; 3 = RSVD4 */
        unsigned int uad_sel:2;             /* 0 = IRDA; 1 = SPDIF; 2 = UART1; 3 = SPI4 */
        unsigned int uda_sel:2;             /* 0 = SPI1 1 = RSVD 2 = UART4 3 = ULPI */
        unsigned int undefined_bits_10_11:2;
        unsigned int ate_sel:2;             /* 0 = IDE; 1 = NAND; 2 = GMI; 3 = RSVD */
        unsigned int rm_sel:2;              /* 0 = I2C; 1 = RSVD1; 2 = RSVD2; 3 = RSVD3 */
        unsigned int atb_sel:2;             /* 0 = IDE; 1 = NAND; 2 = GMI; 3 = SDIO4 */
        unsigned int undefined_bits_18_19:2;
        unsigned int atd_sel:2;             /* 0 = IDE; 1 = NAND; 2 = GMI; 3 = SDIO4 */
        unsigned int atc_sel:2;             /* 0 = IDE; 1 = NAND; 2 = GMI; 3 = SDIO4 */
        unsigned int ata_sel:2;             /* 0 = IDE; 1 = NAND; 2 = GMI; 3 = RSVD */
        unsigned int kbcf_sel:2;            /* 0 = KBC; 1 = NAND; 2 = TRACE; 3 = MIO */
        unsigned int kbce_sel:2;            /* 0 = KBC; 1 = NAND; 2 = OWR; 3 = RSVD2 */
        unsigned int sdio1_sel:2;           /* 0 = SDIO1 1 = RSVD1 2 = UART5 3 = UART1 */
    };

    uint32_t reg32;
} pp_pin_mux_ctl_a_t;

#define PP_PIN_MUX_CTL_B_OFFSET 0x84
#define PP_PIN_MUX_CTL_B_RESET  0x0000A140
typedef union pp_pin_mux_ctl_b_u {
    struct {
        unsigned int gma_sel:2;             /* 0 = UART5 1 = SPI3 2 = GMI 3 = SDMMC4 */
        unsigned int gmc_sel:2;             /* 0 = UART4 1 = SPI4 2 = GMI 3 = SFLASH */
        unsigned int hdint_sel:2;           /* 0 = HDMI; 1 = RSVD2; 2 = RSVD3; 3 = RSVD4 */
        unsigned int slxa_sel:2;            /* 0 = PCIE; 1 = SPI4; 2 = SDIO3; 3 = SPI2 */
        unsigned int owc_sel:2;             /* 0 = OWR; 1 = RSVD1; 2 = RSVD2; 3 = RSVD3 */
        unsigned int slxc_sel:2;            /* 0 = SPDIF; 1 = SPI4; 2 = SDIO3; 3 = SPI2 */
        unsigned int slxd_sel:2;            /* 0 = SPDIF; 1 = SPI4; 2 = SDIO3; 3 = SPI2 */
        unsigned int slxk_sel:2;            /* 0 = PCIE; 1 = SPI4; 2 = SDIO3; 3 = SPI2 */
        unsigned int uca_sel:2;             /* 0 = UART3; 1 = RSVD2; 2 = GMI; 3 = RSVD4 */
        unsigned int ucb_sel:2;             /* 0 = UART3; 1 = PWM; 2 = GMI; 3 = RSVD4 */
        unsigned int dta_sel:2;             /* 0 = RSVD1; 1 = SDIO2; 2 = VI; 3 = RSVD4 */
        unsigned int dtb_sel:2;             /* 0 = RSVD1; 1 = RSVD2; 2 = VI; 3 = SPI1 */
        unsigned int undefined_bits_24_25:2;
        unsigned int dtc_sel:2;             /* 0 = RSVD1; 1 = RSVD2; 2 = VI; 3 = RSVD4 */
        unsigned int dtd_sel:2;             /* 0 = RSVD1; 1 = SDIO2; 2 = VI; 3 = RSVD4 */
        unsigned int dte_sel:2;             /* 0 = RSVD1; 1 = RSVD2; 2 = VI; 3 = SPI1 */
    };

    uint32_t reg32;
} pp_pin_mux_ctl_b_t;

#define PP_PIN_MUX_CTL_C_OFFSET 0x88
#define PP_PIN_MUX_CTL_C_RESET  0xA8CA0000
typedef union pp_pin_mux_ctl_c_u {
    struct {
        unsigned int ddc_sel:2;             /* 0 = I2C2; 1 = RSVD1; 2 = RSVD2; 3 = RSVD3 */
        unsigned int cdev1_sel:2;           /* 0 = OSC; 1 = PLLA_OUT; 2 = PLLM_OUT1; 3 = AUDIO_SYNC */
        unsigned int cdev2_sel:2;           /* 0 = OSC; 1 = AHB_CLK; 2 = APB_CLK; 3 = PLLP_OUT4 */
        unsigned int csus_sel:2;            /* 0 = PLLC_OUT1; 1 = PLLP_OUT2; 2 = PLLP_OUT3; 3 = VI_SENSOR_CLK */
        unsigned int i2cp_sel:2;            /* 0 = I2C; 1 = RSVD2; 2 = RSVD3; 3 = RSVD4 */
        unsigned int kbca_sel:2;            /* 0 = KBC; 1 = NAND; 2 = SDIO2; 3 = EMC_TEST1_DLL */
        unsigned int kbcb_sel:2;            /* 0 = KBC; 1 = NAND; 2 = SDIO2; 3 = MIO */
        unsigned int kbcc_sel:2;            /* 0 = KBC; 1 = NAND; 2 = TRACE; 3 = EMC_TEST1_DLL */
        unsigned int irtx_sel:2;            /* 0 = UART1; 1 = UART2; 2 = GMI; 3 = SPI4 */
        unsigned int irrx_sel:2;            /* 0 = UART1; 1 = UART2; 2 = GMI; 3 = SPI4 */
        unsigned int dap1_sel:2;            /* 0 = DAP1; 1 = RSVD2; 2 = GMI; 3 = SDIO2 */
        unsigned int dap2_sel:2;            /* 0 = DAP2; 1 = TWC; 2 = RSVD3; 3 = GMI */
        unsigned int dap3_sel:2;            /* 0 = DAP3; 1 = RSVD2; 2 = RSVD3; 3 = RSVD4 */
        unsigned int dap4_sel:2;            /* 0 = DAP4; 1 = RSVD2; 2 = GMI; 3 = RSVD4 */
        unsigned int gmb_sel:2;             /* 0 = IDE 1 = NAND 2 = GMI 3 = GMI_INT */
        unsigned int gmd_sel:2;             /* 0 = RSVD1 1 = NAND 2 = GMI 3 = SFLASH */
    };

    uint32_t reg32;
} pp_pin_mux_ctl_c_t;

#define PP_PIN_MUX_CTL_D_OFFSET 0x8C
#define PP_PIN_MUX_CTL_D_RESET  0x0FFC0002
typedef union pp_pin_mux_ctl_d_u {
    struct {
        unsigned int gme_sel:2;             /* 0 = RSVD1; 1 = DAP5; 2 = GMI; 3 = SDIO4 */
        unsigned int gpv_sel:2;             /* 0 = PCIE; 1 = RSVD2; 2 = RSVD3; 3 = RSVD4 */
        unsigned int gpu_sel:2;             /* 0 = PWM; 1 = UART1; 2 = GMI; 3 = RSVD4 */
        unsigned int spdo_sel:2;            /* 0 = SPDIF; 1 = RSVD; 2 = I2C; 3 = SDIO2 */
        unsigned int spdi_sel:2;            /* 0 = SPDIF; 1 = RSVD; 2 = I2C; 3 = SDIO2 */
        unsigned int sdb_sel:2;             /* 0 = UART1; 1 = PWM; 2 = SDIO3; 3 = SPI2 */
        unsigned int sdc_sel:2;             /* 0 = PWM; 1 = TWC; 2 = SDIO3; 3 = SPI3 */
        unsigned int sdd_sel:2;             /* 0 = UART1; 1 = PWM; 2 = SDIO3; 3 = SPI3 */
        unsigned int spih_sel:2;            /* 0 = SPI3; 1 = SPI2; 2 = SPI2_ALT; 3 = I2C */
        unsigned int spig_sel:2;            /* 0 = SPI3; 1 = SPI2; 2 = SPI2_ALT; 3 = I2C */
        unsigned int spif_sel:2;            /* 0 = SPI3; 1 = SPI1; 2 = SPI2; 3 = RSVD */
        unsigned int spie_sel:2;            /* 0 = SPI2; 1 = SPI1; 2 = SPI2_ALT; 3 = GMI */
        unsigned int spid_sel:2;            /* 0 = SPI2; 1 = SPI1; 2 = SPI2_ALT; 3 = GMI */
        unsigned int spic_sel:2;            /* 0 = SPI1; 1 = SPI2; 2 = SPI3; 3 = GMI */
        unsigned int spib_sel:2;            /* 0 = SPI1; 1 = SPI2; 2 = SPI3; 3 = GMI */
        unsigned int spia_sel:2;            /* 0 = SPI1; 1 = SPI2; 2 = SPI3; 3 = GMI */
    };

    uint32_t reg32;
} pp_pin_mux_ctl_d_t;

#define PP_PIN_MUX_CTL_E_OFFSET 0x90
#define PP_PIN_MUX_CTL_E_RESET  0x00000000
typedef union pp_pin_mux_ctl_e_u {
    struct {
        unsigned int lpw0_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = SPI3; 3 = HDMI */
        unsigned int lpw1_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = RSVD; 3 = RSVD4 */
        unsigned int lpw2_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = SPI3; 3 = HDMI */
        unsigned int lsdi_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = SPI3; 3 = RSVD */
        unsigned int lsda_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = SPI3; 3 = HDMI */
        unsigned int lspi_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = HDMI */
        unsigned int lcsn_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = SPI3; 3 = RSVD4 */
        unsigned int ldc_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = RSVD; 3 = RSVD4 */
        unsigned int lsck_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = SPI3; 3 = HDMI */
        unsigned int lsc0_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int lsc1_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = SPI3; 3 = HDMI */
        unsigned int lhs_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int lvs_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int lm0_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = SPI3; 3 = RSVD */
        unsigned int lm1_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = RSVD3; 3 = CRT */
        unsigned int lvp0_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = RSVD3; 3 = RSVD */
    };

    uint32_t reg32;
} pp_pin_mux_ctl_e_t;

#define PP_PIN_MUX_CTL_F_OFFSET 0x94
#define PP_PIN_MUX_CTL_F_RESET  0x00000000
typedef union pp_pin_mux_ctl_f_u {
    struct {
        unsigned int ld0_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld1_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld2_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld3_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld4_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld5_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld6_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld7_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld8_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld9_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld10_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld11_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld12_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld13_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld14_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld15_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
    };

    uint32_t reg32;
} pp_pin_mux_ctl_f_t;

#define PP_PIN_MUX_CTL_G_OFFSET 0x98
#define PP_PIN_MUX_CTL_G_RESET  0x00000000
typedef union pp_pin_mux_ctl_g_u {
    struct {
        unsigned int ld16_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = XIO; 3 = RSVD */
        unsigned int ld17_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = RSVD; 3 = RSVD */
        unsigned int lhp1_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = RSVD3; 3 = RSVD */
        unsigned int lhp2_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = RSVD3; 3 = RSVD4 */
        unsigned int lvp1_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = RSVD3; 3 = RSVD4 */
        unsigned int lhp0_sel:2;            /* 0 = LCD1; 1 = LCD2; 2 = RSVD3; 3 = RSVD4 */
        unsigned int undefined_bits_12_13:2;
        unsigned int lpp_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = RSVD3; 3 = RSVD */
        unsigned int ldi_sel:2;             /* 0 = LCD1; 1 = LCD2; 2 = RSVD3; 3 = RSVD */
        unsigned int pmc_sel:2;             /* 0 = PWR_ON; 1 = PWR_INTR */
        unsigned int crtp_sel:2;            /* 0 = CRT 1 = RSVD2 2 = RSVD3 3 = RSVD4 */
        unsigned int pta_sel:2;             /* 0 = I2C2; 1 = HDMI; 2 = GMI; 3 = RSVD3 */
        unsigned int undefined_bits_24_25:2;
        unsigned int kbcd_sel:2;            /* 0 = KBC; 1 = NAND; 2 = SDIO2; 3 = MIO */
        unsigned int gpu7_sel:2;            /* 0 = RTCK; 1 = RSVD1; 2 = RSVD2; 3 = RSVD3 */
        unsigned int dtf_sel:2;             /* 0 = I2C3; 1 = RSVD2; 2 = VI; 3 = RSVD4 */
    };

    uint32_t reg32;
} pp_pin_mux_ctl_g_t;

#define PP_PIN_MUX_CTL_H_OFFSET 0x9C
#define PP_PIN_MUX_CTL_H_RESET  0x00000000
typedef union pp_pin_mux_ctl_h_u {
    struct {
        unsigned int dap1_cntrl_mux_select:3;/* 0 = DAC1 1 = DAC2 2 = DAC3 3 = RSVD1 4 = RSVD2 5 = DAP2 6 = DAP3 7 = DAP4 */
        unsigned int dap2_cntrl_mux_select:3;/* 0 = DAC1 1 = DAC2 2 = DAC3 3 = RSVD1 4 = DAP1 5 = RSVD2 6 = DAP3 7 = DAP4 */
        unsigned int dap3_cntrl_mux_select:3;/* 0 = DAC1 1 = DAC2 2 = DAC3 3 = RSVD1 4 = DAP1 5 = DAP2 6 = RSVD2 7 = DAP4 */
        unsigned int dap4_cntrl_mux_select:3;/* 0 = DAC1 1 = DAC2 2 = DAC3 3 = RSVD 4 = DAP1 5 = DAP2 6 = DAP3 7 = RSVD2 */
        unsigned int dac1_sel:2;            /* 0 = DAP1 1 = DAP2 2 = DAP3 3 = DAP4 */
        unsigned int dac2_sel:2;            /* 0 = DAP1 1 = DAP2 2 = DAP3 3 = DAP4 */
        unsigned int dac3_sel:2;            /* 0 = DAP1 1 = DAP2 2 = DAP3 3 = DAP4 */
        unsigned int dap1m_sel:1;           /* 0 = DAP1_SLAVE 1 = DAP1_MASTER */
        unsigned int dap2m_sel:1;           /* 0 = DAP2_SLAVE 1 = DAP2_MASTER */
        unsigned int dap3m_sel:1;           /* 0 = DAP3_SLAVE 1 = DAP3_MASTER */
        unsigned int dap4m_sel:1;           /* 0 = DAP4_SLAVE 1 = DAP4_MASTER */
        unsigned int undefined_bits_22_31:10;
    };

    uint32_t reg32;
} pp_pin_mux_ctl_h_t;

#define PP_PULLUPDOWN_REG_A_OFFSET 0xA0
#define PP_PULLUPDOWN_REG_A_RESET  0x215556AA
typedef union pp_pullupdown_reg_a_u {
    struct {
        unsigned int ata_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int atb_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int atc_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int atd_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int ate_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int dap1_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int dap2_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int dap3_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int dap4_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int dta_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int dtb_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int dtc_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int dtd_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int dte_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int dtf_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int gpv_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
    };

    uint32_t reg32;
} pp_pullupdown_reg_a_t;

#define PP_PULLUPDOWN_REG_B_OFFSET 0xA4
#define PP_PULLUPDOWN_REG_B_RESET  0x6A8865AA
typedef union pp_pullupdown_reg_b_u {
    struct {
        unsigned int rm_pu_pd:2;            /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int i2cp_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int pta_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int gpu7_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int kbca_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int kbcb_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int kbcc_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int kbcd_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int spdi_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_U; 3 = RSVD */
        unsigned int spdo_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int gpu_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int slxa_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int crtp_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int slxc_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int slxd_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int slxk_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
    };

    uint32_t reg32;
} pp_pullupdown_reg_b_t;

#define PP_PULLUPDOWN_REG_C_OFFSET 0xA8
#define PP_PULLUPDOWN_REG_C_RESET  0x00AA6655
typedef union pp_pullupdown_reg_c_u {
    struct {
        unsigned int cdev1_pu_pd:2;         /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int cdev2_pu_pd:2;         /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int spia_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int spib_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int spic_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int spid_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int spie_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int spif_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int spig_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int spih_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int irtx_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int irrx_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int gme_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int undefined_bits_26_27:2;
        unsigned int xm2d_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int xm2c_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
    };

    uint32_t reg32;
} pp_pullupdown_reg_c_t;

#define PP_PULLUPDOWN_REG_D_OFFSET 0xAC
#define PP_PULLUPDOWN_REG_D_RESET  0xA1A55A8A
typedef union pp_pullupdown_reg_d_u {
    struct {
        unsigned int uaa_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int uab_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int uac_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int uad_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int uca_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int ucb_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int ld17_0_pu_pd:2;        /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int ld19_18_pu_pd:2;       /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int ld21_20_pu_pd:2;       /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int ld23_22_pu_pd:2;       /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int ls_pu_pd:2;            /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int lc_pu_pd:2;            /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int csus_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int ddrc_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int sdc_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int sdd_pu_pd:2;           /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
    };

    uint32_t reg32;
} pp_pullupdown_reg_d_t;

#define PP_PULLUPDOWN_REG_E_OFFSET 0xB0
#define PP_PULLUPDOWN_REG_E_RESET  0x1401000A
typedef union pp_pullupdown_reg_e_u {
    struct {
        unsigned int kbcf_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int kbce_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int pmca_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int pmcb_pu_pd:2;          /* 0 = NORMAL; 1 = PULL_DOWN; 2 = PULL_UP; 3 = RSVD */
        unsigned int pmcc_pu_pd:2;          /* 0 = NORMAL 1 = PULL_DOWN 2 = PULL_UP 3 = RSVD */
        unsigned int pmcd_pu_pd:2;          /* 0 = NORMAL 1 = PULL_DOWN 2 = PULL_UP 3 = RSVD */
        unsigned int pmce_pu_pd:2;          /* 0 = NORMAL 1 = PULL_DOWN 2 = PULL_UP 3 = RSVD */
        unsigned int ck32_pu_pd:2;          /* 0 = NORMAL 1 = PULL_DOWN 2 = PULL_UP 3 = RSVD */
        unsigned int uda_pu_pd:2;           /* 0 = NORMAL 1 = PULL_DOWN 2 = PULL_UP 3 = RSVD */
        unsigned int sdio1_pu_pd:2;         /* 0 = NORMAL 1 = PULL_DOWN 2 = PULL_UP 3 = RSVD */
        unsigned int gma_pu_pd:2;           /* 0 = NORMAL 1 = PULL_DOWN 2 = PULL_UP 3 = RSVD */
        unsigned int gmb_pu_pd:2;           /* 0 = NORMAL 1 = PULL_DOWN 2 = PULL_UP 3 = RSVD */
        unsigned int gmc_pu_pd:2;           /* 0 = NORMAL 1 = PULL_DOWN 2 = PULL_UP 3 = RSVD */
        unsigned int gmd_pu_pd:2;           /* 0 = NORMAL 1 = PULL_DOWN 2 = PULL_UP 3 = RSVD */
        unsigned int ddc_pu_pd:2;           /* 0 = NORMAL 1 = PULL_DOWN 2 = PULL_UP 3 = RSVD */
        unsigned int owc_pu_pd:2;           /* 0 = NORMAL 1 = PULL_DOWN 2 = PULL_UP 3 = RSVD */
    };

    uint32_t reg32;
} pp_pullupdown_reg_e_t;

#define PP_MISC_USB_CLK_RST_CTL_OFFSET 0xB4
#define PP_MISC_USB_CLK_RST_CTL_RESET  0x00000201
typedef union pp_misc_usb_clk_rst_ctl_u {
    struct {
        unsigned int misc_usb_ce:1;         /* enable clocks to USB controller; 0 = DISABLE; 1 = ENABLE */
        unsigned int misc_usb2_ce:1;        /* enable clocks to USB2 controller; 0 = DISABLE; 1 = ENABLE */
        unsigned int misc_usb2_clk_ovr_on:1;/* Clock override for USB2 controller; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_3_7:5;
        unsigned int misc_usb_rst:1;        /* Reset (active high) for USB controller; 0 = DISABLE; 1 = ENABLE */
        unsigned int misc_usb2_rst:1;       /* Reset (active high) for USB2 controller; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_10_31:22;
    };

    uint32_t reg32;
} pp_misc_usb_clk_rst_ctl_t;

#define GP_MODEREG_OFFSET 0x800
#define GP_MODEREG_RESET  0x00000000
typedef union gp_modereg_u {
    struct {
        unsigned int standby_ie:1;          /* Standby pad input 1 = STANDBYN is asserted (low voltage), 0 = STANDBYN is deasserted (high voltage) 0 = DEASSERTED 1 = ASSERTED */
        unsigned int undefined_bits_1_7:7;
        unsigned int lpddr_strap0:1;        /* LP-DDR Strap option bit 0 */
        unsigned int lpddr_strap1:1;        /* LP-DDR Strap option bit 1 */
        unsigned int undefined_bits_10_31:22;
    };

    uint32_t reg32;
} gp_modereg_t;

#define GP_HIDREV_OFFSET 0x804
#define GP_HIDREV_RESET  0x00000000
typedef union gp_hidrev_u {
    struct {
        unsigned int hidfam:4;              /* Chip ID family register; 7 = NVIDIA Mobile Applications Processor */
        unsigned int majorrev:4;            /* Chip ID major revision (0: Emulation, 1-15: Silicon) 0 = EMULATION 1 = A01 */
        unsigned int chipid:8;              /* Chip ID */
        unsigned int minorrev:4;            /* Chip ID minor revision (IF MAJORREV==0(Emulation) THEN 0: QT, 1:E388 FPGA) */
        unsigned int undefined_bits_20_31:12;
    };

    uint32_t reg32;
} gp_hidrev_t;

#define GP_EMU_REVID_OFFSET 0x860
#define GP_EMU_REVID_RESET  0x00000000
typedef union gp_emu_revid_u {
    struct {
        unsigned int netlist:16;            /* USED by emulators to indicate netlist #, 0 for silicon */
        unsigned int patch:16;              /* USED by emulators to indicate patch #, 0 for silicon */
    };

    uint32_t reg32;
} gp_emu_revid_t;

#define GP_TRANSACTOR_SCRATCH_OFFSET 0x864
#define GP_TRANSACTOR_SCRATCH_RESET  0x00000000
typedef union gp_transactor_scratch_u {
    struct {
        unsigned int transactor_scratch:32; /* used for emulation to determine test results */
    };

    uint32_t reg32;
} gp_transactor_scratch_t;

#define GP_AOCFG1PADCTRL_OFFSET 0x868
#define GP_AOCFG1PADCTRL_RESET  0x3C58480C
typedef union gp_aocfg1padctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_aocfg1_hsm_en:1;/* AOCFG1 data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_aocfg1_schmt_en:1;/* AOCFG1 data pins schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_aocfg1_lpmd:2; /* AOCFG1 data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_aocfg1_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_aocfg1_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_aocfg1_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_aocfg1_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_aocfg1padctrl_t;

#define GP_AOCFG2PADCTRL_OFFSET 0x86C
#define GP_AOCFG2PADCTRL_RESET  0x3C58480C
typedef union gp_aocfg2padctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_aocfg2_hsm_en:1;/* AOCFG2 data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_aocfg2_schmt_en:1;/* AOCFG2 data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_aocfg2_lpmd:2; /* AOCFG2 data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_aocfg2_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_aocfg2_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_aocfg2_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_aocfg2_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_aocfg2padctrl_t;

#define GP_ATCFG1PADCTRL_OFFSET 0x870
#define GP_ATCFG1PADCTRL_RESET  0x3C58480C
typedef union gp_atcfg1padctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_atcfg1_hsm_en:1;/* ATCFG1 data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_atcfg1_schmt_en:1;/* ATCFG1 data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_atcfg1_lpmd:2; /* ATCFG1 data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_atcfg1_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_atcfg1_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_atcfg1_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_atcfg1_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_atcfg1padctrl_t;

#define GP_ATCFG2PADCTRL_OFFSET 0x874
#define GP_ATCFG2PADCTRL_RESET  0x3C58480C
typedef union gp_atcfg2padctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_atcfg2_hsm_en:1;/* ATCFG2 data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_atcfg2_schmt_en:1;/* ATCFG2 data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_atcfg2_lpmd:2; /* ATCFG2 data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_atcfg2_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_atcfg2_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_atcfg2_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_atcfg2_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_atcfg2padctrl_t;

#define GP_CDEV1CFGPADCTRL_OFFSET 0x878
#define GP_CDEV1CFGPADCTRL_RESET  0x1E2C080C
typedef union gp_cdev1cfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_cdev1cfg_hsm_en:1;/* CDEV1CFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_cdev1cfg_schmt_en:1;/* CDEV1CFG data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_cdev1cfg_lpmd:2;/* CDEV1CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_cdev1cfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_cdev1cfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_cdev1cfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_cdev1cfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_cdev1cfgpadctrl_t;

#define GP_CDEV2CFGPADCTRL_OFFSET 0x87C
#define GP_CDEV2CFGPADCTRL_RESET  0x3C58480C
typedef union gp_cdev2cfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_cdev2cfg_hsm_en:1;/* CDEV2CFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_cdev2cfg_schmt_en:1;/* CDEV2CFG data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_cdev2cfg_lpmd:2;/* CDEV2CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_cdev2cfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_cdev2cfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_cdev2cfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_cdev2cfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_cdev2cfgpadctrl_t;

#define GP_CSUSCFGPADCTRL_OFFSET 0x880
#define GP_CSUSCFGPADCTRL_RESET  0x3C58480C
typedef union gp_csuscfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_csuscfg_hsm_en:1;/* CSUSCFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_csuscfg_schmt_en:1;/* CSUSCFG data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_csuscfg_lpmd:2;/* CSUSCFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_csuscfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_csuscfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_csuscfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_csuscfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_csuscfgpadctrl_t;

#define GP_DAP1CFGPADCTRL_OFFSET 0x884
#define GP_DAP1CFGPADCTRL_RESET  0x3C58480C
typedef union gp_dap1cfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_dap1cfg_hsm_en:1;/* DAP1CFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_dap1cfg_schmt_en:1;/* DAP1CFG data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_dap1cfg_lpmd:2;/* DAP1CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_dap1cfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_dap1cfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_dap1cfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_dap1cfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_dap1cfgpadctrl_t;

#define GP_DAP2CFGPADCTRL_OFFSET 0x888
#define GP_DAP2CFGPADCTRL_RESET  0x3C58480C
typedef union gp_dap2cfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_dap2cfg_hsm_en:1;/* DAP2CFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_dap2cfg_schmt_en:1;/* DAP2CFG data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_dap2cfg_lpmd:2;/* DAP2CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_dap2cfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_dap2cfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_dap2cfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_dap2cfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_dap2cfgpadctrl_t;

#define GP_DAP3CFGPADCTRL_OFFSET 0x88C
#define GP_DAP3CFGPADCTRL_RESET  0x3C58480C
typedef union gp_dap3cfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_dap3cfg_hsm_en:1;/* DAP3CFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_dap3cfg_schmt_en:1;/* DAP3CFG data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_dap3cfg_lpmd:2;/* DAP3CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_dap3cfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_dap3cfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_dap3cfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_dap3cfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_dap3cfgpadctrl_t;

#define GP_DAP4CFGPADCTRL_OFFSET 0x890
#define GP_DAP4CFGPADCTRL_RESET  0x3C58480C
typedef union gp_dap4cfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_dap4cfg_hsm_en:1;/* DAP4CFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_dap4cfg_schmt_en:1;/* DAP4CFG data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_dap4cfg_lpmd:2;/* DAP4CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_dap4cfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_dap4cfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_dap4cfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_dap4cfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_dap4cfgpadctrl_t;

#define GP_DBGCFGPADCTRL_OFFSET 0x894
#define GP_DBGCFGPADCTRL_RESET  0x3C58480C
typedef union gp_dbgcfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_dbgcfg_hsm_en:1;/* DBGCFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_dbgcfg_schmt_en:1;/* DBGCFG data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_dbgcfg_lpmd:2; /* DBGCFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_dbgcfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_dbgcfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_dbgcfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_dbgcfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_dbgcfgpadctrl_t;

#define GP_LCDCFG1PADCTRL_OFFSET 0x898
#define GP_LCDCFG1PADCTRL_RESET  0x3C58480C
typedef union gp_lcdcfg1padctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_lcdcfg1_hsm_en:1;/* LCDCFG1 data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_lcdcfg1_schmt_en:1;/* LCDCFG1 data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_lcdcfg1_lpmd:2;/* LCDCFG1 data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_lcdcfg1_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_lcdcfg1_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_lcdcfg1_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_lcdcfg1_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_lcdcfg1padctrl_t;

#define GP_LCDCFG2PADCTRL_OFFSET 0x89C
#define GP_LCDCFG2PADCTRL_RESET  0x3C58480C
typedef union gp_lcdcfg2padctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_lcdcfg2_hsm_en:1;/* LCDCFG2 data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_lcdcfg2_schmt_en:1;/* LCDCFG2 data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_lcdcfg2_lpmd:2;/* LCDCFG2 data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_lcdcfg2_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_lcdcfg2_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_lcdcfg2_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_lcdcfg2_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_lcdcfg2padctrl_t;

#define GP_SDIO2CFGPADCTRL_OFFSET 0x8A0
#define GP_SDIO2CFGPADCTRL_RESET  0x3C58480C
typedef union gp_sdio2cfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_sdio2cfg_hsm_en:1;/* SDIO2CFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_sdio2cfg_schmt_en:1;/* SDIO2CFG data pins schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_sdio2cfg_lpmd:2;/* SDIO2CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_sdio2cfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_sdio2cfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_sdio2cfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_sdio2cfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_sdio2cfgpadctrl_t;

#define GP_SDIO3CFGPADCTRL_OFFSET 0x8A4
#define GP_SDIO3CFGPADCTRL_RESET  0x3C58480C
typedef union gp_sdio3cfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_sdio3cfg_hsm_en:1;/* SDIO3CFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_sdio3cfg_schmt_en:1;/* SDIO3CFG data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_sdio3cfg_lpmd:2;/* SDIO3CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_sdio3cfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_sdio3cfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_sdio3cfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_sdio3cfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_sdio3cfgpadctrl_t;

#define GP_SPICFGPADCTRL_OFFSET 0x8A8
#define GP_SPICFGPADCTRL_RESET  0x3C58480C
typedef union gp_spicfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_spicfg_hsm_en:1;/* SPICFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_spicfg_schmt_en:1;/* SPICFG data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_spicfg_lpmd:2; /* SPICFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_spicfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_spicfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_spicfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_spicfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_spicfgpadctrl_t;

#define GP_UAACFGPADCTRL_OFFSET 0x8AC
#define GP_UAACFGPADCTRL_RESET  0x3C58480C
typedef union gp_uaacfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_uaacfg_hsm_en:1;/* UAACFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_uaacfg_schmt_en:1;/* UAACFG data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_uaacfg_lpmd:2; /* UAACFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_uaacfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_uaacfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_uaacfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_uaacfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_uaacfgpadctrl_t;

#define GP_UABCFGPADCTRL_OFFSET 0x8B0
#define GP_UABCFGPADCTRL_RESET  0x3C58480C
typedef union gp_uabcfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_uabcfg_hsm_en:1;/* UABCFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_uabcfg_schmt_en:1;/* UABCFG data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_uabcfg_lpmd:2; /* UABCFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_uabcfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_uabcfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_uabcfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_uabcfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_uabcfgpadctrl_t;

#define GP_UART2CFGPADCTRL_OFFSET 0x8B4
#define GP_UART2CFGPADCTRL_RESET  0x3C58480C
typedef union gp_uart2cfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_uart2cfg_hsm_en:1;/* UART2CFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_uart2cfg_schmt_en:1;/* UART2CFG data pins schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_uart2cfg_lpmd:2;/* UART2CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_uart2cfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_uart2cfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_uart2cfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_uart2cfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_uart2cfgpadctrl_t;

#define GP_UART3CFGPADCTRL_OFFSET 0x8B8
#define GP_UART3CFGPADCTRL_RESET  0x3C58480C
typedef union gp_uart3cfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_uart3cfg_hsm_en:1;/* UART3CFG data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_uart3cfg_schmt_en:1;/* UART3CFG data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_uart3cfg_lpmd:2;/* UART3CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_uart3cfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_uart3cfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_uart3cfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_uart3cfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_uart3cfgpadctrl_t;

#define GP_VICFG1PADCTRL_OFFSET 0x8BC
#define GP_VICFG1PADCTRL_RESET  0x3C58480C
typedef union gp_vicfg1padctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_vicfg1_hsm_en:1;/* VICFG1 data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_vicfg1_schmt_en:1;/* VICFG1 data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_vicfg1_lpmd:2; /* VICFG1 data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_vicfg1_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_vicfg1_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_vicfg1_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_vicfg1_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_vicfg1padctrl_t;

#define GP_VICFG2PADCTRL_OFFSET 0x8C0
#define GP_VICFG2PADCTRL_RESET  0x3C58480C
typedef union gp_vicfg2padctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_vicfg2_hsm_en:1;/* VICFG2 data pins high speed mode enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_vicfg2_schmt_en:1;/* VICFG2 data pins Schmidt enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int cfg2tmc_vicfg2_lpmd:2; /* VICFG2 data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_vicfg2_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_vicfg2_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_vicfg2_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_vicfg2_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_vicfg2padctrl_t;

#define GP_XM2CFGAPADCTRL_OFFSET 0x8C4
#define GP_XM2CFGAPADCTRL_RESET  0x0FFFFC00
typedef union gp_xm2cfgapadctrl_u {
    struct {
        unsigned int undefined_bits_0_3:4;
        unsigned int cfg2tmc_xm2cfga_bypass_en:1;/* XM2CFGA data pins bypass outbound flop enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2cfga_preemp_en:1;/* XM2CFGA data pins preemp enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2cfga_clk_sel:1;/* pad clk_sel (ma bits get this value inverted in lpddr2 mode) */
        unsigned int undefined_bits_7_13:7;
        unsigned int cfg2tmc_xm2cfga_cal_drvdn:5;
        unsigned int cfg2tmc_xm2cfga_cal_drvup:5;
        unsigned int cfg2tmc_xm2cfga_cal_drvdn_slwr:4;
        unsigned int cfg2tmc_xm2cfga_cal_drvup_slwf:4;
    };

    uint32_t reg32;
} gp_xm2cfgapadctrl_t;

#define GP_XM2CFGCPADCTRL_OFFSET 0x8C8
#define GP_XM2CFGCPADCTRL_RESET  0x1FFFFFFE
typedef union gp_xm2cfgcpadctrl_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int cfg2tmc_xm2cfgc_schmt_en:1;/* XM2CFGD data pins schmidt enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2cfgc_cal_drvdn_term:5;
        unsigned int cfg2tmc_xm2cfgc_cal_drvup_term:5;
        unsigned int cfg2tmc_xm2cfgc_cal_drvdn:5;
        unsigned int cfg2tmc_xm2cfgc_cal_drvup:5;
        unsigned int cfg2tmc_xm2cfgc_cal_drvdn_slwr:4;
        unsigned int cfg2tmc_xm2cfgc_cal_drvup_slwf:4;
    };

    uint32_t reg32;
} gp_xm2cfgcpadctrl_t;

#define GP_XM2CFGDPADCTRL_OFFSET 0x8CC
#define GP_XM2CFGDPADCTRL_RESET  0x1FFFFFFE
typedef union gp_xm2cfgdpadctrl_u {
    struct {
        unsigned int undefined_bits_0_2:3;
        unsigned int cfg2tmc_xm2cfgd_schmt_en:1;/* XM2CFGD data pins schmidt enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2cfgd_cal_drvdn_term:5;
        unsigned int cfg2tmc_xm2cfgd_cal_drvup_term:5;
        unsigned int cfg2tmc_xm2cfgd_cal_drvdn:5;
        unsigned int cfg2tmc_xm2cfgd_cal_drvup:5;
        unsigned int cfg2tmc_xm2cfgd_cal_drvdn_slwr:4;
        unsigned int cfg2tmc_xm2cfgd_cal_drvup_slwf:4;
    };

    uint32_t reg32;
} gp_xm2cfgdpadctrl_t;

#define GP_XM2CLKCFGPADCTRL_OFFSET 0x8D0
#define GP_XM2CLKCFGPADCTRL_RESET  0x7FFFE001
typedef union gp_xm2clkcfgpadctrl_u {
    struct {
        unsigned int undefined_bit_0:1;
        unsigned int cfg2tmc_xm2clkcfg_bypass_en:1;/* XM2 bypass outbound flop enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2clkcfg_preemp_en:1;/* preemp enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2clkcfg_cal_bypass_en:1;/* XM2CLKCFG bypass drvdn/up calibration  0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_4_13:10;
        unsigned int cfg2tmc_xm2clkcfg_cal_drvdn:5;
        unsigned int cfg2tmc_xm2clkcfg_cal_drvup:5;
        unsigned int cfg2tmc_xm2clkcfg_cal_drvdn_slwr:4;
        unsigned int cfg2tmc_xm2clkcfg_cal_drvup_slwf:4;
    };

    uint32_t reg32;
} gp_xm2clkcfgpadctrl_t;

#define GP_XM2COMPPADCTRL_OFFSET 0x8D4
#define GP_XM2COMPPADCTRL_RESET  0x01F1F008
typedef union gp_xm2comppadctrl_u {
    struct {
        unsigned int cfg2tmc_xm2comp_vref_sel:4;
        unsigned int cfg2tmc_xm2comp_testout_en:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2comp_bias_sel:3;
        unsigned int undefined_bits_8_11:4;
        unsigned int cfg2tmc_xm2comp_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_xm2comp_drvup:5;
        unsigned int undefined_bits_25_31:7;
    };

    uint32_t reg32;
} gp_xm2comppadctrl_t;

#define GP_XM2VTTGENPADCTRL_OFFSET 0x8D8
#define GP_XM2VTTGENPADCTRL_RESET  0x00005500
typedef union gp_xm2vttgenpadctrl_u {
    struct {
        unsigned int cfg2tmc_xm2vttgen_short:1;
        unsigned int cfg2tmc_xm2vttgen_short_pwrgnd:1;/* dummy pin */
        unsigned int undefined_bits_2_7:6;
        unsigned int cfg2tmc_xm2vttgen_vclamp_level:3;
        unsigned int undefined_bit_11:1;
        unsigned int cfg2tmc_xm2vttgen_vauxp_level:3;
        unsigned int undefined_bit_15:1;
        unsigned int cfg2tmc_xm2vttgen_cal_drvdn:3;
        unsigned int undefined_bits_19_23:5;
        unsigned int cfg2tmc_xm2vttgen_cal_drvup:3;
        unsigned int undefined_bits_27_31:5;
    };

    uint32_t reg32;
} gp_xm2vttgenpadctrl_t;

#define GP_PADCTL_DFT_OFFSET 0x8DC
#define GP_PADCTL_DFT_RESET  0x00000000
typedef union gp_padctl_dft_u {
    struct {
        unsigned int pinshort_en:1;         /* Enable pin-shorting for tester mode pin-shorting 0 = DISABLE 1 = ENABLE */
        unsigned int pinshort_sel:1;        /* Select which pins are used for test-mode observe */
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} gp_padctl_dft_t;

#define GP_SDIO1CFGPADCTRL_OFFSET 0x8E0
#define GP_SDIO1CFGPADCTRL_RESET  0x3C58480C
typedef union gp_sdio1cfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_sdio1cfg_hsm_en:1;/* SDIO3CFG data pins high speed mode enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_sdio1cfg_schmt_en:1;/* SDIO3CFG data pins schmidt enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_sdio1cfg_lpmd:2;/* SDIO3CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_sdio1cfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_sdio1cfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_sdio1cfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_sdio1cfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_sdio1cfgpadctrl_t;

#define GP_XM2CFGCPADCTRL2_OFFSET 0x8E4
#define GP_XM2CFGCPADCTRL2_RESET  0x08080042
typedef union gp_xm2cfgcpadctrl2_u {
    struct {
        unsigned int cfg2tmc_xm2cfgc_rx_ft_rec_en:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2cfgc_bypass_en:1;/* XM2CFGD data pins bypass outbound flop enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2cfgc_preemp_en:1;/* XM2CFGD data pins preemp enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2cfgc_ctt_hiz_en:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2cfgc_vref_dqs_en:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2cfgc_vref_dq_en:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2cfgc_clksel_dq:1;
        unsigned int cfg2tmc_xm2cfgc_clksel_dqs:1;
        unsigned int undefined_bits_8_15:8;
        unsigned int cfg2tmc_xm2cfgc_vref_dqs:4;
        unsigned int undefined_bits_20_23:4;
        unsigned int cfg2tmc_xm2cfgc_vref_dq:4;
        unsigned int undefined_bits_28_31:4;
    };

    uint32_t reg32;
} gp_xm2cfgcpadctrl2_t;

#define GP_XM2CFGDPADCTRL2_OFFSET 0x8E8
#define GP_XM2CFGDPADCTRL2_RESET  0x00000002
typedef union gp_xm2cfgdpadctrl2_u {
    struct {
        unsigned int cfg2tmc_xm2cfgd_rx_ft_rec_en:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2cfgd_bypass_en:1;/* XM2CFGD data pins bypass outbound flop enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2cfgd_preemp_en:1;/* XM2CFGD data pins preemp enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_xm2cfgd_ctt_hiz_en:1;/* 0 = DISABLE 1 = ENABLE */
        unsigned int undefined_bits_4_15:12;
        unsigned int cfg2tmc_xm2cfgd0_dlyin_trm:3;/* delay trim for byte 0 */
        unsigned int undefined_bit_19:1;
        unsigned int cfg2tmc_xm2cfgd1_dlyin_trm:3;/* delay trim for byte 1 */
        unsigned int undefined_bit_23:1;
        unsigned int cfg2tmc_xm2cfgd2_dlyin_trm:3;/* delay trim for byte 2 */
        unsigned int undefined_bit_27:1;
        unsigned int cfg2tmc_xm2cfgd3_dlyin_trm:3;/* delay trim for byte 3 */
        unsigned int undefined_bit_31:1;
    };

    uint32_t reg32;
} gp_xm2cfgdpadctrl2_t;

#define GP_CRTCFGPADCTRL_OFFSET 0x8EC
#define GP_CRTCFGPADCTRL_RESET  0x00000002
typedef union gp_crtcfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_crtcfg_hsm_en:1;/* SDIO3CFG data pins high speed mode enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_crtcfg_schmt_en:1;/* SDIO3CFG data pins schmidt enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_crtcfg_lpmd:2; /* SDIO3CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_crtcfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_crtcfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_crtcfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_crtcfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_crtcfgpadctrl_t;

#define GP_DDCCFGPADCTRL_OFFSET 0x8F0
#define GP_DDCCFGPADCTRL_RESET  0x3C58480C
typedef union gp_ddccfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_ddccfg_hsm_en:1;/* SDIO3CFG data pins high speed mode enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_ddccfg_schmt_en:1;/* SDIO3CFG data pins schmidt enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_ddccfg_lpmd:2; /* SDIO3CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_ddccfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_ddccfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_ddccfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_ddccfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_ddccfgpadctrl_t;

#define GP_GMACFGPADCTRL_OFFSET 0x8F4
#define GP_GMACFGPADCTRL_RESET  0x3C58480C
typedef union gp_gmacfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_gmacfg_hsm_en:1;/* SDIO3CFG data pins high speed mode enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_gmacfg_schmt_en:1;/* SDIO3CFG data pins schmidt enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_gmacfg_lpmd:2; /* SDIO3CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_gmacfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_gmacfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_gmacfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_gmacfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_gmacfgpadctrl_t;

#define GP_GMBCFGPADCTRL_OFFSET 0x8F8
#define GP_GMBCFGPADCTRL_RESET  0x1E2C2406
typedef union gp_gmbcfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_gmbcfg_hsm_en:1;/* SDIO3CFG data pins high speed mode enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_gmbcfg_schmt_en:1;/* SDIO3CFG data pins schmidt enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_gmbcfg_lpmd:2; /* SDIO3CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_gmbcfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_gmbcfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_gmbcfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_gmbcfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_gmbcfgpadctrl_t;

#define GP_GMCCFGPADCTRL_OFFSET 0x8FC
#define GP_GMCCFGPADCTRL_RESET  0x3C58480C
typedef union gp_gmccfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_gmccfg_hsm_en:1;/* SDIO3CFG data pins high speed mode enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_gmccfg_schmt_en:1;/* SDIO3CFG data pins schmidt enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_gmccfg_lpmd:2; /* SDIO3CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_gmccfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_gmccfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_gmccfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_gmccfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_gmccfgpadctrl_t;

#define GP_GMDCFGPADCTRL_OFFSET 0x900
#define GP_GMDCFGPADCTRL_RESET  0x3C58480C
typedef union gp_gmdcfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_gmdcfg_hsm_en:1;/* SDIO3CFG data pins high speed mode enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_gmdcfg_schmt_en:1;/* SDIO3CFG data pins schmidt enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_gmdcfg_lpmd:2; /* SDIO3CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_gmdcfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_gmdcfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_gmdcfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_gmdcfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_gmdcfgpadctrl_t;

#define GP_GMECFGPADCTRL_OFFSET 0x904
#define GP_GMECFGPADCTRL_RESET  0x3C58480C
typedef union gp_gmecfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_gmecfg_hsm_en:1;/* SDIO3CFG data pins high speed mode enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_gmecfg_schmt_en:1;/* SDIO3CFG data pins schmidt enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_gmecfg_lpmd:2; /* SDIO3CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_gmecfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_gmecfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_gmecfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_gmecfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_gmecfgpadctrl_t;

#define GP_OWRCFGPADCTRL_OFFSET 0x908
#define GP_OWRCFGPADCTRL_RESET  0x3C58480C
typedef union gp_owrcfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_owrcfg_hsm_en:1;/* SDIO3CFG data pins high speed mode enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_owrcfg_schmt_en:1;/* SDIO3CFG data pins schmidt enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_owrcfg_lpmd:2; /* SDIO3CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_owrcfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_owrcfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_owrcfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_owrcfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_owrcfgpadctrl_t;

#define GP_UADCFGPADCTRL_OFFSET 0x90C
#define GP_UADCFGPADCTRL_RESET  0x3C58480C
typedef union gp_uadcfgpadctrl_u {
    struct {
        unsigned int undefined_bits_0_1:2;
        unsigned int cfg2tmc_udacfg_hsm_en:1;/* SDIO3CFG data pins high speed mode enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_udacfg_schmt_en:1;/* SDIO3CFG data pins schmidt enable 0 = DISABLE 1 = ENABLE */
        unsigned int cfg2tmc_udacfg_lpmd:2; /* SDIO3CFG data pins low power mode select */
        unsigned int undefined_bits_6_11:6;
        unsigned int cfg2tmc_udacfg_cal_drvdn:5;
        unsigned int undefined_bits_17_19:3;
        unsigned int cfg2tmc_udacfg_cal_drvup:5;
        unsigned int undefined_bits_25_27:3;
        unsigned int cfg2tmc_udacfg_cal_drvdn_slwr:2;
        unsigned int cfg2tmc_udacfg_cal_drvup_slwf:2;
    };

    uint32_t reg32;
} gp_uadcfgpadctrl_t;

#define DAS_DAP_CTRL_SEL_OFFSET 0xC00
#define DAS_DAP_CTRL_SEL_RESET  0x00000000
typedef union das_dap_ctrl_sel_u {
    struct {
        unsigned int dap_ctrl_sel:5;        /* DAP selection bits to select one of the three DACs or one of the five DAPs 0 = DAC1 1 = DAC2 2 = DAC3 16 = DAP1 17 = DAP2 18 = DAP3 19 = DAP4 20 = DAP5 | */
        unsigned int undefined_bits_5_28:24;
        unsigned int dap_sdata2_rx_tx:1;    /* To program sdata2 in either tx or rx mode when two or more DAPs are in by-pass mode 0 = RX 1 = TX */
        unsigned int dap_sdata1_tx_rx:1;    /* To program sdata1 in either tx or rx mode when two or more DAPs are in by-pass mode 0 = TX 1 = RX */
        unsigned int dap_ms_sel:1;          /* This bit is programmed to put particular DAP is either in master or slave mode when two or more DAPs are in by-pass mode. 0 = SLAVE 1 = MASTER */
    };

    uint32_t reg32;
} das_dap_ctrl_sel_t;

#define DAS_DAC_INPUT_DATA_CLK_SEL_OFFSET 0xC40
#define DAS_DAC_INPUT_DATA_CLK_SEL_RESET  0x00000000
typedef union das_dac_input_data_clk_sel_u {
    struct {
        unsigned int dac_clk_sel:4;         /* These bits are to control the selection of bit clock and fsync for DACs. 0 = DAP1 1 = DAP2 2 = DAP3 3 = DAP4 4 = DAP5 */
        unsigned int undefined_bits_4_23:20;
        unsigned int dac_sdata1_sel:4;      /* These bits are to control the selection of sdata1 input for DACs. 0 = DAP1 1 = DAP2 2 = DAP3 3 = DAP4 4 = DAP5 */
        unsigned int dac_sdata2_sel:4;      /* These bits are to control the selection of sdata2 input for DACs.  0 = DAP1 1 = DAP2 2 = DAP3 3 = DAP4 4 = DAP5 */
    };

    uint32_t reg32;
} das_dac_input_data_clk_sel_t;

#define PP_MISC_SAVE_THE_DAY_OFFSET 0x7C
#define PP_MISC_SAVE_THE_DAY_RESET  0x00000000
typedef union pp_misc_save_the_day_u {
    struct {
        unsigned int save_the_day_d:8;      /* Reserved */
        unsigned int save_the_day_c:8;      /* Reserved */
        unsigned int save_the_day_b:8;      /* Reserved */
        unsigned int save_the_day_a:8;      /* Reserved */
    };

    uint32_t reg32;
} pp_misc_save_the_day_t;

#define ASYNC_COREPWRCONFIG_OFFSET 0x400
#define ASYNC_COREPWRCONFIG_RESET  0x00000000
typedef union async_corepwrconfig_u {
    struct {
        unsigned int td_corepwr_en:1;       /* Power is on in TDA/TDB partitions */
        unsigned int ve_corepwr_en:1;       /* Power is on in VE/MPE partitions */
        unsigned int cpu_corepwr_en:1;      /* Power is on in CPU partition */
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} async_corepwrconfig_t;

#define ASYNC_EMCPADEN_OFFSET 0x410
#define ASYNC_EMCPADEN_RESET  0x00000003
typedef union async_emcpaden_u {
    struct {
        unsigned int emc_pad_output_en:1;   /* outputs enable for EMC pads */
        unsigned int emc_pad_input_en:1;    /* inputs enable for EMC pads */
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} async_emcpaden_t;

#define ASYNC_VCLKCTRL_OFFSET 0x42C
#define ASYNC_VCLKCTRL_RESET  0x00000000
typedef union async_vclkctrl_u {
    struct {
        unsigned int vclk_pad_ie:1;         /* VCLK input enable */
        unsigned int vclk_pad_inversion:1;  /* VCLK invert enable */
        unsigned int undefined_bits_2_31:30;
    };

    uint32_t reg32;
} async_vclkctrl_t;

#define ASYNC_TVDACVHSYNCCTRL_OFFSET 0x438
#define ASYNC_TVDACVHSYNCCTRL_RESET  0x00000000
typedef union async_tvdacvhsyncctrl_u {
    struct {
        unsigned int tvdac_hsyncdly:2;
        unsigned int tvdac_vsyncdly:2;
        unsigned int undefined_bits_4_31:28;
    };

    uint32_t reg32;
} async_tvdacvhsyncctrl_t;

#define ASYNC_TVDACCNTL_OFFSET 0x43C
#define ASYNC_TVDACCNTL_RESET  0x0000083B
typedef union async_tvdaccntl_u {
    struct {
        unsigned int dac_iddq:1;            /* Power down everything including the band-gap */
        unsigned int dac_powerdown:1;       /* Power down everything except the band-gap */
        unsigned int dac_detect_en:1;       /* Power down everything including the band-gap */
        unsigned int dac_sleepr:1;          /* Low power (sleep) mode. SHut down OUTR output */
        unsigned int dac_sleepg:1;          /* Low power (sleep) mode. SHut down OUTG output */
        unsigned int dac_sleepb:1;          /* Low power (sleep) mode. SHut down OUTB output */
        unsigned int dac_comp_th:2;         /* Adjust threshold voltage of comparator inside DAC */
        unsigned int dac_bgap_avg_on:1;     /* Turn bandgap averaging on/off */
        unsigned int dac_bgap_curve:3;      /* To adjust temp coeff */
        unsigned int dac_bgap_cntl:4;       /* Control bits for bandgap */
        unsigned int dac_atest:3;           /* For debugging. Selects internal analog output to be sent out of VREF pin */
        unsigned int dac_cntl:5;            /* Reserved for additional control */
        unsigned int undefined_bit_24:1;
        unsigned int dac_compr_en:1;        /* Enable COMPOUTR output */
        unsigned int dac_compg_en:1;        /* Enable COMPOUTG output */
        unsigned int dac_compb_en:1;        /* Enable COMPOUTB output */
        unsigned int dac_plug_ok:1;         /* Indicate load status */
        unsigned int undefined_bits_29_31:3;
    };

    uint32_t reg32;
} async_tvdaccntl_t;

#define ASYNC_TVDACSTATUS_OFFSET 0x440
#define ASYNC_TVDACSTATUS_RESET  0x00000000
#define ASYNC_TVDACSTATUS_WRMASK 0xFFFFFFF8
typedef union async_tvdacstatus_u {
    struct {
        unsigned int dac_compoutr:1;        /* Channel R comparator output for auto-detect 0 = COMPINR > threshold 1 = COMPINR < threshold, or when POWERDOWN==1 comparison threshold = 0.325V */
        unsigned int dac_compoutg:1;        /* Channel G comparator output for auto-detect 0 = COMPING > threshold 1 = COMPING < threshold, or when POWERDOWN==1 comparison threshold = 0.325V */
        unsigned int dac_compoutb:1;        /* Channel B comparator output for auto-detect 0 = COMPINB > threshold 1 = COMPINB < threshold, or when POWERDOWN==1 comparison threshold = 0.325V */
        unsigned int undefined_bits_3_31:29;
    };

    uint32_t reg32;
} async_tvdacstatus_t;

#define ASYNC_TVDACDINCONFIG_OFFSET 0x444
#define ASYNC_TVDACDINCONFIG_RESET  0x00000002
typedef union async_tvdacdinconfig_u {
    struct {
        unsigned int dac_fifo_th:3;         /* Data Input FIFO threshold */
        unsigned int undefined_bit_3:1;
        unsigned int dac_source:2;          /* INPUT source for TVDAC */
        unsigned int undefined_bits_6_7:2;
        unsigned int dac_din_oride_en:1;    /* Override DAC DIN inputs */
        unsigned int undefined_bit_9:1;
        unsigned int dac_din_oride:10;      /* DIN override */
        unsigned int dac_ampin:8;           /* AMPIN */
        unsigned int undefined_bits_28_31:4;
    };

    uint32_t reg32;
} async_tvdacdinconfig_t;

#define ASYNC_INT_STATUS_OFFSET 0x448
#define ASYNC_INT_STATUS_RESET  0x00000000
#define ASYNC_INT_STATUS_WRMASK 0xFFFFE07F
typedef union async_int_status_u {
    struct {
        unsigned int undefined_bits_0_6:7;
        unsigned int hgp7_int_status:1;     /* HGP7 Interrupt Status  (this is cleared on write)   0= interrupt not pending   1= interrupt pending */
        unsigned int hgp8_int_status:1;     /* HGP8 Interrupt Status  (this is cleared on write)   0= interrupt not pending   1= interrupt pending */
        unsigned int hgp9_int_status:1;     /* HGP9 Interrupt Status  (this is cleared on write)   0= interrupt not pending   1= interrupt pending */
        unsigned int hgp10_int_status:1;    /* HGP10 Interrupt Status  (this is cleared on write)   0= interrupt not pending   1= interrupt pending */
        unsigned int hgp11_int_status:1;    /* HGP11 Interrupt Status  (this is cleared on write)   0= interrupt not pending   1= interrupt pending */
        unsigned int hgp12_int_status:1;    /* HGP12 Interrupt Status  (this is cleared on write)   0= interrupt not pending   1= interrupt pending */
        unsigned int undefined_bits_13_31:19;
    };

    uint32_t reg32;
} async_int_status_t;

#define ASYNC_INT_MASK_OFFSET 0x44C
#define ASYNC_INT_MASK_RESET  0x00000000
typedef union async_int_mask_u {
    struct {
        unsigned int undefined_bits_0_6:7;
        unsigned int hgp7_int_mask:1;       /* HGP7 Interrupt Mask   0= interrupt masked   1= interrupt not masked */
        unsigned int hgp8_int_mask:1;       /* HGP8 Interrupt Mask   0= interrupt masked   1= interrupt not masked */
        unsigned int hgp9_int_mask:1;       /* HGP9 Interrupt Mask   0= interrupt masked   1= interrupt not masked */
        unsigned int hgp10_int_mask:1;      /* HGP10 Interrupt Mask   0= interrupt masked   1= interrupt not masked */
        unsigned int hgp11_int_mask:1;      /* HGP11 Interrupt Mask   0= interrupt masked   1= interrupt not masked */
        unsigned int hgp12_int_mask:1;      /* HGP12 Interrupt Mask   0= interrupt masked   1= interrupt not masked */
        unsigned int undefined_bits_13_31:19;
    };

    uint32_t reg32;
} async_int_mask_t;

#define ASYNC_INT_POLARITY_OFFSET 0x450
#define ASYNC_INT_POLARITY_RESET  0x00000000
typedef union async_int_polarity_u {
    struct {
        unsigned int undefined_bits_0_6:7;
        unsigned int hgp7_int_polarity:1;   /* HGP7 Interrupt Polarity   0= falling edge interrupt   1= rising edge interrupt */
        unsigned int hgp8_int_polarity:1;   /* HGP8 Interrupt Polarity   0= falling edge interrupt   1= rising edge interrupt */
        unsigned int hgp9_int_polarity:1;   /* HGP9 Interrupt Polarity   0= falling edge interrupt   1= rising edge interrupt */
        unsigned int hgp10_int_polarity:1;  /* HGP10 Interrupt Polarity   0= falling edge interrupt   1= rising edge interrupt */
        unsigned int hgp11_int_polarity:1;  /* HGP11 Interrupt Polarity   0= falling edge interrupt   1= rising edge interrupt */
        unsigned int hgp12_int_polarity:1;  /* HGP12 Interrupt Polarity   0= falling edge interrupt   1= rising edge interrupt */
        unsigned int undefined_bits_13_31:19;
    };

    uint32_t reg32;
} async_int_polarity_t;

#define ASYNC_INT_TYPE_SELECT_OFFSET 0x454
#define ASYNC_INT_TYPE_SELECT_RESET  0x00000000
typedef union async_int_type_select_u {
    struct {
        unsigned int undefined_bits_0_6:7;
        unsigned int hgp7_int_type:1;       /* HGP7 Interrupt Type   0= Edge type   1= Level type */
        unsigned int hgp8_int_type:1;       /* HGP8 Interrupt Polarity   0= Edge type   1= Level type */
        unsigned int hgp9_int_type:1;       /* HGP9 Interrupt Polarity   0= Edge type   1= Level type */
        unsigned int hgp10_int_type:1;      /* HGP10 Interrupt Polarity   0= Edge type   1= Level type */
        unsigned int hgp11_int_type:1;      /* HGP11 Interrupt Polarity   0= Edge type   1= Level type */
        unsigned int hgp12_int_type:1;      /* HGP12 Interrupt Polarity   0= Edge type   1= Level type */
        unsigned int undefined_bits_13_31:19;
    };

    uint32_t reg32;
} async_int_type_select_t;

#define DAS_DAP_CTRL_SEL_1_OFFSET 0xC04
#define DAS_DAP_CTRL_SEL_1_RESET  0x00000000
typedef union das_dap_ctrl_sel_1_u {
    struct {
        unsigned int dap_ctrl_sel:5;        /* DAP selection bits to select one of the three DACs or one of the five DAPs */
        unsigned int undefined_bits_5_28:24;
        unsigned int dap_sdata2_rx_tx:1;    /* To program sdata2 in either tx or rx mode when two or more DAPs are in by-pass mode */
        unsigned int dap_sdata1_tx_rx:1;    /* To program sdata1 in either tx or rx mode when two or more DAPs are in by-pass mode */
        unsigned int dap_ms_sel:1;          /* This bit is programmed to put particular DAP is either in master or slave mode when two or more DAPs are in by-pass mode. */
    };

    uint32_t reg32;
} das_dap_ctrl_sel_1_t;

#define DAS_DAP_CTRL_SEL_2_OFFSET 0xC08
#define DAS_DAP_CTRL_SEL_2_RESET  0x00000000
typedef union das_dap_ctrl_sel_2_u {
    struct {
        unsigned int dap_ctrl_sel:5;        /* DAP selection bits to select one of the three DACs or one of the five DAPs */
        unsigned int undefined_bits_5_28:24;
        unsigned int dap_sdata2_rx_tx:1;    /* To program sdata2 in either tx or rx mode when two or more DAPs are in by-pass mode */
        unsigned int dap_sdata1_tx_rx:1;    /* To program sdata1 in either tx or rx mode when two or more DAPs are in by-pass mode */
        unsigned int dap_ms_sel:1;          /* This bit is programmed to put particular DAP is either in master or slave mode when two or more DAPs are in by-pass mode. */
    };

    uint32_t reg32;
} das_dap_ctrl_sel_2_t;

#define DAS_DAP_CTRL_SEL_3_OFFSET 0xC0C
#define DAS_DAP_CTRL_SEL_3_RESET  0x00000000
typedef union das_dap_ctrl_sel_3_u {
    struct {
        unsigned int dap_ctrl_sel:5;        /* DAP selection bits to select one of the three DACs or one of the five DAPs */
        unsigned int undefined_bits_5_28:24;
        unsigned int dap_sdata2_rx_tx:1;    /* To program sdata2 in either tx or rx mode when two or more DAPs are in by-pass mode */
        unsigned int dap_sdata1_tx_rx:1;    /* To program sdata1 in either tx or rx mode when two or more DAPs are in by-pass mode */
        unsigned int dap_ms_sel:1;          /* This bit is programmed to put particular DAP is either in master or slave mode when two or more DAPs are in by-pass mode. */
    };

    uint32_t reg32;
} das_dap_ctrl_sel_3_t;

#define DAS_DAP_CTRL_SEL_4_OFFSET 0xC10
#define DAS_DAP_CTRL_SEL_4_RESET  0x00000000
typedef union das_dap_ctrl_sel_4_u {
    struct {
        unsigned int dap_ctrl_sel:5;        /* DAP selection bits to select one of the three DACs or one of the five DAPs */
        unsigned int undefined_bits_5_28:24;
        unsigned int dap_sdata2_rx_tx:1;    /* To program sdata2 in either tx or rx mode when two or more DAPs are in by-pass mode */
        unsigned int dap_sdata1_tx_rx:1;    /* To program sdata1 in either tx or rx mode when two or more DAPs are in by-pass mode */
        unsigned int dap_ms_sel:1;          /* This bit is programmed to put particular DAP is either in master or slave mode when two or more DAPs are in by-pass mode. */
    };

    uint32_t reg32;
} das_dap_ctrl_sel_4_t;

#define DAS_DAC_INPUT_DATA_CLK_SEL_1_OFFSET 0xC44
#define DAS_DAC_INPUT_DATA_CLK_SEL_1_RESET  0x00000000
typedef union das_dac_input_data_clk_sel_1_u {
    struct {
        unsigned int dac_clk_sel:4;         /* These bits are to control the selection of bit clock and fsync for DACs. */
        unsigned int undefined_bits_4_23:20;
        unsigned int dac_sdata1_sel:4;      /* These bits are to control the selection of sdata1 input for DACs. */
        unsigned int dac_sdata2_sel:4;      /* These bits are to control the selection of sdata2 input for DACs.  */
    };

    uint32_t reg32;
} das_dac_input_data_clk_sel_1_t;

#define DAS_DAC_INPUT_DATA_CLK_SEL_2_OFFSET 0xC48
#define DAS_DAC_INPUT_DATA_CLK_SEL_2_RESET  0x00000000
typedef union das_dac_input_data_clk_sel_2_u {
    struct {
        unsigned int dac_clk_sel:4;         /* These bits are to control the selection of bit clock and fsync for DACs. */
        unsigned int undefined_bits_4_23:20;
        unsigned int dac_sdata1_sel:4;      /* These bits are to control the selection of sdata1 input for DACs. */
        unsigned int dac_sdata2_sel:4;      /* These bits are to control the selection of sdata2 input for DACs.  */
    };

    uint32_t reg32;
} das_dac_input_data_clk_sel_2_t;

#endif // TEGRA_APB_MISC_H
