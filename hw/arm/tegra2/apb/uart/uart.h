/*
 * ARM NVIDIA Tegra2 emulation.
 *
 * Copyright (c) 2014-2015 Dmitry Osipenko <digetx@gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the
 *  Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* Autogenerated from TRM v02p */

#ifndef TEGRA_UART_H
#define TEGRA_UART_H

#define THR_DLAB_OFFSET 0x0
#define THR_DLAB_RESET  0x00000000
typedef union thr_dlab_u {
    struct {
        unsigned int thr_rbr_dll:8;         /* Transmit holding register, holds the character to be transmitted by the UART. In FIFO mode, a write to this FIFO places the data at the end of the FIFO; Receive Buffer Register. Rx Data read from here; Divisor Latch LSB (low 8 bits of 16-bit Baud Divisor) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} thr_dlab_t;

#define IER_DLAB_OFFSET 0x4
#define IER_DLAB_RESET  0x00000000
typedef union ier_dlab_u {
    struct {
        unsigned int ie_rhr:1;              /* Interrupt Enable for Received Data Interrupt; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_thr:1;              /* Interrupt Enable for Transmitter Holding Register Empty interrupt; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_rxs:1;              /* Interrupt Enable for Receiver Line Status Interrupt; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_msi:1;              /* Interrupt Enable for Modem Status Interrupt; 0 = DISABLE; 1 = ENABLE NOTE: Modem Status Interrupt (IE_MSI) should not be enabled when the modem is used in 4-pin or 2-pin configurations. If enabled in these configurations phantom interrupts may be generated. */
        unsigned int ie_rx_timeout:1;       /* Interrupt Enable for Rx FIFO timeout 1 = Enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int ie_eord:1;             /* Interrupt Enable for End of Received Data 1 = Enable; 0 = DISABLE; 1 = ENABLE */
        unsigned int n_a:2;                 /* Reserved */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} ier_dlab_t;

#define IIR_FCR_OFFSET 0x8
#define IIR_FCR_RESET  0x00000000
typedef union iir_fcr_u {
    struct {
        unsigned int is_sta_fcr_en_fifo:1;  /* Interrupt Pending if ZERO; 0 = INTR_PEND; 1 = NO_INTR_PEND; 1 = Enable the transmit and receive FIFO. This bit should be enabled; 0 = DISABLE; 1 = ENABLE */
        unsigned int is_pri0_rx_clr:1;      /* Encoded Interrupt ID Refer to IIR[3:0] table above; 0 = DISABLE; 1 = ENABLE; 1 = Clears the contents of the receive FIFO and resets its counter logic to 0 (the receive shift register is not cleared or altered). This bit returns to 0 after clearing the FIFOs; 0 = NO_CLEAR; 1 = CLEAR */
        unsigned int is_pri1_tx_clr:1;      /* Encoded Interrupt ID Refer to IIR[3:0] table above; 0 = DISABLE; 1 = ENABLE; 1 = Clears the contents of the transmit FIFO and resets its counter logic to 0 (the transmit shift register is not cleared or altered). This bit returns to 0 after clearing the FIFOs; 0 = NO_CLEAR; 1 = CLEAR */
        unsigned int is_pri2_dma:1;         /* Encoded Interrupt ID Refer to IIR[3:0] table above; 0 = DISABLE; 1 = ENABLE; 0:DMA_Mode_0 1:DMA_MODE_1; 0 = NO_CHANGE; 1 = CHANGE */
        unsigned int n_a_tx_trig:2;         /* Reserved; FIFO_COUNT_GREATER_12 deprecated 0 = FIFO_COUNT_GREATER_16 1 = FIFO_COUNT_GREATER_8 2 = FIFO_COUNT_GREATER_4 3 = FIFO_COUNT_GREATER_1 0 = FIFO_COUNT_GREATER_12 */
        unsigned int en_fifo_rx_trig:2;     /* FIFO Mode Status 0=16450 mode(no FIFO), 1 = 16550 mode (FIFO); 1 = MODE_16550; 0 = MODE_16450; FIFO_COUNT_GREATER_12 deprecated  0 = FIFO_COUNT_GREATER_1 1 = FIFO_COUNT_GREATER_4 2 = FIFO_COUNT_GREATER_8 3 = FIFO_COUNT_GREATER_16 3 = FIFO_COUNT_GREATER_12 */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} iir_fcr_t;

#define LCR_OFFSET 0xC
#define LCR_RESET  0x00000000
typedef union lcr_u {
    struct {
        unsigned int wd_size:2;             /* 3=Word length of 8; 0 = WORD_LENGTH_5; 1 = WORD_LENGTH_6; 2 = WORD_LENGTH_7; 3 = WORD_LENGTH_8 */
        unsigned int stop:1;                /* 0 = Transmit 1 stop bit, 1 = Transmit 2 stop bits (receiver always checks for 1 stop bit); 0 = DISABLE; 1 = ENABLE */
        unsigned int par:1;                 /* 0 = No parity sent; 0 = NO_PARITY; 1 = PARITY */
        unsigned int even:1;                /* Even parity format. There will always be an even number of 1s in the binary representation (PAR = 1); 0 = DISABLE; 1 = ENABLE */
        unsigned int set_p:1;               /* Set (force) parity to value in LCR [4]; 0 = NO_PARITY; 1 = PARITY */
        unsigned int set_b:1;               /* Set BREAK condition -- Transmitter will send all zeroes to indicate BREAK; 0 = NO_BREAK; 1 = BREAK */
        unsigned int dlab:1;                /* Divisor Latch Access Bit (set to allow programming of the DLH, DLM Divisors); 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} lcr_t;

#define MCR_OFFSET 0x10
#define MCR_RESET  0x00000000
typedef union mcr_u {
    struct {
        unsigned int dtr:1;                 /* 1 = Force DTR to high; 0 = FORCE_DTR_HI; 1 = FORCE_DTR_LOW */
        unsigned int rts:1;                 /* 0 = Force RTS to high if RTS HW flow control not enabled; 0 = FORCE_RTS_HI; 1 = FORCE_RTS_LOW */
        unsigned int out1:1;                /* nOUT1 (Not Used); 0 = DISABLE; 1 = ENABLE */
        unsigned int out2:1;                /* nOUT2 (Not Used); 0 = DISABLE; 1 = ENABLE */
        unsigned int loopbk:1;              /* 1 = enable internal loop back of Serial Out to In; 0 = DISABLE; 1 = ENABLE */
        unsigned int cts_en:1;              /* 1 = Enable CTS Hardware Flow Control; 0 = DISABLE; 1 = ENABLE */
        unsigned int rts_en:1;              /* 1 = Enable RTS Hardware Flow Control; 0 = DISABLE; 1 = ENABLE */
        unsigned int n_a:1;                 /* Reserved */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} mcr_t;

#define LSR_OFFSET 0x14
#define LSR_RESET  0x00000000
typedef union lsr_u {
    struct {
        unsigned int rdr:1;                 /* 1 = Receiver Data Ready (Data available to read); 0 = NO_DATA_IN_FIFO; 1 = DATA_IN_FIFO */
        unsigned int ovrf:1;                /* 1 = Receiver Overrun Error; 0 = NO_OVERRUN_ERROR; 1 = OVERRUN_ERROR */
        unsigned int perr:1;                /* 1 = Parity Error; 0 = NO_PARITY_ERR; 1 = PARITY_ERR */
        unsigned int ferr:1;                /* 1 = Framing Errpr; 0 = NO_FRAME_ERR; 1 = FRAME_ERR */
        unsigned int brk:1;                 /* 1 = BREAK condition detected on line; 0 = NO_BREAK; 1 = BREAK */
        unsigned int thre:1;                /* 1 = Transmit Holding Register is Empty -- OK to write data; 0 = FULL; 1 = EMPTY */
        unsigned int tmty:1;                /* Transmit Shift Reg empty status; 0 = NO_EMPTY; 1 = EMPTY */
        unsigned int fifoe:1;               /* 1 = Receive FIFO Error; 0 = NO_ERR; 1 = ERR */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} lsr_t;

#define MSR_OFFSET 0x18
#define MSR_RESET  0x00000000
typedef union msr_u {
    struct {
        unsigned int dcts:1;                /* Change (Delta) in CTS state detected; 0 = DISABLE; 1 = ENABLE */
        unsigned int ddsr:1;                /* Change (Delta) in DSR state detected; 0 = DISABLE; 1 = ENABLE */
        unsigned int dri:1;                 /* Change (Delta) in RI state detected; 0 = DISABLE; 1 = ENABLE */
        unsigned int dcd:1;                 /* Change (Delta) in CD state detected; 0 = DISABLE; 1 = ENABLE */
        unsigned int cts:1;                 /* State of Clear to send pin; 0 = DISABLE; 1 = ENABLE */
        unsigned int dsr:1;                 /* State of Data set ready pin; 0 = DISABLE; 1 = ENABLE */
        unsigned int ri:1;                  /* State of Ring Indicator pin; 0 = DISABLE; 1 = ENABLE */
        unsigned int cd:1;                  /* State of Carrier detect pin; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} msr_t;

#define SPR_OFFSET 0x1C
#define SPR_RESET  0x00000000
typedef union spr_u {
    struct {
        unsigned int spr_a:8;               /* Scratchpad register (not used internally) */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} spr_t;

#define IRDA_CSR_OFFSET 0x20
#define IRDA_CSR_RESET  0x00000000
typedef union irda_csr_u {
    struct {
        unsigned int invert_rxd:1;          /* Inverts the normally inactive high RXD pin; 0 = DISABLE; 1 = ENABLE */
        unsigned int invert_txd:1;          /* Inverts the normally inactive high TXD pin; 0 = DISABLE; 1 = ENABLE */
        unsigned int invert_cts:1;          /* Inverts the normally inactive high nCTS pin; 0 = DISABLE; 1 = ENABLE */
        unsigned int invert_rts:1;          /* Inverts the normally inactive high nRTS pin; 0 = DISABLE; 1 = ENABLE */
        unsigned int n_a:2;                 /* Reserved = 0 */
        unsigned int pwt_a:1;               /* 0=3/16th Baud Pulse, 1=4/16; 0 = BAUD_PULSE_3_14; 1 = BAUD_PULSE_4_14 */
        unsigned int sir_a:1;               /* 1 = Enable SIR coder 0 = Disable SIR coder; 0 = DISABLE; 1 = ENABLE */
        unsigned int undefined_bits_8_31:24;
    };

    uint32_t reg32;
} irda_csr_t;

#define ASR_OFFSET 0x3C
#define ASR_RESET  0x00000000
typedef union asr_u {
    struct {
        unsigned int rx_rate_sense_l:8;     /* Shows the bits[7:0] of the count of clock edges between two successive clock edges */
        unsigned int rx_rate_sense_h:8;     /* Shows the bits [15:8] of the count of clock edges between two successive clock edges */
        unsigned int n_a:14;                /* Reserved = 0 */
        unsigned int busy:1;                /* This bit is set when there is a write to ASR and is reset when the controller finishes counting the clock edges between two successive clock edges; 0 = NO_BUSY; 1 = BUSY */
        unsigned int valid:1;               /* This bit is set when the controller finishes counting the clocks between two successive clock edges after there is a write to ASR with dont care data; 0 = UN_SET; 1 = SET */
    };

    uint32_t reg32;
} asr_t;

#endif // TEGRA_UART_H
